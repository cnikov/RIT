{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n  TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n  forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n  constructor() {\n    this._lastState = null;\n  }\n  set(lastCopiedValue, data) {\n    this._lastState = {\n      lastCopiedValue,\n      data\n    };\n  }\n  get(pastedText) {\n    if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n      // match!\n      return this._lastState.data;\n    }\n    this._lastState = null;\n    return null;\n  }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n  constructor() {\n    this._lastTypeTextLength = 0;\n  }\n  handleCompositionUpdate(text) {\n    text = text || '';\n    const typeInput = {\n      text: text,\n      replacePrevCharCnt: this._lastTypeTextLength,\n      replaceNextCharCnt: 0,\n      positionDelta: 0\n    };\n    this._lastTypeTextLength = text.length;\n    return typeInput;\n  }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n  get textAreaState() {\n    return this._textAreaState;\n  }\n  constructor(_host, _textArea, _OS, _browser) {\n    super();\n    this._host = _host;\n    this._textArea = _textArea;\n    this._OS = _OS;\n    this._browser = _browser;\n    this._onFocus = this._register(new Emitter());\n    this.onFocus = this._onFocus.event;\n    this._onBlur = this._register(new Emitter());\n    this.onBlur = this._onBlur.event;\n    this._onKeyDown = this._register(new Emitter());\n    this.onKeyDown = this._onKeyDown.event;\n    this._onKeyUp = this._register(new Emitter());\n    this.onKeyUp = this._onKeyUp.event;\n    this._onCut = this._register(new Emitter());\n    this.onCut = this._onCut.event;\n    this._onPaste = this._register(new Emitter());\n    this.onPaste = this._onPaste.event;\n    this._onType = this._register(new Emitter());\n    this.onType = this._onType.event;\n    this._onCompositionStart = this._register(new Emitter());\n    this.onCompositionStart = this._onCompositionStart.event;\n    this._onCompositionUpdate = this._register(new Emitter());\n    this.onCompositionUpdate = this._onCompositionUpdate.event;\n    this._onCompositionEnd = this._register(new Emitter());\n    this.onCompositionEnd = this._onCompositionEnd.event;\n    this._onSelectionChangeRequest = this._register(new Emitter());\n    this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n    this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n    this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n    this._textAreaState = TextAreaState.EMPTY;\n    this._selectionChangeListener = null;\n    this.writeScreenReaderContent('ctor');\n    this._hasFocus = false;\n    this._currentComposition = null;\n    let lastKeyDown = null;\n    this._register(this._textArea.onKeyDown(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */ || this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */) {\n        // Stop propagation for keyDown events if the IME is processing key input\n        e.stopPropagation();\n      }\n      if (e.equals(9 /* KeyCode.Escape */)) {\n        // Prevent default always for `Esc`, otherwise it will generate a keypress\n        // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n        e.preventDefault();\n      }\n      lastKeyDown = e;\n      this._onKeyDown.fire(e);\n    }));\n    this._register(this._textArea.onKeyUp(_e => {\n      const e = new StandardKeyboardEvent(_e);\n      this._onKeyUp.fire(e);\n    }));\n    this._register(this._textArea.onCompositionStart(e => {\n      if (_debugComposition) {\n        console.log(`[compositionstart]`, e);\n      }\n      const currentComposition = new CompositionContext();\n      if (this._currentComposition) {\n        // simply reset the composition context\n        this._currentComposition = currentComposition;\n        return;\n      }\n      this._currentComposition = currentComposition;\n      if (this._OS === 2 /* OperatingSystem.Macintosh */ && lastKeyDown && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n        // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n        if (_debugComposition) {\n          console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n        }\n        // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n        currentComposition.handleCompositionUpdate('x');\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // when tapping on the editor, Android enters composition mode to edit the current word\n        // so we cannot clear the textarea on Android and we must pretend the current word was selected\n        this._onCompositionStart.fire({\n          data: e.data\n        });\n        return;\n      }\n      this._onCompositionStart.fire({\n        data: e.data\n      });\n    }));\n    this._register(this._textArea.onCompositionUpdate(e => {\n      if (_debugComposition) {\n        console.log(`[compositionupdate]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n        return;\n      }\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionUpdate.fire(e);\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      this._onType.fire(typeInput);\n      this._onCompositionUpdate.fire(e);\n    }));\n    this._register(this._textArea.onCompositionEnd(e => {\n      if (_debugComposition) {\n        console.log(`[compositionend]`, e);\n      }\n      const currentComposition = this._currentComposition;\n      if (!currentComposition) {\n        // https://github.com/microsoft/monaco-editor/issues/1663\n        // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n        return;\n      }\n      this._currentComposition = null;\n      if (this._browser.isAndroid) {\n        // On Android, the data sent with the composition update event is unusable.\n        // For example, if the cursor is in the middle of a word like Mic|osoft\n        // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n        // This is not really usable because it doesn't tell us where the edit began and where it ended.\n        const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n        const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n        this._textAreaState = newState;\n        this._onType.fire(typeInput);\n        this._onCompositionEnd.fire();\n        return;\n      }\n      const typeInput = currentComposition.handleCompositionUpdate(e.data);\n      this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      this._onType.fire(typeInput);\n      this._onCompositionEnd.fire();\n    }));\n    this._register(this._textArea.onInput(e => {\n      if (_debugComposition) {\n        console.log(`[input]`, e);\n      }\n      // Pretend here we touched the text area, as the `input` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received input event');\n      if (this._currentComposition) {\n        return;\n      }\n      const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n      const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/this._OS === 2 /* OperatingSystem.Macintosh */);\n      if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n        // one character was typed\n        if (strings.isHighSurrogate(typeInput.text.charCodeAt(0)) || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n          // Ignore invalid input but keep it around for next time\n          return;\n        }\n      }\n      this._textAreaState = newState;\n      if (typeInput.text !== '' || typeInput.replacePrevCharCnt !== 0 || typeInput.replaceNextCharCnt !== 0 || typeInput.positionDelta !== 0) {\n        this._onType.fire(typeInput);\n      }\n    }));\n    // --- Clipboard operations\n    this._register(this._textArea.onCut(e => {\n      // Pretend here we touched the text area, as the `cut` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received cut event');\n      this._ensureClipboardGetsEditorSelection(e);\n      this._asyncTriggerCut.schedule();\n    }));\n    this._register(this._textArea.onCopy(e => {\n      this._ensureClipboardGetsEditorSelection(e);\n    }));\n    this._register(this._textArea.onPaste(e => {\n      // Pretend here we touched the text area, as the `paste` event will most likely\n      // result in a `selectionchange` event which we want to ignore\n      this._textArea.setIgnoreSelectionChangeTime('received paste event');\n      e.preventDefault();\n      if (!e.clipboardData) {\n        return;\n      }\n      let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n      if (!text) {\n        return;\n      }\n      // try the in-memory store\n      metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n      this._onPaste.fire({\n        text: text,\n        metadata: metadata\n      });\n    }));\n    this._register(this._textArea.onFocus(() => {\n      const hadFocus = this._hasFocus;\n      this._setHasFocus(true);\n      if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n        // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n        // Safari will always move the selection at offset 0 in the textarea\n        this._asyncFocusGainWriteScreenReaderContent.schedule();\n      }\n    }));\n    this._register(this._textArea.onBlur(() => {\n      if (this._currentComposition) {\n        // See https://github.com/microsoft/vscode/issues/112621\n        // where compositionend is not triggered when the editor\n        // is taken off-dom during a composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeScreenReaderContent('blurWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n      this._setHasFocus(false);\n    }));\n    this._register(this._textArea.onSyntheticTap(() => {\n      if (this._browser.isAndroid && this._currentComposition) {\n        // on Android, tapping does not cancel the current composition, so the\n        // textarea is stuck showing the old composition\n        // Clear the flag to be able to write to the textarea\n        this._currentComposition = null;\n        // Clear the textarea to avoid an unwanted cursor type\n        this.writeScreenReaderContent('tapWithoutCompositionEnd');\n        // Fire artificial composition end\n        this._onCompositionEnd.fire();\n      }\n    }));\n  }\n  _installSelectionChangeListener() {\n    // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n    // When using a Braille display, it is possible for users to reposition the\n    // system caret. This is reflected in Chrome as a `selectionchange` event.\n    //\n    // The `selectionchange` event appears to be emitted under numerous other circumstances,\n    // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n    // using a Braille display from all the other cases.\n    //\n    // The problems with the `selectionchange` event are:\n    //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n    //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n    //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n    //  * the event is emitted when tabbing into the textarea\n    //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n    //  * the event sometimes comes in bursts for a single logical textarea operation\n    // `selectionchange` events often come multiple times for a single logical change\n    // so throttle multiple `selectionchange` events that burst in a short period of time.\n    let previousSelectionChangeEventTime = 0;\n    return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', e => {\n      inputLatency.onSelectionChange();\n      if (!this._hasFocus) {\n        return;\n      }\n      if (this._currentComposition) {\n        return;\n      }\n      if (!this._browser.isChrome) {\n        // Support only for Chrome until testing happens on other browsers\n        return;\n      }\n      const now = Date.now();\n      const delta1 = now - previousSelectionChangeEventTime;\n      previousSelectionChangeEventTime = now;\n      if (delta1 < 5) {\n        // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n        // => ignore it\n        return;\n      }\n      const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n      this._textArea.resetSelectionChangeTime();\n      if (delta2 < 100) {\n        // received a `selectionchange` event within 100ms since we touched the textarea\n        // => ignore it, since we caused it\n        return;\n      }\n      if (!this._textAreaState.selection) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newValue = this._textArea.getValue();\n      if (this._textAreaState.value !== newValue) {\n        // Cannot correlate a position in the textarea with a position in the editor...\n        return;\n      }\n      const newSelectionStart = this._textArea.getSelectionStart();\n      const newSelectionEnd = this._textArea.getSelectionEnd();\n      if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n        // Nothing to do...\n        return;\n      }\n      const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n      const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n      const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n      const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n      const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n      this._onSelectionChangeRequest.fire(newSelection);\n    });\n  }\n  dispose() {\n    super.dispose();\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n  }\n  focusTextArea() {\n    // Setting this._hasFocus and writing the screen reader content\n    // will result in a focus() and setSelectionRange() in the textarea\n    this._setHasFocus(true);\n    // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n    this.refreshFocusState();\n  }\n  isFocused() {\n    return this._hasFocus;\n  }\n  refreshFocusState() {\n    this._setHasFocus(this._textArea.hasFocus());\n  }\n  _setHasFocus(newHasFocus) {\n    if (this._hasFocus === newHasFocus) {\n      // no change\n      return;\n    }\n    this._hasFocus = newHasFocus;\n    if (this._selectionChangeListener) {\n      this._selectionChangeListener.dispose();\n      this._selectionChangeListener = null;\n    }\n    if (this._hasFocus) {\n      this._selectionChangeListener = this._installSelectionChangeListener();\n    }\n    if (this._hasFocus) {\n      this.writeScreenReaderContent('focusgain');\n    }\n    if (this._hasFocus) {\n      this._onFocus.fire();\n    } else {\n      this._onBlur.fire();\n    }\n  }\n  _setAndWriteTextAreaState(reason, textAreaState) {\n    if (!this._hasFocus) {\n      textAreaState = textAreaState.collapseSelection();\n    }\n    textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n    this._textAreaState = textAreaState;\n  }\n  writeScreenReaderContent(reason) {\n    if (this._currentComposition) {\n      // Do not write to the text area when doing composition\n      return;\n    }\n    this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n  }\n  _ensureClipboardGetsEditorSelection(e) {\n    const dataToCopy = this._host.getDataToCopy();\n    const storedMetadata = {\n      version: 1,\n      isFromEmptySelection: dataToCopy.isFromEmptySelection,\n      multicursorText: dataToCopy.multicursorText,\n      mode: dataToCopy.mode\n    };\n    InMemoryClipboardMetadataManager.INSTANCE.set(\n    // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n    // Firefox pastes \"LINE\\n\", so let's work around this quirk\n    this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text, storedMetadata);\n    e.preventDefault();\n    if (e.clipboardData) {\n      ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n    }\n  }\n}\nexport const ClipboardEventUtils = {\n  getTextData(clipboardData) {\n    const text = clipboardData.getData(Mimes.text);\n    let metadata = null;\n    const rawmetadata = clipboardData.getData('vscode-editor-data');\n    if (typeof rawmetadata === 'string') {\n      try {\n        metadata = JSON.parse(rawmetadata);\n        if (metadata.version !== 1) {\n          metadata = null;\n        }\n      } catch (err) {\n        // no problem!\n      }\n    }\n    if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n      // no textual data pasted, generate text from file names\n      const files = Array.prototype.slice.call(clipboardData.files, 0);\n      return [files.map(file => file.name).join('\\n'), null];\n    }\n    return [text, metadata];\n  },\n  setTextData(clipboardData, text, html, metadata) {\n    clipboardData.setData(Mimes.text, text);\n    if (typeof html === 'string') {\n      clipboardData.setData('text/html', html);\n    }\n    clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n  }\n};\nexport class TextAreaWrapper extends Disposable {\n  get ownerDocument() {\n    return this._actual.ownerDocument;\n  }\n  constructor(_actual) {\n    super();\n    this._actual = _actual;\n    this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n    this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n    this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n    this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n    this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n    this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n    this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n    this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n    this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n    this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n    this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n    this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n    this._onSyntheticTap = this._register(new Emitter());\n    this.onSyntheticTap = this._onSyntheticTap.event;\n    this._ignoreSelectionChangeTime = 0;\n    this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n    this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n    this._register(this.onInput(() => inputLatency.onInput()));\n    this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n    this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n  }\n  hasFocus() {\n    const shadowRoot = dom.getShadowRoot(this._actual);\n    if (shadowRoot) {\n      return shadowRoot.activeElement === this._actual;\n    } else if (dom.isInDOM(this._actual)) {\n      return this._actual.ownerDocument.activeElement === this._actual;\n    } else {\n      return false;\n    }\n  }\n  setIgnoreSelectionChangeTime(reason) {\n    this._ignoreSelectionChangeTime = Date.now();\n  }\n  getIgnoreSelectionChangeTime() {\n    return this._ignoreSelectionChangeTime;\n  }\n  resetSelectionChangeTime() {\n    this._ignoreSelectionChangeTime = 0;\n  }\n  getValue() {\n    // console.log('current value: ' + this._textArea.value);\n    return this._actual.value;\n  }\n  setValue(reason, value) {\n    const textArea = this._actual;\n    if (textArea.value === value) {\n      // No change\n      return;\n    }\n    // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n    this.setIgnoreSelectionChangeTime('setValue');\n    textArea.value = value;\n  }\n  getSelectionStart() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n  }\n  getSelectionEnd() {\n    return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n  }\n  setSelectionRange(reason, selectionStart, selectionEnd) {\n    const textArea = this._actual;\n    let activeElement = null;\n    const shadowRoot = dom.getShadowRoot(textArea);\n    if (shadowRoot) {\n      activeElement = shadowRoot.activeElement;\n    } else {\n      activeElement = textArea.ownerDocument.activeElement;\n    }\n    const currentIsFocused = activeElement === textArea;\n    const currentSelectionStart = textArea.selectionStart;\n    const currentSelectionEnd = textArea.selectionEnd;\n    if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n      // No change\n      // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n    if (currentIsFocused) {\n      // No need to focus, only need to change the selection range\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      if (browser.isFirefox && window.parent !== window) {\n        textArea.focus();\n      }\n      return;\n    }\n    // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n    // Here, we try to undo the browser's desperate reveal.\n    try {\n      const scrollState = dom.saveParentsScrollTop(textArea);\n      this.setIgnoreSelectionChangeTime('setSelectionRange');\n      textArea.focus();\n      textArea.setSelectionRange(selectionStart, selectionEnd);\n      dom.restoreParentsScrollTop(textArea, scrollState);\n    } catch (e) {\n      // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n    }\n  }\n}","map":{"version":3,"names":["browser","dom","DomEmitter","StandardKeyboardEvent","inputLatency","RunOnceScheduler","Emitter","Disposable","Mimes","strings","TextAreaState","_debugComposition","Selection","TextAreaSyntethicEvents","Tap","CopyOptions","forceCopyWithSyntaxHighlighting","InMemoryClipboardMetadataManager","constructor","_lastState","set","lastCopiedValue","data","get","pastedText","INSTANCE","CompositionContext","_lastTypeTextLength","handleCompositionUpdate","text","typeInput","replacePrevCharCnt","replaceNextCharCnt","positionDelta","length","TextAreaInput","textAreaState","_textAreaState","_host","_textArea","_OS","_browser","_onFocus","_register","onFocus","event","_onBlur","onBlur","_onKeyDown","onKeyDown","_onKeyUp","onKeyUp","_onCut","onCut","_onPaste","onPaste","_onType","onType","_onCompositionStart","onCompositionStart","_onCompositionUpdate","onCompositionUpdate","_onCompositionEnd","onCompositionEnd","_onSelectionChangeRequest","onSelectionChangeRequest","_asyncTriggerCut","fire","_asyncFocusGainWriteScreenReaderContent","writeScreenReaderContent","EMPTY","_selectionChangeListener","_hasFocus","_currentComposition","lastKeyDown","_e","e","keyCode","stopPropagation","equals","preventDefault","console","log","currentComposition","selectionStart","selectionEnd","value","substr","code","isAndroid","newState","readFromTextArea","deduceAndroidCompositionInput","onInput","setIgnoreSelectionChangeTime","deduceInput","isHighSurrogate","charCodeAt","_ensureClipboardGetsEditorSelection","schedule","onCopy","clipboardData","metadata","ClipboardEventUtils","getTextData","hadFocus","_setHasFocus","isSafari","onSyntheticTap","_installSelectionChangeListener","previousSelectionChangeEventTime","addDisposableListener","ownerDocument","onSelectionChange","isChrome","now","Date","delta1","delta2","getIgnoreSelectionChangeTime","resetSelectionChangeTime","selection","newValue","getValue","newSelectionStart","getSelectionStart","newSelectionEnd","getSelectionEnd","_newSelectionStartPosition","deduceEditorPosition","newSelectionStartPosition","deduceModelPosition","_newSelectionEndPosition","newSelectionEndPosition","newSelection","lineNumber","column","dispose","focusTextArea","refreshFocusState","isFocused","hasFocus","newHasFocus","_setAndWriteTextAreaState","reason","collapseSelection","writeToTextArea","getScreenReaderContent","dataToCopy","getDataToCopy","storedMetadata","version","isFromEmptySelection","multicursorText","mode","isFirefox","replace","setTextData","html","getData","rawmetadata","JSON","parse","err","files","Array","prototype","slice","call","map","file","name","join","setData","stringify","TextAreaWrapper","_actual","onBeforeInput","_onSyntheticTap","_ignoreSelectionChangeTime","shadowRoot","getShadowRoot","activeElement","isInDOM","setValue","textArea","selectionDirection","setSelectionRange","currentIsFocused","currentSelectionStart","currentSelectionEnd","window","parent","focus","scrollState","saveParentsScrollTop","restoreParentsScrollTop"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/browser/controller/textAreaInput.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as browser from '../../../base/browser/browser.js';\nimport * as dom from '../../../base/browser/dom.js';\nimport { DomEmitter } from '../../../base/browser/event.js';\nimport { StandardKeyboardEvent } from '../../../base/browser/keyboardEvent.js';\nimport { inputLatency } from '../../../base/browser/performance.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { TextAreaState, _debugComposition } from './textAreaState.js';\nimport { Selection } from '../../common/core/selection.js';\nexport var TextAreaSyntethicEvents;\n(function (TextAreaSyntethicEvents) {\n    TextAreaSyntethicEvents.Tap = '-monaco-textarea-synthetic-tap';\n})(TextAreaSyntethicEvents || (TextAreaSyntethicEvents = {}));\nexport const CopyOptions = {\n    forceCopyWithSyntaxHighlighting: false\n};\n/**\n * Every time we write to the clipboard, we record a bit of extra metadata here.\n * Every time we read from the cipboard, if the text matches our last written text,\n * we can fetch the previous metadata.\n */\nexport class InMemoryClipboardMetadataManager {\n    constructor() {\n        this._lastState = null;\n    }\n    set(lastCopiedValue, data) {\n        this._lastState = { lastCopiedValue, data };\n    }\n    get(pastedText) {\n        if (this._lastState && this._lastState.lastCopiedValue === pastedText) {\n            // match!\n            return this._lastState.data;\n        }\n        this._lastState = null;\n        return null;\n    }\n}\nInMemoryClipboardMetadataManager.INSTANCE = new InMemoryClipboardMetadataManager();\nclass CompositionContext {\n    constructor() {\n        this._lastTypeTextLength = 0;\n    }\n    handleCompositionUpdate(text) {\n        text = text || '';\n        const typeInput = {\n            text: text,\n            replacePrevCharCnt: this._lastTypeTextLength,\n            replaceNextCharCnt: 0,\n            positionDelta: 0\n        };\n        this._lastTypeTextLength = text.length;\n        return typeInput;\n    }\n}\n/**\n * Writes screen reader content to the textarea and is able to analyze its input events to generate:\n *  - onCut\n *  - onPaste\n *  - onType\n *\n * Composition events are generated for presentation purposes (composition input is reflected in onType).\n */\nexport class TextAreaInput extends Disposable {\n    get textAreaState() {\n        return this._textAreaState;\n    }\n    constructor(_host, _textArea, _OS, _browser) {\n        super();\n        this._host = _host;\n        this._textArea = _textArea;\n        this._OS = _OS;\n        this._browser = _browser;\n        this._onFocus = this._register(new Emitter());\n        this.onFocus = this._onFocus.event;\n        this._onBlur = this._register(new Emitter());\n        this.onBlur = this._onBlur.event;\n        this._onKeyDown = this._register(new Emitter());\n        this.onKeyDown = this._onKeyDown.event;\n        this._onKeyUp = this._register(new Emitter());\n        this.onKeyUp = this._onKeyUp.event;\n        this._onCut = this._register(new Emitter());\n        this.onCut = this._onCut.event;\n        this._onPaste = this._register(new Emitter());\n        this.onPaste = this._onPaste.event;\n        this._onType = this._register(new Emitter());\n        this.onType = this._onType.event;\n        this._onCompositionStart = this._register(new Emitter());\n        this.onCompositionStart = this._onCompositionStart.event;\n        this._onCompositionUpdate = this._register(new Emitter());\n        this.onCompositionUpdate = this._onCompositionUpdate.event;\n        this._onCompositionEnd = this._register(new Emitter());\n        this.onCompositionEnd = this._onCompositionEnd.event;\n        this._onSelectionChangeRequest = this._register(new Emitter());\n        this.onSelectionChangeRequest = this._onSelectionChangeRequest.event;\n        this._asyncTriggerCut = this._register(new RunOnceScheduler(() => this._onCut.fire(), 0));\n        this._asyncFocusGainWriteScreenReaderContent = this._register(new RunOnceScheduler(() => this.writeScreenReaderContent('asyncFocusGain'), 0));\n        this._textAreaState = TextAreaState.EMPTY;\n        this._selectionChangeListener = null;\n        this.writeScreenReaderContent('ctor');\n        this._hasFocus = false;\n        this._currentComposition = null;\n        let lastKeyDown = null;\n        this._register(this._textArea.onKeyDown((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            if (e.keyCode === 114 /* KeyCode.KEY_IN_COMPOSITION */\n                || (this._currentComposition && e.keyCode === 1 /* KeyCode.Backspace */)) {\n                // Stop propagation for keyDown events if the IME is processing key input\n                e.stopPropagation();\n            }\n            if (e.equals(9 /* KeyCode.Escape */)) {\n                // Prevent default always for `Esc`, otherwise it will generate a keypress\n                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx\n                e.preventDefault();\n            }\n            lastKeyDown = e;\n            this._onKeyDown.fire(e);\n        }));\n        this._register(this._textArea.onKeyUp((_e) => {\n            const e = new StandardKeyboardEvent(_e);\n            this._onKeyUp.fire(e);\n        }));\n        this._register(this._textArea.onCompositionStart((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionstart]`, e);\n            }\n            const currentComposition = new CompositionContext();\n            if (this._currentComposition) {\n                // simply reset the composition context\n                this._currentComposition = currentComposition;\n                return;\n            }\n            this._currentComposition = currentComposition;\n            if (this._OS === 2 /* OperatingSystem.Macintosh */\n                && lastKeyDown\n                && lastKeyDown.equals(114 /* KeyCode.KEY_IN_COMPOSITION */)\n                && this._textAreaState.selectionStart === this._textAreaState.selectionEnd\n                && this._textAreaState.selectionStart > 0\n                && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === e.data\n                && (lastKeyDown.code === 'ArrowRight' || lastKeyDown.code === 'ArrowLeft')) {\n                // Handling long press case on Chromium/Safari macOS + arrow key => pretend the character was selected\n                if (_debugComposition) {\n                    console.log(`[compositionstart] Handling long press case on macOS + arrow key`, e);\n                }\n                // Pretend the previous character was composed (in order to get it removed by subsequent compositionupdate events)\n                currentComposition.handleCompositionUpdate('x');\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // when tapping on the editor, Android enters composition mode to edit the current word\n                // so we cannot clear the textarea on Android and we must pretend the current word was selected\n                this._onCompositionStart.fire({ data: e.data });\n                return;\n            }\n            this._onCompositionStart.fire({ data: e.data });\n        }));\n        this._register(this._textArea.onCompositionUpdate((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionupdate]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // should not be possible to receive a 'compositionupdate' without a 'compositionstart'\n                return;\n            }\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionUpdate.fire(e);\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionUpdate.fire(e);\n        }));\n        this._register(this._textArea.onCompositionEnd((e) => {\n            if (_debugComposition) {\n                console.log(`[compositionend]`, e);\n            }\n            const currentComposition = this._currentComposition;\n            if (!currentComposition) {\n                // https://github.com/microsoft/monaco-editor/issues/1663\n                // On iOS 13.2, Chinese system IME randomly trigger an additional compositionend event with empty data\n                return;\n            }\n            this._currentComposition = null;\n            if (this._browser.isAndroid) {\n                // On Android, the data sent with the composition update event is unusable.\n                // For example, if the cursor is in the middle of a word like Mic|osoft\n                // and Microsoft is chosen from the keyboard's suggestions, the e.data will contain \"Microsoft\".\n                // This is not really usable because it doesn't tell us where the edit began and where it ended.\n                const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n                const typeInput = TextAreaState.deduceAndroidCompositionInput(this._textAreaState, newState);\n                this._textAreaState = newState;\n                this._onType.fire(typeInput);\n                this._onCompositionEnd.fire();\n                return;\n            }\n            const typeInput = currentComposition.handleCompositionUpdate(e.data);\n            this._textAreaState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            this._onType.fire(typeInput);\n            this._onCompositionEnd.fire();\n        }));\n        this._register(this._textArea.onInput((e) => {\n            if (_debugComposition) {\n                console.log(`[input]`, e);\n            }\n            // Pretend here we touched the text area, as the `input` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received input event');\n            if (this._currentComposition) {\n                return;\n            }\n            const newState = TextAreaState.readFromTextArea(this._textArea, this._textAreaState);\n            const typeInput = TextAreaState.deduceInput(this._textAreaState, newState, /*couldBeEmojiInput*/ this._OS === 2 /* OperatingSystem.Macintosh */);\n            if (typeInput.replacePrevCharCnt === 0 && typeInput.text.length === 1) {\n                // one character was typed\n                if (strings.isHighSurrogate(typeInput.text.charCodeAt(0))\n                    || typeInput.text.charCodeAt(0) === 0x7f /* Delete */) {\n                    // Ignore invalid input but keep it around for next time\n                    return;\n                }\n            }\n            this._textAreaState = newState;\n            if (typeInput.text !== ''\n                || typeInput.replacePrevCharCnt !== 0\n                || typeInput.replaceNextCharCnt !== 0\n                || typeInput.positionDelta !== 0) {\n                this._onType.fire(typeInput);\n            }\n        }));\n        // --- Clipboard operations\n        this._register(this._textArea.onCut((e) => {\n            // Pretend here we touched the text area, as the `cut` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received cut event');\n            this._ensureClipboardGetsEditorSelection(e);\n            this._asyncTriggerCut.schedule();\n        }));\n        this._register(this._textArea.onCopy((e) => {\n            this._ensureClipboardGetsEditorSelection(e);\n        }));\n        this._register(this._textArea.onPaste((e) => {\n            // Pretend here we touched the text area, as the `paste` event will most likely\n            // result in a `selectionchange` event which we want to ignore\n            this._textArea.setIgnoreSelectionChangeTime('received paste event');\n            e.preventDefault();\n            if (!e.clipboardData) {\n                return;\n            }\n            let [text, metadata] = ClipboardEventUtils.getTextData(e.clipboardData);\n            if (!text) {\n                return;\n            }\n            // try the in-memory store\n            metadata = metadata || InMemoryClipboardMetadataManager.INSTANCE.get(text);\n            this._onPaste.fire({\n                text: text,\n                metadata: metadata\n            });\n        }));\n        this._register(this._textArea.onFocus(() => {\n            const hadFocus = this._hasFocus;\n            this._setHasFocus(true);\n            if (this._browser.isSafari && !hadFocus && this._hasFocus) {\n                // When \"tabbing into\" the textarea, immediately after dispatching the 'focus' event,\n                // Safari will always move the selection at offset 0 in the textarea\n                this._asyncFocusGainWriteScreenReaderContent.schedule();\n            }\n        }));\n        this._register(this._textArea.onBlur(() => {\n            if (this._currentComposition) {\n                // See https://github.com/microsoft/vscode/issues/112621\n                // where compositionend is not triggered when the editor\n                // is taken off-dom during a composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('blurWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n            this._setHasFocus(false);\n        }));\n        this._register(this._textArea.onSyntheticTap(() => {\n            if (this._browser.isAndroid && this._currentComposition) {\n                // on Android, tapping does not cancel the current composition, so the\n                // textarea is stuck showing the old composition\n                // Clear the flag to be able to write to the textarea\n                this._currentComposition = null;\n                // Clear the textarea to avoid an unwanted cursor type\n                this.writeScreenReaderContent('tapWithoutCompositionEnd');\n                // Fire artificial composition end\n                this._onCompositionEnd.fire();\n            }\n        }));\n    }\n    _installSelectionChangeListener() {\n        // See https://github.com/microsoft/vscode/issues/27216 and https://github.com/microsoft/vscode/issues/98256\n        // When using a Braille display, it is possible for users to reposition the\n        // system caret. This is reflected in Chrome as a `selectionchange` event.\n        //\n        // The `selectionchange` event appears to be emitted under numerous other circumstances,\n        // so it is quite a challenge to distinguish a `selectionchange` coming in from a user\n        // using a Braille display from all the other cases.\n        //\n        // The problems with the `selectionchange` event are:\n        //  * the event is emitted when the textarea is focused programmatically -- textarea.focus()\n        //  * the event is emitted when the selection is changed in the textarea programmatically -- textarea.setSelectionRange(...)\n        //  * the event is emitted when the value of the textarea is changed programmatically -- textarea.value = '...'\n        //  * the event is emitted when tabbing into the textarea\n        //  * the event is emitted asynchronously (sometimes with a delay as high as a few tens of ms)\n        //  * the event sometimes comes in bursts for a single logical textarea operation\n        // `selectionchange` events often come multiple times for a single logical change\n        // so throttle multiple `selectionchange` events that burst in a short period of time.\n        let previousSelectionChangeEventTime = 0;\n        return dom.addDisposableListener(this._textArea.ownerDocument, 'selectionchange', (e) => {\n            inputLatency.onSelectionChange();\n            if (!this._hasFocus) {\n                return;\n            }\n            if (this._currentComposition) {\n                return;\n            }\n            if (!this._browser.isChrome) {\n                // Support only for Chrome until testing happens on other browsers\n                return;\n            }\n            const now = Date.now();\n            const delta1 = now - previousSelectionChangeEventTime;\n            previousSelectionChangeEventTime = now;\n            if (delta1 < 5) {\n                // received another `selectionchange` event within 5ms of the previous `selectionchange` event\n                // => ignore it\n                return;\n            }\n            const delta2 = now - this._textArea.getIgnoreSelectionChangeTime();\n            this._textArea.resetSelectionChangeTime();\n            if (delta2 < 100) {\n                // received a `selectionchange` event within 100ms since we touched the textarea\n                // => ignore it, since we caused it\n                return;\n            }\n            if (!this._textAreaState.selection) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newValue = this._textArea.getValue();\n            if (this._textAreaState.value !== newValue) {\n                // Cannot correlate a position in the textarea with a position in the editor...\n                return;\n            }\n            const newSelectionStart = this._textArea.getSelectionStart();\n            const newSelectionEnd = this._textArea.getSelectionEnd();\n            if (this._textAreaState.selectionStart === newSelectionStart && this._textAreaState.selectionEnd === newSelectionEnd) {\n                // Nothing to do...\n                return;\n            }\n            const _newSelectionStartPosition = this._textAreaState.deduceEditorPosition(newSelectionStart);\n            const newSelectionStartPosition = this._host.deduceModelPosition(_newSelectionStartPosition[0], _newSelectionStartPosition[1], _newSelectionStartPosition[2]);\n            const _newSelectionEndPosition = this._textAreaState.deduceEditorPosition(newSelectionEnd);\n            const newSelectionEndPosition = this._host.deduceModelPosition(_newSelectionEndPosition[0], _newSelectionEndPosition[1], _newSelectionEndPosition[2]);\n            const newSelection = new Selection(newSelectionStartPosition.lineNumber, newSelectionStartPosition.column, newSelectionEndPosition.lineNumber, newSelectionEndPosition.column);\n            this._onSelectionChangeRequest.fire(newSelection);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n    }\n    focusTextArea() {\n        // Setting this._hasFocus and writing the screen reader content\n        // will result in a focus() and setSelectionRange() in the textarea\n        this._setHasFocus(true);\n        // If the editor is off DOM, focus cannot be really set, so let's double check that we have managed to set the focus\n        this.refreshFocusState();\n    }\n    isFocused() {\n        return this._hasFocus;\n    }\n    refreshFocusState() {\n        this._setHasFocus(this._textArea.hasFocus());\n    }\n    _setHasFocus(newHasFocus) {\n        if (this._hasFocus === newHasFocus) {\n            // no change\n            return;\n        }\n        this._hasFocus = newHasFocus;\n        if (this._selectionChangeListener) {\n            this._selectionChangeListener.dispose();\n            this._selectionChangeListener = null;\n        }\n        if (this._hasFocus) {\n            this._selectionChangeListener = this._installSelectionChangeListener();\n        }\n        if (this._hasFocus) {\n            this.writeScreenReaderContent('focusgain');\n        }\n        if (this._hasFocus) {\n            this._onFocus.fire();\n        }\n        else {\n            this._onBlur.fire();\n        }\n    }\n    _setAndWriteTextAreaState(reason, textAreaState) {\n        if (!this._hasFocus) {\n            textAreaState = textAreaState.collapseSelection();\n        }\n        textAreaState.writeToTextArea(reason, this._textArea, this._hasFocus);\n        this._textAreaState = textAreaState;\n    }\n    writeScreenReaderContent(reason) {\n        if (this._currentComposition) {\n            // Do not write to the text area when doing composition\n            return;\n        }\n        this._setAndWriteTextAreaState(reason, this._host.getScreenReaderContent());\n    }\n    _ensureClipboardGetsEditorSelection(e) {\n        const dataToCopy = this._host.getDataToCopy();\n        const storedMetadata = {\n            version: 1,\n            isFromEmptySelection: dataToCopy.isFromEmptySelection,\n            multicursorText: dataToCopy.multicursorText,\n            mode: dataToCopy.mode\n        };\n        InMemoryClipboardMetadataManager.INSTANCE.set(\n        // When writing \"LINE\\r\\n\" to the clipboard and then pasting,\n        // Firefox pastes \"LINE\\n\", so let's work around this quirk\n        (this._browser.isFirefox ? dataToCopy.text.replace(/\\r\\n/g, '\\n') : dataToCopy.text), storedMetadata);\n        e.preventDefault();\n        if (e.clipboardData) {\n            ClipboardEventUtils.setTextData(e.clipboardData, dataToCopy.text, dataToCopy.html, storedMetadata);\n        }\n    }\n}\nexport const ClipboardEventUtils = {\n    getTextData(clipboardData) {\n        const text = clipboardData.getData(Mimes.text);\n        let metadata = null;\n        const rawmetadata = clipboardData.getData('vscode-editor-data');\n        if (typeof rawmetadata === 'string') {\n            try {\n                metadata = JSON.parse(rawmetadata);\n                if (metadata.version !== 1) {\n                    metadata = null;\n                }\n            }\n            catch (err) {\n                // no problem!\n            }\n        }\n        if (text.length === 0 && metadata === null && clipboardData.files.length > 0) {\n            // no textual data pasted, generate text from file names\n            const files = Array.prototype.slice.call(clipboardData.files, 0);\n            return [files.map(file => file.name).join('\\n'), null];\n        }\n        return [text, metadata];\n    },\n    setTextData(clipboardData, text, html, metadata) {\n        clipboardData.setData(Mimes.text, text);\n        if (typeof html === 'string') {\n            clipboardData.setData('text/html', html);\n        }\n        clipboardData.setData('vscode-editor-data', JSON.stringify(metadata));\n    }\n};\nexport class TextAreaWrapper extends Disposable {\n    get ownerDocument() {\n        return this._actual.ownerDocument;\n    }\n    constructor(_actual) {\n        super();\n        this._actual = _actual;\n        this.onKeyDown = this._register(new DomEmitter(this._actual, 'keydown')).event;\n        this.onKeyUp = this._register(new DomEmitter(this._actual, 'keyup')).event;\n        this.onCompositionStart = this._register(new DomEmitter(this._actual, 'compositionstart')).event;\n        this.onCompositionUpdate = this._register(new DomEmitter(this._actual, 'compositionupdate')).event;\n        this.onCompositionEnd = this._register(new DomEmitter(this._actual, 'compositionend')).event;\n        this.onBeforeInput = this._register(new DomEmitter(this._actual, 'beforeinput')).event;\n        this.onInput = this._register(new DomEmitter(this._actual, 'input')).event;\n        this.onCut = this._register(new DomEmitter(this._actual, 'cut')).event;\n        this.onCopy = this._register(new DomEmitter(this._actual, 'copy')).event;\n        this.onPaste = this._register(new DomEmitter(this._actual, 'paste')).event;\n        this.onFocus = this._register(new DomEmitter(this._actual, 'focus')).event;\n        this.onBlur = this._register(new DomEmitter(this._actual, 'blur')).event;\n        this._onSyntheticTap = this._register(new Emitter());\n        this.onSyntheticTap = this._onSyntheticTap.event;\n        this._ignoreSelectionChangeTime = 0;\n        this._register(this.onKeyDown(() => inputLatency.onKeyDown()));\n        this._register(this.onBeforeInput(() => inputLatency.onBeforeInput()));\n        this._register(this.onInput(() => inputLatency.onInput()));\n        this._register(this.onKeyUp(() => inputLatency.onKeyUp()));\n        this._register(dom.addDisposableListener(this._actual, TextAreaSyntethicEvents.Tap, () => this._onSyntheticTap.fire()));\n    }\n    hasFocus() {\n        const shadowRoot = dom.getShadowRoot(this._actual);\n        if (shadowRoot) {\n            return shadowRoot.activeElement === this._actual;\n        }\n        else if (dom.isInDOM(this._actual)) {\n            return this._actual.ownerDocument.activeElement === this._actual;\n        }\n        else {\n            return false;\n        }\n    }\n    setIgnoreSelectionChangeTime(reason) {\n        this._ignoreSelectionChangeTime = Date.now();\n    }\n    getIgnoreSelectionChangeTime() {\n        return this._ignoreSelectionChangeTime;\n    }\n    resetSelectionChangeTime() {\n        this._ignoreSelectionChangeTime = 0;\n    }\n    getValue() {\n        // console.log('current value: ' + this._textArea.value);\n        return this._actual.value;\n    }\n    setValue(reason, value) {\n        const textArea = this._actual;\n        if (textArea.value === value) {\n            // No change\n            return;\n        }\n        // console.log('reason: ' + reason + ', current value: ' + textArea.value + ' => new value: ' + value);\n        this.setIgnoreSelectionChangeTime('setValue');\n        textArea.value = value;\n    }\n    getSelectionStart() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionEnd : this._actual.selectionStart;\n    }\n    getSelectionEnd() {\n        return this._actual.selectionDirection === 'backward' ? this._actual.selectionStart : this._actual.selectionEnd;\n    }\n    setSelectionRange(reason, selectionStart, selectionEnd) {\n        const textArea = this._actual;\n        let activeElement = null;\n        const shadowRoot = dom.getShadowRoot(textArea);\n        if (shadowRoot) {\n            activeElement = shadowRoot.activeElement;\n        }\n        else {\n            activeElement = textArea.ownerDocument.activeElement;\n        }\n        const currentIsFocused = (activeElement === textArea);\n        const currentSelectionStart = textArea.selectionStart;\n        const currentSelectionEnd = textArea.selectionEnd;\n        if (currentIsFocused && currentSelectionStart === selectionStart && currentSelectionEnd === selectionEnd) {\n            // No change\n            // Firefox iframe bug https://github.com/microsoft/monaco-editor/issues/643#issuecomment-367871377\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // console.log('reason: ' + reason + ', setSelectionRange: ' + selectionStart + ' -> ' + selectionEnd);\n        if (currentIsFocused) {\n            // No need to focus, only need to change the selection range\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            if (browser.isFirefox && window.parent !== window) {\n                textArea.focus();\n            }\n            return;\n        }\n        // If the focus is outside the textarea, browsers will try really hard to reveal the textarea.\n        // Here, we try to undo the browser's desperate reveal.\n        try {\n            const scrollState = dom.saveParentsScrollTop(textArea);\n            this.setIgnoreSelectionChangeTime('setSelectionRange');\n            textArea.focus();\n            textArea.setSelectionRange(selectionStart, selectionEnd);\n            dom.restoreParentsScrollTop(textArea, scrollState);\n        }\n        catch (e) {\n            // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}