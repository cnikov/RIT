{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n  let {\n    moves,\n    excludedChanges\n  } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n  if (!timeout.isValid()) {\n    return [];\n  }\n  const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n  const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n  pushMany(moves, unchangedMoves);\n  moves = joinCloseConsecutiveMoves(moves);\n  // Ignore too short moves\n  moves = moves.filter(current => {\n    const originalText = current.original.toOffsetRange().slice(originalLines).map(l => l.trim()).join('\\n');\n    return originalText.length >= 10;\n  });\n  moves = removeMovesInSameDiff(changes, moves);\n  return moves;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const deletions = changes.filter(c => c.modified.isEmpty && c.original.length >= 3).map(d => new LineRangeFragment(d.original, originalLines, d));\n  const insertions = new Set(changes.filter(c => c.original.isEmpty && c.modified.length >= 3).map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n  const excludedChanges = new Set();\n  for (const deletion of deletions) {\n    let highestSimilarity = -1;\n    let best;\n    for (const insertion of insertions) {\n      const similarity = deletion.computeSimilarity(insertion);\n      if (similarity > highestSimilarity) {\n        highestSimilarity = similarity;\n        best = insertion;\n      }\n    }\n    if (highestSimilarity > 0.90 && best) {\n      insertions.delete(best);\n      moves.push(new LineRangeMapping(deletion.range, best.range));\n      excludedChanges.add(deletion.source);\n      excludedChanges.add(best.source);\n    }\n    if (!timeout.isValid()) {\n      return {\n        moves,\n        excludedChanges\n      };\n    }\n  }\n  return {\n    moves,\n    excludedChanges\n  };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n  const moves = [];\n  const original3LineHashes = new SetMap();\n  for (const change of changes) {\n    for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n      original3LineHashes.add(key, {\n        range: new LineRange(i, i + 3)\n      });\n    }\n  }\n  const possibleMappings = [];\n  changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n  for (const change of changes) {\n    let lastMappings = [];\n    for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n      const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n      const currentModifiedRange = new LineRange(i, i + 3);\n      const nextMappings = [];\n      original3LineHashes.forEach(key, ({\n        range\n      }) => {\n        for (const lastMapping of lastMappings) {\n          // does this match extend some last match?\n          if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive && lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n            lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n            lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n            nextMappings.push(lastMapping);\n            return;\n          }\n        }\n        const mapping = {\n          modifiedLineRange: currentModifiedRange,\n          originalLineRange: range\n        };\n        possibleMappings.push(mapping);\n        nextMappings.push(mapping);\n      });\n      lastMappings = nextMappings;\n    }\n    if (!timeout.isValid()) {\n      return [];\n    }\n  }\n  possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n  const modifiedSet = new LineRangeSet();\n  const originalSet = new LineRangeSet();\n  for (const mapping of possibleMappings) {\n    const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n    const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n    const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n    const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n    for (const s of modifiedIntersectedSections.ranges) {\n      if (s.length < 3) {\n        continue;\n      }\n      const modifiedLineRange = s;\n      const originalLineRange = s.delta(-diffOrigToMod);\n      moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n      modifiedSet.addRange(modifiedLineRange);\n      originalSet.addRange(originalLineRange);\n    }\n  }\n  moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n  const monotonousChanges = new MonotonousArray(changes);\n  for (let i = 0; i < moves.length; i++) {\n    const move = moves[i];\n    const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n    const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n    const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n    const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n    const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n    const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n    let extendToTop;\n    for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n      const origLine = move.original.startLineNumber - extendToTop - 1;\n      const modLine = move.modified.startLineNumber - extendToTop - 1;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToTop > 0) {\n      originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n      modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n    }\n    let extendToBottom;\n    for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n      const origLine = move.original.endLineNumberExclusive + extendToBottom;\n      const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n      if (origLine > originalLines.length || modLine > modifiedLines.length) {\n        break;\n      }\n      if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n        break;\n      }\n      if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n        break;\n      }\n    }\n    if (extendToBottom > 0) {\n      originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n      modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n    if (extendToTop > 0 || extendToBottom > 0) {\n      moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n    }\n  }\n  return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n  if (line1.trim() === line2.trim()) {\n    return true;\n  }\n  if (line1.length > 300 && line2.length > 300) {\n    return false;\n  }\n  const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n  const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n  let commonNonSpaceCharCount = 0;\n  const inverted = SequenceDiff.invert(result.diffs, line1.length);\n  for (const seq of inverted) {\n    seq.seq1Range.forEach(idx => {\n      if (!isSpace(line1.charCodeAt(idx))) {\n        commonNonSpaceCharCount++;\n      }\n    });\n  }\n  function countNonWsChars(str) {\n    let count = 0;\n    for (let i = 0; i < line1.length; i++) {\n      if (!isSpace(str.charCodeAt(i))) {\n        count++;\n      }\n    }\n    return count;\n  }\n  const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n  const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n  return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n  if (moves.length === 0) {\n    return moves;\n  }\n  moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n  const result = [moves[0]];\n  for (let i = 1; i < moves.length; i++) {\n    const last = result[result.length - 1];\n    const current = moves[i];\n    const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n    const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n    const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n    if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n      result[result.length - 1] = last.join(current);\n      continue;\n    }\n    result.push(current);\n  }\n  return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n  const changesMonotonous = new MonotonousArray(changes);\n  moves = moves.filter(m => {\n    const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.endLineNumberExclusive < m.original.endLineNumberExclusive) || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n    const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.endLineNumberExclusive < m.modified.endLineNumberExclusive);\n    const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n    return differentDiffs;\n  });\n  return moves;\n}","map":{"version":3,"names":["SequenceDiff","LineRangeMapping","pushMany","compareBy","numberComparator","reverseOrder","MonotonousArray","findLastMonotonous","SetMap","LineRange","LineRangeSet","OffsetRange","LinesSliceCharSequence","LineRangeFragment","isSpace","MyersDiffAlgorithm","computeMovedLines","changes","originalLines","modifiedLines","hashedOriginalLines","hashedModifiedLines","timeout","moves","excludedChanges","computeMovesFromSimpleDeletionsToSimpleInsertions","isValid","filteredChanges","filter","c","has","unchangedMoves","computeUnchangedMoves","joinCloseConsecutiveMoves","current","originalText","original","toOffsetRange","slice","map","l","trim","join","length","removeMovesInSameDiff","deletions","modified","isEmpty","d","insertions","Set","deletion","highestSimilarity","best","insertion","similarity","computeSimilarity","delete","push","range","add","source","original3LineHashes","change","i","startLineNumber","endLineNumberExclusive","key","possibleMappings","sort","lastMappings","currentModifiedRange","nextMappings","forEach","lastMapping","originalLineRange","modifiedLineRange","mapping","m","modifiedSet","originalSet","diffOrigToMod","modifiedSections","subtractFrom","originalTranslatedSections","getWithDelta","modifiedIntersectedSections","getIntersection","s","ranges","delta","addRange","monotonousChanges","move","firstTouchingChangeOrig","firstTouchingChangeMod","linesAbove","Math","max","lastTouchingChangeOrig","lastTouchingChangeMod","linesBelow","extendToTop","origLine","modLine","contains","areLinesSimilar","extendToBottom","line1","line2","myersDiffingAlgorithm","result","compute","commonNonSpaceCharCount","inverted","invert","diffs","seq","seq1Range","idx","charCodeAt","countNonWsChars","str","count","longerLineLength","r","last","originalDist","modifiedDist","currentMoveAfterLast","changesMonotonous","diffBeforeEndOfMoveOriginal","diffBeforeEndOfMoveModified","differentDiffs"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { LineRangeMapping } from '../rangeMapping.js';\nimport { pushMany, compareBy, numberComparator, reverseOrder } from '../../../../base/common/arrays.js';\nimport { MonotonousArray, findLastMonotonous } from '../../../../base/common/arraysFind.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { LineRange, LineRangeSet } from '../../core/lineRange.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { LinesSliceCharSequence } from './linesSliceCharSequence.js';\nimport { LineRangeFragment, isSpace } from './utils.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nexport function computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const originalText = current.original.toOffsetRange().slice(originalLines).map(l => l.trim()).join('\\n');\n        return originalText.length >= 10;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.endLineNumberExclusive < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.endLineNumberExclusive < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}