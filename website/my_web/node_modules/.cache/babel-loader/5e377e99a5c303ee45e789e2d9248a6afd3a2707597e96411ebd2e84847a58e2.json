{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorunWithStore, derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { IDiffProviderFactoryService } from './diffProviderFactoryService.js';\nimport { readHotReloadableExport } from './utils.js';\nimport { LineRange } from '../../../common/core/lineRange.js';\nimport { DefaultLinesDiffComputer } from '../../../common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../../../common/diff/rangeMapping.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { optimizeSequenceDiffs } from '../../../common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js';\nlet DiffEditorViewModel = class DiffEditorViewModel extends Disposable {\n  setActiveMovedText(movedText) {\n    this._activeMovedText.set(movedText, undefined);\n  }\n  constructor(model, _options, _editor, _diffProviderFactoryService) {\n    super();\n    this.model = model;\n    this._options = _options;\n    this._editor = _editor;\n    this._diffProviderFactoryService = _diffProviderFactoryService;\n    this._isDiffUpToDate = observableValue(this, false);\n    this.isDiffUpToDate = this._isDiffUpToDate;\n    this._diff = observableValue(this, undefined);\n    this.diff = this._diff;\n    this._unchangedRegions = observableValue(this, {\n      regions: [],\n      originalDecorationIds: [],\n      modifiedDecorationIds: []\n    });\n    this.unchangedRegions = derived(this, r => {\n      if (this._options.hideUnchangedRegions.read(r)) {\n        return this._unchangedRegions.read(r).regions;\n      } else {\n        // Reset state\n        transaction(tx => {\n          for (const r of this._unchangedRegions.get().regions) {\n            r.collapseAll(tx);\n          }\n        });\n        return [];\n      }\n    });\n    this.movedTextToCompare = observableValue(this, undefined);\n    this._activeMovedText = observableValue(this, undefined);\n    this._hoveredMovedText = observableValue(this, undefined);\n    this.activeMovedText = derived(this, r => {\n      var _a, _b;\n      return (_b = (_a = this.movedTextToCompare.read(r)) !== null && _a !== void 0 ? _a : this._hoveredMovedText.read(r)) !== null && _b !== void 0 ? _b : this._activeMovedText.read(r);\n    });\n    this._cancellationTokenSource = new CancellationTokenSource();\n    this._diffProvider = derived(this, reader => {\n      const diffProvider = this._diffProviderFactoryService.createDiffProvider(this._editor, {\n        diffAlgorithm: this._options.diffAlgorithm.read(reader)\n      });\n      const onChangeSignal = observableSignalFromEvent('onDidChange', diffProvider.onDidChange);\n      return {\n        diffProvider,\n        onChangeSignal\n      };\n    });\n    this._register(toDisposable(() => this._cancellationTokenSource.cancel()));\n    const contentChangedSignal = observableSignal('contentChangedSignal');\n    const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n    const updateUnchangedRegions = (result, tx, reader) => {\n      const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(reader), this._options.hideUnchangedRegionsContextLineCount.read(reader));\n      // Transfer state from cur state\n      const lastUnchangedRegions = this._unchangedRegions.get();\n      const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds.map(id => model.original.getDecorationRange(id)).filter(r => !!r).map(r => LineRange.fromRange(r));\n      const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds.map(id => model.modified.getDecorationRange(id)).filter(r => !!r).map(r => LineRange.fromRange(r));\n      const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newUnchangedRegions.map(r => ({\n        range: r.originalUnchangedRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newUnchangedRegions.map(r => ({\n        range: r.modifiedUnchangedRange.toInclusiveRange(),\n        options: {\n          description: 'unchanged'\n        }\n      })));\n      for (const r of newUnchangedRegions) {\n        for (let i = 0; i < lastUnchangedRegions.regions.length; i++) {\n          if (r.originalUnchangedRange.intersectsStrict(lastUnchangedRegionsOrigRanges[i]) && r.modifiedUnchangedRange.intersectsStrict(lastUnchangedRegionsModRanges[i])) {\n            r.setHiddenModifiedRange(lastUnchangedRegions.regions[i].getHiddenModifiedRange(undefined), tx);\n            break;\n          }\n        }\n      }\n      this._unchangedRegions.set({\n        regions: newUnchangedRegions,\n        originalDecorationIds,\n        modifiedDecorationIds\n      }, tx);\n    };\n    this._register(model.modified.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (diff) {\n        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n        const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n        if (result) {\n          this._lastDiff = result;\n          transaction(tx => {\n            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n            updateUnchangedRegions(result, tx);\n            const currentSyncedMovedText = this.movedTextToCompare.get();\n            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n          });\n        }\n      }\n      debouncer.schedule();\n    }));\n    this._register(model.original.onDidChangeContent(e => {\n      const diff = this._diff.get();\n      if (diff) {\n        const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n        const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n        if (result) {\n          this._lastDiff = result;\n          transaction(tx => {\n            this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n            updateUnchangedRegions(result, tx);\n            const currentSyncedMovedText = this.movedTextToCompare.get();\n            this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n          });\n        }\n      }\n      debouncer.schedule();\n    }));\n    this._register(autorunWithStore((reader, store) => __awaiter(this, void 0, void 0, function* () {\n      /** @description compute diff */\n      var _a, _b;\n      // So that they get recomputed when these settings change\n      this._options.hideUnchangedRegionsMinimumLineCount.read(reader);\n      this._options.hideUnchangedRegionsContextLineCount.read(reader);\n      debouncer.cancel();\n      contentChangedSignal.read(reader);\n      const documentDiffProvider = this._diffProvider.read(reader);\n      documentDiffProvider.onChangeSignal.read(reader);\n      readHotReloadableExport(DefaultLinesDiffComputer, reader);\n      readHotReloadableExport(optimizeSequenceDiffs, reader);\n      this._isDiffUpToDate.set(false, undefined);\n      let originalTextEditInfos = [];\n      store.add(model.original.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n      }));\n      let modifiedTextEditInfos = [];\n      store.add(model.modified.onDidChangeContent(e => {\n        const edits = TextEditInfo.fromModelContentChanges(e.changes);\n        modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n      }));\n      let result = yield documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {\n        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n        maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n        computeMoves: this._options.showMoves.read(reader)\n      }, this._cancellationTokenSource.token);\n      if (this._cancellationTokenSource.token.isCancellationRequested) {\n        return;\n      }\n      result = normalizeDocumentDiff(result, model.original, model.modified);\n      result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;\n      result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;\n      transaction(tx => {\n        updateUnchangedRegions(result, tx);\n        this._lastDiff = result;\n        const state = DiffState.fromDiffResult(result);\n        this._diff.set(state, tx);\n        this._isDiffUpToDate.set(true, tx);\n        const currentSyncedMovedText = this.movedTextToCompare.get();\n        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n      });\n    })));\n  }\n  ensureModifiedLineIsVisible(lineNumber, tx) {\n    var _a;\n    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = this._unchangedRegions.get().regions;\n    for (const r of unchangedRegions) {\n      if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n        r.showModifiedLine(lineNumber, tx);\n        return;\n      }\n    }\n  }\n  ensureOriginalLineIsVisible(lineNumber, tx) {\n    var _a;\n    if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n      return;\n    }\n    const unchangedRegions = this._unchangedRegions.get().regions;\n    for (const r of unchangedRegions) {\n      if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n        r.showOriginalLine(lineNumber, tx);\n        return;\n      }\n    }\n  }\n  waitForDiff() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield waitForState(this.isDiffUpToDate, s => s);\n    });\n  }\n  serializeState() {\n    const regions = this._unchangedRegions.get();\n    return {\n      collapsedRegions: regions.regions.map(r => ({\n        range: r.getHiddenModifiedRange(undefined).serialize()\n      }))\n    };\n  }\n  restoreSerializedState(state) {\n    const ranges = state.collapsedRegions.map(r => LineRange.deserialize(r.range));\n    const regions = this._unchangedRegions.get();\n    transaction(tx => {\n      for (const r of regions.regions) {\n        for (const range of ranges) {\n          if (r.modifiedUnchangedRange.intersect(range)) {\n            r.setHiddenModifiedRange(range, tx);\n            break;\n          }\n        }\n      }\n    });\n  }\n};\nDiffEditorViewModel = __decorate([__param(3, IDiffProviderFactoryService)], DiffEditorViewModel);\nexport { DiffEditorViewModel };\nfunction normalizeDocumentDiff(diff, original, modified) {\n  return {\n    changes: diff.changes.map(c => new DetailedLineRangeMapping(c.original, c.modified, c.innerChanges ? c.innerChanges.map(i => normalizeRangeMapping(i, original, modified)) : undefined)),\n    moves: diff.moves,\n    identical: diff.identical,\n    quitEarly: diff.quitEarly\n  };\n}\nfunction normalizeRangeMapping(rangeMapping, original, modified) {\n  let originalRange = rangeMapping.originalRange;\n  let modifiedRange = rangeMapping.modifiedRange;\n  if ((originalRange.endColumn !== 1 || modifiedRange.endColumn !== 1) && originalRange.endColumn === original.getLineMaxColumn(originalRange.endLineNumber) && modifiedRange.endColumn === modified.getLineMaxColumn(modifiedRange.endLineNumber) && originalRange.endLineNumber < original.getLineCount() && modifiedRange.endLineNumber < modified.getLineCount()) {\n    originalRange = originalRange.setEndPosition(originalRange.endLineNumber + 1, 1);\n    modifiedRange = modifiedRange.setEndPosition(modifiedRange.endLineNumber + 1, 1);\n  }\n  return new RangeMapping(originalRange, modifiedRange);\n}\nexport class DiffState {\n  static fromDiffResult(result) {\n    return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n  }\n  constructor(mappings, movedTexts, identical, quitEarly) {\n    this.mappings = mappings;\n    this.movedTexts = movedTexts;\n    this.identical = identical;\n    this.quitEarly = quitEarly;\n  }\n}\nexport class DiffMapping {\n  constructor(lineRangeMapping) {\n    this.lineRangeMapping = lineRangeMapping;\n    /*\n    readonly movedTo: MovedText | undefined,\n    readonly movedFrom: MovedText | undefined,\n     if (movedTo) {\n        assertFn(() =>\n            movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n            && lineRangeMapping.originalRange.isEmpty\n            && !movedFrom\n        );\n    } else if (movedFrom) {\n        assertFn(() =>\n            movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n            && lineRangeMapping.modifiedRange.isEmpty\n            && !movedTo\n        );\n    }\n    */\n  }\n}\n\nexport class UnchangedRegion {\n  static fromDiffs(changes, originalLineCount, modifiedLineCount, minHiddenLineCount, minContext) {\n    const inversedMappings = DetailedLineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n    const result = [];\n    for (const mapping of inversedMappings) {\n      let origStart = mapping.original.startLineNumber;\n      let modStart = mapping.modified.startLineNumber;\n      let length = mapping.original.length;\n      const atStart = origStart === 1 && modStart === 1;\n      const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n      if ((atStart || atEnd) && length >= minContext + minHiddenLineCount) {\n        if (atStart && !atEnd) {\n          length -= minContext;\n        }\n        if (atEnd && !atStart) {\n          origStart += minContext;\n          modStart += minContext;\n          length -= minContext;\n        }\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      } else if (length >= minContext * 2 + minHiddenLineCount) {\n        origStart += minContext;\n        modStart += minContext;\n        length -= minContext * 2;\n        result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n      }\n    }\n    return result;\n  }\n  get originalUnchangedRange() {\n    return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n  }\n  get modifiedUnchangedRange() {\n    return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n  }\n  constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n    this.originalLineNumber = originalLineNumber;\n    this.modifiedLineNumber = modifiedLineNumber;\n    this.lineCount = lineCount;\n    this._visibleLineCountTop = observableValue(this, 0);\n    this.visibleLineCountTop = this._visibleLineCountTop;\n    this._visibleLineCountBottom = observableValue(this, 0);\n    this.visibleLineCountBottom = this._visibleLineCountBottom;\n    this._shouldHideControls = derived(this, reader => /** @description isVisible */this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n    this.isDragged = observableValue(this, false);\n    this._visibleLineCountTop.set(visibleLineCountTop, undefined);\n    this._visibleLineCountBottom.set(visibleLineCountBottom, undefined);\n  }\n  shouldHideControls(reader) {\n    return this._shouldHideControls.read(reader);\n  }\n  getHiddenOriginalRange(reader) {\n    return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  getHiddenModifiedRange(reader) {\n    return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n  }\n  setHiddenModifiedRange(range, tx) {\n    const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n    const visibleLineCountBottom = this.modifiedLineNumber + this.lineCount - range.endLineNumberExclusive;\n    this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n  }\n  getMaxVisibleLineCountTop() {\n    return this.lineCount - this._visibleLineCountBottom.get();\n  }\n  getMaxVisibleLineCountBottom() {\n    return this.lineCount - this._visibleLineCountTop.get();\n  }\n  showMoreAbove(count = 10, tx) {\n    const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n  }\n  showMoreBelow(count = 10, tx) {\n    const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n  }\n  showAll(tx) {\n    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n  }\n  showModifiedLine(lineNumber, tx) {\n    const top = lineNumber + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get());\n    const bottom = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - lineNumber;\n    if (top < bottom) {\n      this._visibleLineCountTop.set(this._visibleLineCountTop.get() + top, tx);\n    } else {\n      this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + bottom, tx);\n    }\n  }\n  showOriginalLine(lineNumber, tx) {\n    const top = lineNumber - this.originalLineNumber;\n    const bottom = this.originalLineNumber + this.lineCount - lineNumber;\n    if (top < bottom) {\n      this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + bottom - top, this.getMaxVisibleLineCountTop()), tx);\n    } else {\n      this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + top - bottom, this.getMaxVisibleLineCountBottom()), tx);\n    }\n  }\n  collapseAll(tx) {\n    this._visibleLineCountTop.set(0, tx);\n    this._visibleLineCountBottom.set(0, tx);\n  }\n  setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n    visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n    visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n    this._visibleLineCountTop.set(visibleLineCountTop, tx);\n    this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n  }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  return undefined;\n  /*\n  TODO@hediet\n  if (textEdits.length === 0) {\n      return diff;\n  }\n   const diff2 = flip(diff);\n  const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n  if (!diff3) {\n      return undefined;\n  }\n  return flip(diff3);*/\n}\n/*\nfunction flip(diff: IDocumentDiff): IDocumentDiff {\n    return {\n        changes: diff.changes.map(c => c.flip()),\n        moves: diff.moves.map(m => m.flip()),\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\n*/\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n  return undefined;\n  /*\n  TODO@hediet\n  if (textEdits.length === 0) {\n      return diff;\n  }\n  if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n      // TODO support these cases\n      return undefined;\n  }\n   const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n   const moves = diff.moves.map(m => {\n      const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n      return newModifiedRange ? new MovedText(\n          new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange),\n          applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel),\n      ) : undefined;\n  }).filter(isDefined);\n   return {\n      identical: false,\n      quitEarly: false,\n      changes,\n      moves,\n  };*/\n}\n/*\nfunction applyEditToLineRange(range: LineRange, textEdits: TextEditInfo[]): LineRange | undefined {\n    let rangeStartLineNumber = range.startLineNumber;\n    let rangeEndLineNumberEx = range.endLineNumberExclusive;\n\n    for (let i = textEdits.length - 1; i >= 0; i--) {\n        const textEdit = textEdits[i];\n        const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n        const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n        const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n        const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n\n        if (textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit is before us\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n            // the text edit is after us\n            // NOOP\n        } else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n            // the range is fully contained in the text edit\n            return undefined;\n        } else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n            // the text edit ends inside our range\n            rangeStartLineNumber = textEditEndLineNumber + 1;\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit starts inside our range\n            rangeEndLineNumberEx = textEditStartLineNumber;\n        } else {\n            rangeEndLineNumberEx += delta;\n        }\n    }\n\n    return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\n\nfunction applyModifiedEditsToLineRangeMappings(changes: readonly LineRangeMapping[], textEdits: TextEditInfo[], originalTextModel: ITextModel, modifiedTextModel: ITextModel): LineRangeMapping[] {\n    const diffTextEdits = changes.flatMap(c => c.innerChanges!.map(c => new TextEditInfo(\n        positionToLength(c.originalRange.getStartPosition()),\n        positionToLength(c.originalRange.getEndPosition()),\n        lengthOfRange(c.modifiedRange).toLength(),\n    )));\n\n    const combined = combineTextEditInfos(diffTextEdits, textEdits);\n\n    let lastOriginalEndOffset = lengthZero;\n    let lastModifiedEndOffset = lengthZero;\n    const rangeMappings = combined.map(c => {\n        const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n        lastOriginalEndOffset = c.endOffset;\n        lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n\n        return new RangeMapping(\n            Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)),\n            Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)),\n        );\n    });\n\n    const newChanges = lineRangeMappingFromRangeMappings(\n        rangeMappings,\n        originalTextModel.getLinesContent(),\n        modifiedTextModel.getLinesContent(),\n    );\n    return newChanges;\n}\n*/","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","RunOnceScheduler","CancellationTokenSource","Disposable","toDisposable","autorunWithStore","derived","observableSignal","observableSignalFromEvent","observableValue","transaction","waitForState","IDiffProviderFactoryService","readHotReloadableExport","LineRange","DefaultLinesDiffComputer","DetailedLineRangeMapping","RangeMapping","TextEditInfo","combineTextEditInfos","optimizeSequenceDiffs","DiffEditorViewModel","setActiveMovedText","movedText","_activeMovedText","set","undefined","constructor","model","_options","_editor","_diffProviderFactoryService","_isDiffUpToDate","isDiffUpToDate","_diff","diff","_unchangedRegions","regions","originalDecorationIds","modifiedDecorationIds","unchangedRegions","hideUnchangedRegions","read","tx","get","collapseAll","movedTextToCompare","_hoveredMovedText","activeMovedText","_a","_b","_cancellationTokenSource","_diffProvider","reader","diffProvider","createDiffProvider","diffAlgorithm","onChangeSignal","onDidChange","_register","cancel","contentChangedSignal","debouncer","trigger","updateUnchangedRegions","newUnchangedRegions","UnchangedRegion","fromDiffs","changes","original","getLineCount","modified","hideUnchangedRegionsMinimumLineCount","hideUnchangedRegionsContextLineCount","lastUnchangedRegions","lastUnchangedRegionsOrigRanges","map","id","getDecorationRange","filter","fromRange","lastUnchangedRegionsModRanges","deltaDecorations","range","originalUnchangedRange","toInclusiveRange","options","description","modifiedUnchangedRange","intersectsStrict","setHiddenModifiedRange","getHiddenModifiedRange","onDidChangeContent","textEdits","fromModelContentChanges","applyModifiedEdits","_lastDiff","DiffState","fromDiffResult","currentSyncedMovedText","moves","find","m","lineRangeMapping","intersect","schedule","applyOriginalEdits","store","documentDiffProvider","originalTextEditInfos","add","edits","modifiedTextEditInfos","computeDiff","ignoreTrimWhitespace","maxComputationTimeMs","computeMoves","showMoves","token","isCancellationRequested","normalizeDocumentDiff","state","ensureModifiedLineIsVisible","lineNumber","mappings","contains","showModifiedLine","ensureOriginalLineIsVisible","getHiddenOriginalRange","showOriginalLine","waitForDiff","s","serializeState","collapsedRegions","serialize","restoreSerializedState","ranges","deserialize","innerChanges","normalizeRangeMapping","identical","quitEarly","rangeMapping","originalRange","modifiedRange","endColumn","getLineMaxColumn","endLineNumber","setEndPosition","DiffMapping","movedTexts","originalLineCount","modifiedLineCount","minHiddenLineCount","minContext","inversedMappings","inverse","mapping","origStart","startLineNumber","modStart","atStart","atEnd","push","ofLength","originalLineNumber","lineCount","modifiedLineNumber","visibleLineCountTop","visibleLineCountBottom","_visibleLineCountTop","_visibleLineCountBottom","_shouldHideControls","isDragged","shouldHideControls","endLineNumberExclusive","setState","getMaxVisibleLineCountTop","getMaxVisibleLineCountBottom","showMoreAbove","count","maxVisibleLineCountTop","Math","min","showMoreBelow","maxVisibleLineCountBottom","showAll","top","bottom","max","originalTextModel","modifiedTextModel"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/browser/widget/diffEditor/diffEditorViewModel.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { RunOnceScheduler } from '../../../../base/common/async.js';\nimport { CancellationTokenSource } from '../../../../base/common/cancellation.js';\nimport { Disposable, toDisposable } from '../../../../base/common/lifecycle.js';\nimport { autorunWithStore, derived, observableSignal, observableSignalFromEvent, observableValue, transaction, waitForState } from '../../../../base/common/observable.js';\nimport { IDiffProviderFactoryService } from './diffProviderFactoryService.js';\nimport { readHotReloadableExport } from './utils.js';\nimport { LineRange } from '../../../common/core/lineRange.js';\nimport { DefaultLinesDiffComputer } from '../../../common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js';\nimport { DetailedLineRangeMapping, RangeMapping } from '../../../common/diff/rangeMapping.js';\nimport { TextEditInfo } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js';\nimport { combineTextEditInfos } from '../../../common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js';\nimport { optimizeSequenceDiffs } from '../../../common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js';\nlet DiffEditorViewModel = class DiffEditorViewModel extends Disposable {\n    setActiveMovedText(movedText) {\n        this._activeMovedText.set(movedText, undefined);\n    }\n    constructor(model, _options, _editor, _diffProviderFactoryService) {\n        super();\n        this.model = model;\n        this._options = _options;\n        this._editor = _editor;\n        this._diffProviderFactoryService = _diffProviderFactoryService;\n        this._isDiffUpToDate = observableValue(this, false);\n        this.isDiffUpToDate = this._isDiffUpToDate;\n        this._diff = observableValue(this, undefined);\n        this.diff = this._diff;\n        this._unchangedRegions = observableValue(this, { regions: [], originalDecorationIds: [], modifiedDecorationIds: [] });\n        this.unchangedRegions = derived(this, r => {\n            if (this._options.hideUnchangedRegions.read(r)) {\n                return this._unchangedRegions.read(r).regions;\n            }\n            else {\n                // Reset state\n                transaction(tx => {\n                    for (const r of this._unchangedRegions.get().regions) {\n                        r.collapseAll(tx);\n                    }\n                });\n                return [];\n            }\n        });\n        this.movedTextToCompare = observableValue(this, undefined);\n        this._activeMovedText = observableValue(this, undefined);\n        this._hoveredMovedText = observableValue(this, undefined);\n        this.activeMovedText = derived(this, r => { var _a, _b; return (_b = (_a = this.movedTextToCompare.read(r)) !== null && _a !== void 0 ? _a : this._hoveredMovedText.read(r)) !== null && _b !== void 0 ? _b : this._activeMovedText.read(r); });\n        this._cancellationTokenSource = new CancellationTokenSource();\n        this._diffProvider = derived(this, reader => {\n            const diffProvider = this._diffProviderFactoryService.createDiffProvider(this._editor, {\n                diffAlgorithm: this._options.diffAlgorithm.read(reader)\n            });\n            const onChangeSignal = observableSignalFromEvent('onDidChange', diffProvider.onDidChange);\n            return {\n                diffProvider,\n                onChangeSignal,\n            };\n        });\n        this._register(toDisposable(() => this._cancellationTokenSource.cancel()));\n        const contentChangedSignal = observableSignal('contentChangedSignal');\n        const debouncer = this._register(new RunOnceScheduler(() => contentChangedSignal.trigger(undefined), 200));\n        const updateUnchangedRegions = (result, tx, reader) => {\n            const newUnchangedRegions = UnchangedRegion.fromDiffs(result.changes, model.original.getLineCount(), model.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(reader), this._options.hideUnchangedRegionsContextLineCount.read(reader));\n            // Transfer state from cur state\n            const lastUnchangedRegions = this._unchangedRegions.get();\n            const lastUnchangedRegionsOrigRanges = lastUnchangedRegions.originalDecorationIds\n                .map(id => model.original.getDecorationRange(id))\n                .filter(r => !!r)\n                .map(r => LineRange.fromRange(r));\n            const lastUnchangedRegionsModRanges = lastUnchangedRegions.modifiedDecorationIds\n                .map(id => model.modified.getDecorationRange(id))\n                .filter(r => !!r)\n                .map(r => LineRange.fromRange(r));\n            const originalDecorationIds = model.original.deltaDecorations(lastUnchangedRegions.originalDecorationIds, newUnchangedRegions.map(r => ({ range: r.originalUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            const modifiedDecorationIds = model.modified.deltaDecorations(lastUnchangedRegions.modifiedDecorationIds, newUnchangedRegions.map(r => ({ range: r.modifiedUnchangedRange.toInclusiveRange(), options: { description: 'unchanged' } })));\n            for (const r of newUnchangedRegions) {\n                for (let i = 0; i < lastUnchangedRegions.regions.length; i++) {\n                    if (r.originalUnchangedRange.intersectsStrict(lastUnchangedRegionsOrigRanges[i])\n                        && r.modifiedUnchangedRange.intersectsStrict(lastUnchangedRegionsModRanges[i])) {\n                        r.setHiddenModifiedRange(lastUnchangedRegions.regions[i].getHiddenModifiedRange(undefined), tx);\n                        break;\n                    }\n                }\n            }\n            this._unchangedRegions.set({\n                regions: newUnchangedRegions,\n                originalDecorationIds,\n                modifiedDecorationIds\n            }, tx);\n        };\n        this._register(model.modified.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (diff) {\n                const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n                const result = applyModifiedEdits(this._lastDiff, textEdits, model.original, model.modified);\n                if (result) {\n                    this._lastDiff = result;\n                    transaction(tx => {\n                        this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                        updateUnchangedRegions(result, tx);\n                        const currentSyncedMovedText = this.movedTextToCompare.get();\n                        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                    });\n                }\n            }\n            debouncer.schedule();\n        }));\n        this._register(model.original.onDidChangeContent((e) => {\n            const diff = this._diff.get();\n            if (diff) {\n                const textEdits = TextEditInfo.fromModelContentChanges(e.changes);\n                const result = applyOriginalEdits(this._lastDiff, textEdits, model.original, model.modified);\n                if (result) {\n                    this._lastDiff = result;\n                    transaction(tx => {\n                        this._diff.set(DiffState.fromDiffResult(this._lastDiff), tx);\n                        updateUnchangedRegions(result, tx);\n                        const currentSyncedMovedText = this.movedTextToCompare.get();\n                        this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n                    });\n                }\n            }\n            debouncer.schedule();\n        }));\n        this._register(autorunWithStore((reader, store) => __awaiter(this, void 0, void 0, function* () {\n            /** @description compute diff */\n            var _a, _b;\n            // So that they get recomputed when these settings change\n            this._options.hideUnchangedRegionsMinimumLineCount.read(reader);\n            this._options.hideUnchangedRegionsContextLineCount.read(reader);\n            debouncer.cancel();\n            contentChangedSignal.read(reader);\n            const documentDiffProvider = this._diffProvider.read(reader);\n            documentDiffProvider.onChangeSignal.read(reader);\n            readHotReloadableExport(DefaultLinesDiffComputer, reader);\n            readHotReloadableExport(optimizeSequenceDiffs, reader);\n            this._isDiffUpToDate.set(false, undefined);\n            let originalTextEditInfos = [];\n            store.add(model.original.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                originalTextEditInfos = combineTextEditInfos(originalTextEditInfos, edits);\n            }));\n            let modifiedTextEditInfos = [];\n            store.add(model.modified.onDidChangeContent((e) => {\n                const edits = TextEditInfo.fromModelContentChanges(e.changes);\n                modifiedTextEditInfos = combineTextEditInfos(modifiedTextEditInfos, edits);\n            }));\n            let result = yield documentDiffProvider.diffProvider.computeDiff(model.original, model.modified, {\n                ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(reader),\n                maxComputationTimeMs: this._options.maxComputationTimeMs.read(reader),\n                computeMoves: this._options.showMoves.read(reader),\n            }, this._cancellationTokenSource.token);\n            if (this._cancellationTokenSource.token.isCancellationRequested) {\n                return;\n            }\n            result = normalizeDocumentDiff(result, model.original, model.modified);\n            result = (_a = applyOriginalEdits(result, originalTextEditInfos, model.original, model.modified)) !== null && _a !== void 0 ? _a : result;\n            result = (_b = applyModifiedEdits(result, modifiedTextEditInfos, model.original, model.modified)) !== null && _b !== void 0 ? _b : result;\n            transaction(tx => {\n                updateUnchangedRegions(result, tx);\n                this._lastDiff = result;\n                const state = DiffState.fromDiffResult(result);\n                this._diff.set(state, tx);\n                this._isDiffUpToDate.set(true, tx);\n                const currentSyncedMovedText = this.movedTextToCompare.get();\n                this.movedTextToCompare.set(currentSyncedMovedText ? this._lastDiff.moves.find(m => m.lineRangeMapping.modified.intersect(currentSyncedMovedText.lineRangeMapping.modified)) : undefined, tx);\n            });\n        })));\n    }\n    ensureModifiedLineIsVisible(lineNumber, tx) {\n        var _a;\n        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get().regions;\n        for (const r of unchangedRegions) {\n            if (r.getHiddenModifiedRange(undefined).contains(lineNumber)) {\n                r.showModifiedLine(lineNumber, tx);\n                return;\n            }\n        }\n    }\n    ensureOriginalLineIsVisible(lineNumber, tx) {\n        var _a;\n        if (((_a = this.diff.get()) === null || _a === void 0 ? void 0 : _a.mappings.length) === 0) {\n            return;\n        }\n        const unchangedRegions = this._unchangedRegions.get().regions;\n        for (const r of unchangedRegions) {\n            if (r.getHiddenOriginalRange(undefined).contains(lineNumber)) {\n                r.showOriginalLine(lineNumber, tx);\n                return;\n            }\n        }\n    }\n    waitForDiff() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield waitForState(this.isDiffUpToDate, s => s);\n        });\n    }\n    serializeState() {\n        const regions = this._unchangedRegions.get();\n        return {\n            collapsedRegions: regions.regions.map(r => ({ range: r.getHiddenModifiedRange(undefined).serialize() }))\n        };\n    }\n    restoreSerializedState(state) {\n        const ranges = state.collapsedRegions.map(r => LineRange.deserialize(r.range));\n        const regions = this._unchangedRegions.get();\n        transaction(tx => {\n            for (const r of regions.regions) {\n                for (const range of ranges) {\n                    if (r.modifiedUnchangedRange.intersect(range)) {\n                        r.setHiddenModifiedRange(range, tx);\n                        break;\n                    }\n                }\n            }\n        });\n    }\n};\nDiffEditorViewModel = __decorate([\n    __param(3, IDiffProviderFactoryService)\n], DiffEditorViewModel);\nexport { DiffEditorViewModel };\nfunction normalizeDocumentDiff(diff, original, modified) {\n    return {\n        changes: diff.changes.map(c => new DetailedLineRangeMapping(c.original, c.modified, c.innerChanges ? c.innerChanges.map(i => normalizeRangeMapping(i, original, modified)) : undefined)),\n        moves: diff.moves,\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\nfunction normalizeRangeMapping(rangeMapping, original, modified) {\n    let originalRange = rangeMapping.originalRange;\n    let modifiedRange = rangeMapping.modifiedRange;\n    if ((originalRange.endColumn !== 1 || modifiedRange.endColumn !== 1) &&\n        originalRange.endColumn === original.getLineMaxColumn(originalRange.endLineNumber)\n        && modifiedRange.endColumn === modified.getLineMaxColumn(modifiedRange.endLineNumber)\n        && originalRange.endLineNumber < original.getLineCount()\n        && modifiedRange.endLineNumber < modified.getLineCount()) {\n        originalRange = originalRange.setEndPosition(originalRange.endLineNumber + 1, 1);\n        modifiedRange = modifiedRange.setEndPosition(modifiedRange.endLineNumber + 1, 1);\n    }\n    return new RangeMapping(originalRange, modifiedRange);\n}\nexport class DiffState {\n    static fromDiffResult(result) {\n        return new DiffState(result.changes.map(c => new DiffMapping(c)), result.moves || [], result.identical, result.quitEarly);\n    }\n    constructor(mappings, movedTexts, identical, quitEarly) {\n        this.mappings = mappings;\n        this.movedTexts = movedTexts;\n        this.identical = identical;\n        this.quitEarly = quitEarly;\n    }\n}\nexport class DiffMapping {\n    constructor(lineRangeMapping) {\n        this.lineRangeMapping = lineRangeMapping;\n        /*\n        readonly movedTo: MovedText | undefined,\n        readonly movedFrom: MovedText | undefined,\n\n        if (movedTo) {\n            assertFn(() =>\n                movedTo.lineRangeMapping.modifiedRange.equals(lineRangeMapping.modifiedRange)\n                && lineRangeMapping.originalRange.isEmpty\n                && !movedFrom\n            );\n        } else if (movedFrom) {\n            assertFn(() =>\n                movedFrom.lineRangeMapping.originalRange.equals(lineRangeMapping.originalRange)\n                && lineRangeMapping.modifiedRange.isEmpty\n                && !movedTo\n            );\n        }\n        */\n    }\n}\nexport class UnchangedRegion {\n    static fromDiffs(changes, originalLineCount, modifiedLineCount, minHiddenLineCount, minContext) {\n        const inversedMappings = DetailedLineRangeMapping.inverse(changes, originalLineCount, modifiedLineCount);\n        const result = [];\n        for (const mapping of inversedMappings) {\n            let origStart = mapping.original.startLineNumber;\n            let modStart = mapping.modified.startLineNumber;\n            let length = mapping.original.length;\n            const atStart = origStart === 1 && modStart === 1;\n            const atEnd = origStart + length === originalLineCount + 1 && modStart + length === modifiedLineCount + 1;\n            if ((atStart || atEnd) && length >= minContext + minHiddenLineCount) {\n                if (atStart && !atEnd) {\n                    length -= minContext;\n                }\n                if (atEnd && !atStart) {\n                    origStart += minContext;\n                    modStart += minContext;\n                    length -= minContext;\n                }\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n            else if (length >= minContext * 2 + minHiddenLineCount) {\n                origStart += minContext;\n                modStart += minContext;\n                length -= minContext * 2;\n                result.push(new UnchangedRegion(origStart, modStart, length, 0, 0));\n            }\n        }\n        return result;\n    }\n    get originalUnchangedRange() {\n        return LineRange.ofLength(this.originalLineNumber, this.lineCount);\n    }\n    get modifiedUnchangedRange() {\n        return LineRange.ofLength(this.modifiedLineNumber, this.lineCount);\n    }\n    constructor(originalLineNumber, modifiedLineNumber, lineCount, visibleLineCountTop, visibleLineCountBottom) {\n        this.originalLineNumber = originalLineNumber;\n        this.modifiedLineNumber = modifiedLineNumber;\n        this.lineCount = lineCount;\n        this._visibleLineCountTop = observableValue(this, 0);\n        this.visibleLineCountTop = this._visibleLineCountTop;\n        this._visibleLineCountBottom = observableValue(this, 0);\n        this.visibleLineCountBottom = this._visibleLineCountBottom;\n        this._shouldHideControls = derived(this, reader => /** @description isVisible */ this.visibleLineCountTop.read(reader) + this.visibleLineCountBottom.read(reader) === this.lineCount && !this.isDragged.read(reader));\n        this.isDragged = observableValue(this, false);\n        this._visibleLineCountTop.set(visibleLineCountTop, undefined);\n        this._visibleLineCountBottom.set(visibleLineCountBottom, undefined);\n    }\n    shouldHideControls(reader) {\n        return this._shouldHideControls.read(reader);\n    }\n    getHiddenOriginalRange(reader) {\n        return LineRange.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    getHiddenModifiedRange(reader) {\n        return LineRange.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(reader), this.lineCount - this._visibleLineCountTop.read(reader) - this._visibleLineCountBottom.read(reader));\n    }\n    setHiddenModifiedRange(range, tx) {\n        const visibleLineCountTop = range.startLineNumber - this.modifiedLineNumber;\n        const visibleLineCountBottom = (this.modifiedLineNumber + this.lineCount) - range.endLineNumberExclusive;\n        this.setState(visibleLineCountTop, visibleLineCountBottom, tx);\n    }\n    getMaxVisibleLineCountTop() {\n        return this.lineCount - this._visibleLineCountBottom.get();\n    }\n    getMaxVisibleLineCountBottom() {\n        return this.lineCount - this._visibleLineCountTop.get();\n    }\n    showMoreAbove(count = 10, tx) {\n        const maxVisibleLineCountTop = this.getMaxVisibleLineCountTop();\n        this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + count, maxVisibleLineCountTop), tx);\n    }\n    showMoreBelow(count = 10, tx) {\n        const maxVisibleLineCountBottom = this.lineCount - this._visibleLineCountTop.get();\n        this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + count, maxVisibleLineCountBottom), tx);\n    }\n    showAll(tx) {\n        this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), tx);\n    }\n    showModifiedLine(lineNumber, tx) {\n        const top = lineNumber + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get());\n        const bottom = (this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount) - lineNumber;\n        if (top < bottom) {\n            this._visibleLineCountTop.set(this._visibleLineCountTop.get() + top, tx);\n        }\n        else {\n            this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + bottom, tx);\n        }\n    }\n    showOriginalLine(lineNumber, tx) {\n        const top = lineNumber - this.originalLineNumber;\n        const bottom = (this.originalLineNumber + this.lineCount) - lineNumber;\n        if (top < bottom) {\n            this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + bottom - top, this.getMaxVisibleLineCountTop()), tx);\n        }\n        else {\n            this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + top - bottom, this.getMaxVisibleLineCountBottom()), tx);\n        }\n    }\n    collapseAll(tx) {\n        this._visibleLineCountTop.set(0, tx);\n        this._visibleLineCountBottom.set(0, tx);\n    }\n    setState(visibleLineCountTop, visibleLineCountBottom, tx) {\n        visibleLineCountTop = Math.max(Math.min(visibleLineCountTop, this.lineCount), 0);\n        visibleLineCountBottom = Math.max(Math.min(visibleLineCountBottom, this.lineCount - visibleLineCountTop), 0);\n        this._visibleLineCountTop.set(visibleLineCountTop, tx);\n        this._visibleLineCountBottom.set(visibleLineCountBottom, tx);\n    }\n}\nfunction applyOriginalEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    return undefined;\n    /*\n    TODO@hediet\n    if (textEdits.length === 0) {\n        return diff;\n    }\n\n    const diff2 = flip(diff);\n    const diff3 = applyModifiedEdits(diff2, textEdits, modifiedTextModel, originalTextModel);\n    if (!diff3) {\n        return undefined;\n    }\n    return flip(diff3);*/\n}\n/*\nfunction flip(diff: IDocumentDiff): IDocumentDiff {\n    return {\n        changes: diff.changes.map(c => c.flip()),\n        moves: diff.moves.map(m => m.flip()),\n        identical: diff.identical,\n        quitEarly: diff.quitEarly,\n    };\n}\n*/\nfunction applyModifiedEdits(diff, textEdits, originalTextModel, modifiedTextModel) {\n    return undefined;\n    /*\n    TODO@hediet\n    if (textEdits.length === 0) {\n        return diff;\n    }\n    if (diff.changes.some(c => !c.innerChanges) || diff.moves.length > 0) {\n        // TODO support these cases\n        return undefined;\n    }\n\n    const changes = applyModifiedEditsToLineRangeMappings(diff.changes, textEdits, originalTextModel, modifiedTextModel);\n\n    const moves = diff.moves.map(m => {\n        const newModifiedRange = applyEditToLineRange(m.lineRangeMapping.modified, textEdits);\n        return newModifiedRange ? new MovedText(\n            new SimpleLineRangeMapping(m.lineRangeMapping.original, newModifiedRange),\n            applyModifiedEditsToLineRangeMappings(m.changes, textEdits, originalTextModel, modifiedTextModel),\n        ) : undefined;\n    }).filter(isDefined);\n\n    return {\n        identical: false,\n        quitEarly: false,\n        changes,\n        moves,\n    };*/\n}\n/*\nfunction applyEditToLineRange(range: LineRange, textEdits: TextEditInfo[]): LineRange | undefined {\n    let rangeStartLineNumber = range.startLineNumber;\n    let rangeEndLineNumberEx = range.endLineNumberExclusive;\n\n    for (let i = textEdits.length - 1; i >= 0; i--) {\n        const textEdit = textEdits[i];\n        const textEditStartLineNumber = lengthGetLineCount(textEdit.startOffset) + 1;\n        const textEditEndLineNumber = lengthGetLineCount(textEdit.endOffset) + 1;\n        const newLengthLineCount = lengthGetLineCount(textEdit.newLength);\n        const delta = newLengthLineCount - (textEditEndLineNumber - textEditStartLineNumber);\n\n        if (textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit is before us\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (textEditStartLineNumber > rangeEndLineNumberEx) {\n            // the text edit is after us\n            // NOOP\n        } else if (textEditStartLineNumber < rangeStartLineNumber && rangeEndLineNumberEx < textEditEndLineNumber) {\n            // the range is fully contained in the text edit\n            return undefined;\n        } else if (textEditStartLineNumber < rangeStartLineNumber && textEditEndLineNumber <= rangeEndLineNumberEx) {\n            // the text edit ends inside our range\n            rangeStartLineNumber = textEditEndLineNumber + 1;\n            rangeStartLineNumber += delta;\n            rangeEndLineNumberEx += delta;\n        } else if (rangeStartLineNumber <= textEditStartLineNumber && textEditEndLineNumber < rangeStartLineNumber) {\n            // the text edit starts inside our range\n            rangeEndLineNumberEx = textEditStartLineNumber;\n        } else {\n            rangeEndLineNumberEx += delta;\n        }\n    }\n\n    return new LineRange(rangeStartLineNumber, rangeEndLineNumberEx);\n}\n\nfunction applyModifiedEditsToLineRangeMappings(changes: readonly LineRangeMapping[], textEdits: TextEditInfo[], originalTextModel: ITextModel, modifiedTextModel: ITextModel): LineRangeMapping[] {\n    const diffTextEdits = changes.flatMap(c => c.innerChanges!.map(c => new TextEditInfo(\n        positionToLength(c.originalRange.getStartPosition()),\n        positionToLength(c.originalRange.getEndPosition()),\n        lengthOfRange(c.modifiedRange).toLength(),\n    )));\n\n    const combined = combineTextEditInfos(diffTextEdits, textEdits);\n\n    let lastOriginalEndOffset = lengthZero;\n    let lastModifiedEndOffset = lengthZero;\n    const rangeMappings = combined.map(c => {\n        const modifiedStartOffset = lengthAdd(lastModifiedEndOffset, lengthDiffNonNegative(lastOriginalEndOffset, c.startOffset));\n        lastOriginalEndOffset = c.endOffset;\n        lastModifiedEndOffset = lengthAdd(modifiedStartOffset, c.newLength);\n\n        return new RangeMapping(\n            Range.fromPositions(lengthToPosition(c.startOffset), lengthToPosition(c.endOffset)),\n            Range.fromPositions(lengthToPosition(modifiedStartOffset), lengthToPosition(lastModifiedEndOffset)),\n        );\n    });\n\n    const newChanges = lineRangeMappingFromRangeMappings(\n        rangeMappings,\n        originalTextModel.getLinesContent(),\n        modifiedTextModel.getLinesContent(),\n    );\n    return newChanges;\n}\n*/\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}