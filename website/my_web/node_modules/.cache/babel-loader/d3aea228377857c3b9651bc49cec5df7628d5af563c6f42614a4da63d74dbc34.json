{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\nexport var StorageHint;\n(function (StorageHint) {\n  // A hint to the storage that the storage\n  // does not exist on disk yet. This allows\n  // the storage library to improve startup\n  // time by not checking the storage for data.\n  StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n  // A hint to the storage that the storage\n  // is backed by an in-memory storage.\n  StorageHint[StorageHint[\"STORAGE_IN_MEMORY\"] = 1] = \"STORAGE_IN_MEMORY\";\n})(StorageHint || (StorageHint = {}));\nexport var StorageState;\n(function (StorageState) {\n  StorageState[StorageState[\"None\"] = 0] = \"None\";\n  StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n  StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n  constructor(database, options = Object.create(null)) {\n    super();\n    this.database = database;\n    this.options = options;\n    this._onDidChangeStorage = this._register(new PauseableEmitter());\n    this.onDidChangeStorage = this._onDidChangeStorage.event;\n    this.state = StorageState.None;\n    this.cache = new Map();\n    this.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n    this.pendingDeletes = new Set();\n    this.pendingInserts = new Map();\n    this.whenFlushedCallbacks = [];\n    this.registerListeners();\n  }\n  registerListeners() {\n    this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n  }\n  onDidChangeItemsExternal(e) {\n    var _a, _b;\n    this._onDidChangeStorage.pause();\n    try {\n      // items that change external require us to update our\n      // caches with the values. we just accept the value and\n      // emit an event if there is a change.\n      (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.acceptExternal(key, value));\n      (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.acceptExternal(key, undefined));\n    } finally {\n      this._onDidChangeStorage.resume();\n    }\n  }\n  acceptExternal(key, value) {\n    if (this.state === StorageState.Closed) {\n      return; // Return early if we are already closed\n    }\n\n    let changed = false;\n    // Item got removed, check for deletion\n    if (isUndefinedOrNull(value)) {\n      changed = this.cache.delete(key);\n    }\n    // Item got updated, check for change\n    else {\n      const currentValue = this.cache.get(key);\n      if (currentValue !== value) {\n        this.cache.set(key, value);\n        changed = true;\n      }\n    }\n    // Signal to outside listeners\n    if (changed) {\n      this._onDidChangeStorage.fire({\n        key,\n        external: true\n      });\n    }\n  }\n  get(key, fallbackValue) {\n    const value = this.cache.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return value;\n  }\n  getBoolean(key, fallbackValue) {\n    const value = this.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return value === 'true';\n  }\n  getNumber(key, fallbackValue) {\n    const value = this.get(key);\n    if (isUndefinedOrNull(value)) {\n      return fallbackValue;\n    }\n    return parseInt(value, 10);\n  }\n  set(key, value, external = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === StorageState.Closed) {\n        return; // Return early if we are already closed\n      }\n      // We remove the key for undefined/null values\n      if (isUndefinedOrNull(value)) {\n        return this.delete(key, external);\n      }\n      // Otherwise, convert to String and store\n      const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n      // Return early if value already set\n      const currentValue = this.cache.get(key);\n      if (currentValue === valueStr) {\n        return;\n      }\n      // Update in cache and pending\n      this.cache.set(key, valueStr);\n      this.pendingInserts.set(key, valueStr);\n      this.pendingDeletes.delete(key);\n      // Event\n      this._onDidChangeStorage.fire({\n        key,\n        external\n      });\n      // Accumulate work by scheduling after timeout\n      return this.doFlush();\n    });\n  }\n  delete(key, external = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.state === StorageState.Closed) {\n        return; // Return early if we are already closed\n      }\n      // Remove from cache and add to pending\n      const wasDeleted = this.cache.delete(key);\n      if (!wasDeleted) {\n        return; // Return early if value already deleted\n      }\n\n      if (!this.pendingDeletes.has(key)) {\n        this.pendingDeletes.add(key);\n      }\n      this.pendingInserts.delete(key);\n      // Event\n      this._onDidChangeStorage.fire({\n        key,\n        external\n      });\n      // Accumulate work by scheduling after timeout\n      return this.doFlush();\n    });\n  }\n  get hasPending() {\n    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n  }\n  flushPending() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hasPending) {\n        return; // return early if nothing to do\n      }\n      // Get pending data\n      const updateRequest = {\n        insert: this.pendingInserts,\n        delete: this.pendingDeletes\n      };\n      // Reset pending data for next run\n      this.pendingDeletes = new Set();\n      this.pendingInserts = new Map();\n      // Update in storage and release any\n      // waiters we have once done\n      return this.database.updateItems(updateRequest).finally(() => {\n        var _a;\n        if (!this.hasPending) {\n          while (this.whenFlushedCallbacks.length) {\n            (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n          }\n        }\n      });\n    });\n  }\n  doFlush(delay) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n        return this.flushPending(); // return early if in-memory\n      }\n\n      return this.flushDelayer.trigger(() => this.flushPending(), delay);\n    });\n  }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n  constructor() {\n    this.onDidChangeItemsExternal = Event.None;\n    this.items = new Map();\n  }\n  updateItems(request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = request.insert) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.items.set(key, value));\n      (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));\n    });\n  }\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ThrottledDelayer","Event","PauseableEmitter","Disposable","stringify","isObject","isUndefinedOrNull","StorageHint","StorageState","Storage","constructor","database","options","Object","create","_onDidChangeStorage","_register","onDidChangeStorage","event","state","None","cache","Map","flushDelayer","DEFAULT_FLUSH_DELAY","pendingDeletes","Set","pendingInserts","whenFlushedCallbacks","registerListeners","onDidChangeItemsExternal","_a","_b","pause","changed","forEach","key","acceptExternal","deleted","undefined","resume","Closed","delete","currentValue","get","set","fire","external","fallbackValue","getBoolean","getNumber","parseInt","valueStr","Array","isArray","String","doFlush","wasDeleted","has","add","hasPending","size","flushPending","updateRequest","insert","updateItems","finally","length","pop","delay","hint","STORAGE_IN_MEMORY","trigger","InMemoryStorageDatabase","items","request"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/base/parts/storage/common/storage.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ThrottledDelayer } from '../../../common/async.js';\nimport { Event, PauseableEmitter } from '../../../common/event.js';\nimport { Disposable } from '../../../common/lifecycle.js';\nimport { stringify } from '../../../common/marshalling.js';\nimport { isObject, isUndefinedOrNull } from '../../../common/types.js';\nexport var StorageHint;\n(function (StorageHint) {\n    // A hint to the storage that the storage\n    // does not exist on disk yet. This allows\n    // the storage library to improve startup\n    // time by not checking the storage for data.\n    StorageHint[StorageHint[\"STORAGE_DOES_NOT_EXIST\"] = 0] = \"STORAGE_DOES_NOT_EXIST\";\n    // A hint to the storage that the storage\n    // is backed by an in-memory storage.\n    StorageHint[StorageHint[\"STORAGE_IN_MEMORY\"] = 1] = \"STORAGE_IN_MEMORY\";\n})(StorageHint || (StorageHint = {}));\nexport var StorageState;\n(function (StorageState) {\n    StorageState[StorageState[\"None\"] = 0] = \"None\";\n    StorageState[StorageState[\"Initialized\"] = 1] = \"Initialized\";\n    StorageState[StorageState[\"Closed\"] = 2] = \"Closed\";\n})(StorageState || (StorageState = {}));\nexport class Storage extends Disposable {\n    constructor(database, options = Object.create(null)) {\n        super();\n        this.database = database;\n        this.options = options;\n        this._onDidChangeStorage = this._register(new PauseableEmitter());\n        this.onDidChangeStorage = this._onDidChangeStorage.event;\n        this.state = StorageState.None;\n        this.cache = new Map();\n        this.flushDelayer = this._register(new ThrottledDelayer(Storage.DEFAULT_FLUSH_DELAY));\n        this.pendingDeletes = new Set();\n        this.pendingInserts = new Map();\n        this.whenFlushedCallbacks = [];\n        this.registerListeners();\n    }\n    registerListeners() {\n        this._register(this.database.onDidChangeItemsExternal(e => this.onDidChangeItemsExternal(e)));\n    }\n    onDidChangeItemsExternal(e) {\n        var _a, _b;\n        this._onDidChangeStorage.pause();\n        try {\n            // items that change external require us to update our\n            // caches with the values. we just accept the value and\n            // emit an event if there is a change.\n            (_a = e.changed) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.acceptExternal(key, value));\n            (_b = e.deleted) === null || _b === void 0 ? void 0 : _b.forEach(key => this.acceptExternal(key, undefined));\n        }\n        finally {\n            this._onDidChangeStorage.resume();\n        }\n    }\n    acceptExternal(key, value) {\n        if (this.state === StorageState.Closed) {\n            return; // Return early if we are already closed\n        }\n        let changed = false;\n        // Item got removed, check for deletion\n        if (isUndefinedOrNull(value)) {\n            changed = this.cache.delete(key);\n        }\n        // Item got updated, check for change\n        else {\n            const currentValue = this.cache.get(key);\n            if (currentValue !== value) {\n                this.cache.set(key, value);\n                changed = true;\n            }\n        }\n        // Signal to outside listeners\n        if (changed) {\n            this._onDidChangeStorage.fire({ key, external: true });\n        }\n    }\n    get(key, fallbackValue) {\n        const value = this.cache.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value;\n    }\n    getBoolean(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return value === 'true';\n    }\n    getNumber(key, fallbackValue) {\n        const value = this.get(key);\n        if (isUndefinedOrNull(value)) {\n            return fallbackValue;\n        }\n        return parseInt(value, 10);\n    }\n    set(key, value, external = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // We remove the key for undefined/null values\n            if (isUndefinedOrNull(value)) {\n                return this.delete(key, external);\n            }\n            // Otherwise, convert to String and store\n            const valueStr = isObject(value) || Array.isArray(value) ? stringify(value) : String(value);\n            // Return early if value already set\n            const currentValue = this.cache.get(key);\n            if (currentValue === valueStr) {\n                return;\n            }\n            // Update in cache and pending\n            this.cache.set(key, valueStr);\n            this.pendingInserts.set(key, valueStr);\n            this.pendingDeletes.delete(key);\n            // Event\n            this._onDidChangeStorage.fire({ key, external });\n            // Accumulate work by scheduling after timeout\n            return this.doFlush();\n        });\n    }\n    delete(key, external = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.state === StorageState.Closed) {\n                return; // Return early if we are already closed\n            }\n            // Remove from cache and add to pending\n            const wasDeleted = this.cache.delete(key);\n            if (!wasDeleted) {\n                return; // Return early if value already deleted\n            }\n            if (!this.pendingDeletes.has(key)) {\n                this.pendingDeletes.add(key);\n            }\n            this.pendingInserts.delete(key);\n            // Event\n            this._onDidChangeStorage.fire({ key, external });\n            // Accumulate work by scheduling after timeout\n            return this.doFlush();\n        });\n    }\n    get hasPending() {\n        return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;\n    }\n    flushPending() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hasPending) {\n                return; // return early if nothing to do\n            }\n            // Get pending data\n            const updateRequest = { insert: this.pendingInserts, delete: this.pendingDeletes };\n            // Reset pending data for next run\n            this.pendingDeletes = new Set();\n            this.pendingInserts = new Map();\n            // Update in storage and release any\n            // waiters we have once done\n            return this.database.updateItems(updateRequest).finally(() => {\n                var _a;\n                if (!this.hasPending) {\n                    while (this.whenFlushedCallbacks.length) {\n                        (_a = this.whenFlushedCallbacks.pop()) === null || _a === void 0 ? void 0 : _a();\n                    }\n                }\n            });\n        });\n    }\n    doFlush(delay) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.options.hint === StorageHint.STORAGE_IN_MEMORY) {\n                return this.flushPending(); // return early if in-memory\n            }\n            return this.flushDelayer.trigger(() => this.flushPending(), delay);\n        });\n    }\n}\nStorage.DEFAULT_FLUSH_DELAY = 100;\nexport class InMemoryStorageDatabase {\n    constructor() {\n        this.onDidChangeItemsExternal = Event.None;\n        this.items = new Map();\n    }\n    updateItems(request) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            (_a = request.insert) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => this.items.set(key, value));\n            (_b = request.delete) === null || _b === void 0 ? void 0 : _b.forEach(key => this.items.delete(key));\n        });\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}