{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n  return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n  constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 0 /* UndoRedoElementType.Resource */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this.resourceLabels = [this.resourceLabel];\n    this.strResources = [this.strResource];\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.isValid = true;\n  }\n  setValid(isValid) {\n    this.isValid = isValid;\n  }\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n}\nclass ResourceReasonPair {\n  constructor(resourceLabel, reason) {\n    this.resourceLabel = resourceLabel;\n    this.reason = reason;\n  }\n}\nclass RemovedResources {\n  constructor() {\n    this.elements = new Map();\n  }\n  createMessage() {\n    const externalRemoval = [];\n    const noParallelUniverses = [];\n    for (const [, element] of this.elements) {\n      const dest = element.reason === 0 /* RemovedResourceReason.ExternalRemoval */ ? externalRemoval : noParallelUniverses;\n      dest.push(element.resourceLabel);\n    }\n    const messages = [];\n    if (externalRemoval.length > 0) {\n      messages.push(nls.localize({\n        key: 'externalRemoval',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n    }\n    if (noParallelUniverses.length > 0) {\n      messages.push(nls.localize({\n        key: 'noParallelUniverses',\n        comment: ['{0} is a list of filenames']\n      }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n    }\n    return messages.join('\\n');\n  }\n  get size() {\n    return this.elements.size;\n  }\n  has(strResource) {\n    return this.elements.has(strResource);\n  }\n  set(strResource, value) {\n    this.elements.set(strResource, value);\n  }\n  delete(strResource) {\n    return this.elements.delete(strResource);\n  }\n}\nclass WorkspaceStackElement {\n  constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n    this.id = ++stackElementCounter;\n    this.type = 1 /* UndoRedoElementType.Workspace */;\n    this.actual = actual;\n    this.label = actual.label;\n    this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n    this.resourceLabels = resourceLabels;\n    this.strResources = strResources;\n    this.groupId = groupId;\n    this.groupOrder = groupOrder;\n    this.sourceId = sourceId;\n    this.sourceOrder = sourceOrder;\n    this.removedResources = null;\n    this.invalidatedResources = null;\n  }\n  canSplit() {\n    return typeof this.actual.split === 'function';\n  }\n  removeResource(resourceLabel, strResource, reason) {\n    if (!this.removedResources) {\n      this.removedResources = new RemovedResources();\n    }\n    if (!this.removedResources.has(strResource)) {\n      this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n    }\n  }\n  setValid(resourceLabel, strResource, isValid) {\n    if (isValid) {\n      if (this.invalidatedResources) {\n        this.invalidatedResources.delete(strResource);\n        if (this.invalidatedResources.size === 0) {\n          this.invalidatedResources = null;\n        }\n      }\n    } else {\n      if (!this.invalidatedResources) {\n        this.invalidatedResources = new RemovedResources();\n      }\n      if (!this.invalidatedResources.has(strResource)) {\n        this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n      }\n    }\n  }\n\n  toString() {\n    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n  }\n}\nclass ResourceEditStack {\n  constructor(resourceLabel, strResource) {\n    this.resourceLabel = resourceLabel;\n    this.strResource = strResource;\n    this._past = [];\n    this._future = [];\n    this.locked = false;\n    this.versionId = 1;\n  }\n  dispose() {\n    for (const element of this._past) {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n\n    for (const element of this._future) {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n\n    this.versionId++;\n  }\n  toString() {\n    const result = [];\n    result.push(`* ${this.strResource}:`);\n    for (let i = 0; i < this._past.length; i++) {\n      result.push(`   * [UNDO] ${this._past[i]}`);\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      result.push(`   * [REDO] ${this._future[i]}`);\n    }\n    return result.join('\\n');\n  }\n  flushAllElements() {\n    this._past = [];\n    this._future = [];\n    this.versionId++;\n  }\n  _setElementValidFlag(element, isValid) {\n    if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n      element.setValid(this.resourceLabel, this.strResource, isValid);\n    } else {\n      element.setValid(isValid);\n    }\n  }\n  setElementsValidFlag(isValid, filter) {\n    for (const element of this._past) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n    for (const element of this._future) {\n      if (filter(element.actual)) {\n        this._setElementValidFlag(element, isValid);\n      }\n    }\n  }\n  pushElement(element) {\n    // remove the future\n    for (const futureElement of this._future) {\n      if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n        futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n      }\n    }\n\n    this._future = [];\n    this._past.push(element);\n    this.versionId++;\n  }\n  createSnapshot(resource) {\n    const elements = [];\n    for (let i = 0, len = this._past.length; i < len; i++) {\n      elements.push(this._past[i].id);\n    }\n    for (let i = this._future.length - 1; i >= 0; i--) {\n      elements.push(this._future[i].id);\n    }\n    return new ResourceEditStackSnapshot(resource, elements);\n  }\n  restoreSnapshot(snapshot) {\n    const snapshotLength = snapshot.elements.length;\n    let isOK = true;\n    let snapshotIndex = 0;\n    let removePastAfter = -1;\n    for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n      const element = this._past[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removePastAfter = 0;\n      }\n      if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n\n    let removeFutureBefore = -1;\n    for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n      const element = this._future[i];\n      if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n        isOK = false;\n        removeFutureBefore = i;\n      }\n      if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n        element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n      }\n    }\n\n    if (removePastAfter !== -1) {\n      this._past = this._past.slice(0, removePastAfter);\n    }\n    if (removeFutureBefore !== -1) {\n      this._future = this._future.slice(removeFutureBefore + 1);\n    }\n    this.versionId++;\n  }\n  getElements() {\n    const past = [];\n    const future = [];\n    for (const element of this._past) {\n      past.push(element.actual);\n    }\n    for (const element of this._future) {\n      future.push(element.actual);\n    }\n    return {\n      past,\n      future\n    };\n  }\n  getClosestPastElement() {\n    if (this._past.length === 0) {\n      return null;\n    }\n    return this._past[this._past.length - 1];\n  }\n  getSecondClosestPastElement() {\n    if (this._past.length < 2) {\n      return null;\n    }\n    return this._past[this._past.length - 2];\n  }\n  getClosestFutureElement() {\n    if (this._future.length === 0) {\n      return null;\n    }\n    return this._future[this._future.length - 1];\n  }\n  hasPastElements() {\n    return this._past.length > 0;\n  }\n  hasFutureElements() {\n    return this._future.length > 0;\n  }\n  splitPastWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._past.length - 1; j >= 0; j--) {\n      if (this._past[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._past[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._past.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  splitFutureWorkspaceElement(toRemove, individualMap) {\n    for (let j = this._future.length - 1; j >= 0; j--) {\n      if (this._future[j] === toRemove) {\n        if (individualMap.has(this.strResource)) {\n          // gets replaced\n          this._future[j] = individualMap.get(this.strResource);\n        } else {\n          // gets deleted\n          this._future.splice(j, 1);\n        }\n        break;\n      }\n    }\n    this.versionId++;\n  }\n  moveBackward(element) {\n    this._past.pop();\n    this._future.push(element);\n    this.versionId++;\n  }\n  moveForward(element) {\n    this._future.pop();\n    this._past.push(element);\n    this.versionId++;\n  }\n}\nclass EditStackSnapshot {\n  constructor(editStacks) {\n    this.editStacks = editStacks;\n    this._versionIds = [];\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      this._versionIds[i] = this.editStacks[i].versionId;\n    }\n  }\n  isValid() {\n    for (let i = 0, len = this.editStacks.length; i < len; i++) {\n      if (this._versionIds[i] !== this.editStacks[i].versionId) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n  constructor(_dialogService, _notificationService) {\n    this._dialogService = _dialogService;\n    this._notificationService = _notificationService;\n    this._editStacks = new Map();\n    this._uriComparisonKeyComputers = [];\n  }\n  getUriComparisonKey(resource) {\n    for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n      if (uriComparisonKeyComputer[0] === resource.scheme) {\n        return uriComparisonKeyComputer[1].getComparisonKey(resource);\n      }\n    }\n    return resource.toString();\n  }\n  _print(label) {\n    console.log(`------------------------------------`);\n    console.log(`AFTER ${label}: `);\n    const str = [];\n    for (const element of this._editStacks) {\n      str.push(element[1].toString());\n    }\n    console.log(str.join('\\n'));\n  }\n  pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n    if (element.type === 0 /* UndoRedoElementType.Resource */) {\n      const resourceLabel = getResourceLabel(element.resource);\n      const strResource = this.getUriComparisonKey(element.resource);\n      this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n    } else {\n      const seen = new Set();\n      const resourceLabels = [];\n      const strResources = [];\n      for (const resource of element.resources) {\n        const resourceLabel = getResourceLabel(resource);\n        const strResource = this.getUriComparisonKey(resource);\n        if (seen.has(strResource)) {\n          continue;\n        }\n        seen.add(strResource);\n        resourceLabels.push(resourceLabel);\n        strResources.push(strResource);\n      }\n      if (resourceLabels.length === 1) {\n        this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n      } else {\n        this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n      }\n    }\n    if (DEBUG) {\n      this._print('pushElement');\n    }\n  }\n  _pushElement(element) {\n    for (let i = 0, len = element.strResources.length; i < len; i++) {\n      const resourceLabel = element.resourceLabels[i];\n      const strResource = element.strResources[i];\n      let editStack;\n      if (this._editStacks.has(strResource)) {\n        editStack = this._editStacks.get(strResource);\n      } else {\n        editStack = new ResourceEditStack(resourceLabel, strResource);\n        this._editStacks.set(strResource, editStack);\n      }\n      editStack.pushElement(element);\n    }\n  }\n  getLastElement(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      if (editStack.hasFutureElements()) {\n        return null;\n      }\n      const closestPastElement = editStack.getClosestPastElement();\n      return closestPastElement ? closestPastElement.actual : null;\n    }\n    return null;\n  }\n  _splitPastWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitPastWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n    const individualArr = toRemove.actual.split();\n    const individualMap = new Map();\n    for (const _element of individualArr) {\n      const resourceLabel = getResourceLabel(_element.resource);\n      const strResource = this.getUriComparisonKey(_element.resource);\n      const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n      individualMap.set(element.strResource, element);\n    }\n    for (const strResource of toRemove.strResources) {\n      if (ignoreResources && ignoreResources.has(strResource)) {\n        continue;\n      }\n      const editStack = this._editStacks.get(strResource);\n      editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n    }\n  }\n  removeElements(resource) {\n    const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.dispose();\n      this._editStacks.delete(strResource);\n    }\n    if (DEBUG) {\n      this._print('removeElements');\n    }\n  }\n  setElementsValidFlag(resource, isValid, filter) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.setElementsValidFlag(isValid, filter);\n    }\n    if (DEBUG) {\n      this._print('setElementsValidFlag');\n    }\n  }\n  createSnapshot(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.createSnapshot(resource);\n    }\n    return new ResourceEditStackSnapshot(resource, []);\n  }\n  restoreSnapshot(snapshot) {\n    const strResource = this.getUriComparisonKey(snapshot.resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      editStack.restoreSnapshot(snapshot);\n      if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n        // the edit stack is now empty, just remove it entirely\n        editStack.dispose();\n        this._editStacks.delete(strResource);\n      }\n    }\n    if (DEBUG) {\n      this._print('restoreSnapshot');\n    }\n  }\n  getElements(resource) {\n    const strResource = this.getUriComparisonKey(resource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.getElements();\n    }\n    return {\n      past: [],\n      future: []\n    };\n  }\n  _findClosestUndoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with the sourceId and with the highest sourceOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canUndo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasPastElements();\n    }\n    return false;\n  }\n  _onError(err, element) {\n    onUnexpectedError(err);\n    // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n    for (const strResource of element.strResources) {\n      this.removeElements(strResource);\n    }\n    this._notificationService.error(err);\n  }\n  _acquireLocks(editStackSnapshot) {\n    // first, check if all locks can be acquired\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        throw new Error('Cannot acquire edit stack lock');\n      }\n    }\n    // can acquire all locks\n    for (const editStack of editStackSnapshot.editStacks) {\n      editStack.locked = true;\n    }\n    return () => {\n      // release all locks\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.locked = false;\n      }\n    };\n  }\n  _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n    const releaseLocks = this._acquireLocks(editStackSnapshot);\n    let result;\n    try {\n      result = invoke();\n    } catch (err) {\n      releaseLocks();\n      cleanup.dispose();\n      return this._onError(err, element);\n    }\n    if (result) {\n      // result is Promise<void>\n      return result.then(() => {\n        releaseLocks();\n        cleanup.dispose();\n        return continuation();\n      }, err => {\n        releaseLocks();\n        cleanup.dispose();\n        return this._onError(err, element);\n      });\n    } else {\n      // result is void\n      releaseLocks();\n      cleanup.dispose();\n      return continuation();\n    }\n  }\n  _invokeWorkspacePrepare(element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof element.actual.prepareUndoRedo === 'undefined') {\n        return Disposable.None;\n      }\n      const result = element.actual.prepareUndoRedo();\n      if (typeof result === 'undefined') {\n        return Disposable.None;\n      }\n      return result;\n    });\n  }\n  _invokeResourcePrepare(element, callback) {\n    if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n      // no preparation needed\n      return callback(Disposable.None);\n    }\n    const r = element.actual.prepareUndoRedo();\n    if (!r) {\n      // nothing to clean up\n      return callback(Disposable.None);\n    }\n    if (isDisposable(r)) {\n      return callback(r);\n    }\n    return r.then(disposable => {\n      return callback(disposable);\n    });\n  }\n  _getAffectedEditStacks(element) {\n    const affectedEditStacks = [];\n    for (const strResource of element.strResources) {\n      affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n    }\n    return new EditStackSnapshot(affectedEditStacks);\n  }\n  _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitPastWorkspaceElement(element, ignoreResources);\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceUndo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last past element in all the impacted resources!\n    const cannotUndoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestPastElement() !== element) {\n        cannotUndoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotUndoDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndUndo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceUndo(strResource, element, undoConfirmed) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n  }\n  _isPartOfUndoGroup(element) {\n    if (!element.groupId) {\n      return false;\n    }\n    // check that there is at least another element with the same groupId ready to be undone\n    for (const [, editStack] of this._editStacks) {\n      const pastElement = editStack.getClosestPastElement();\n      if (!pastElement) {\n        continue;\n      }\n      if (pastElement === element) {\n        const secondPastElement = editStack.getSecondClosestPastElement();\n        if (secondPastElement && secondPastElement.groupId === element.groupId) {\n          // there is another element with the same group id in the same stack!\n          return true;\n        }\n      }\n      if (pastElement.groupId === element.groupId) {\n        // there is another element with the same group id in another stack!\n        return true;\n      }\n    }\n    return false;\n  }\n  _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n        // this element can be split\n        let UndoChoice;\n        (function (UndoChoice) {\n          UndoChoice[UndoChoice[\"All\"] = 0] = \"All\";\n          UndoChoice[UndoChoice[\"This\"] = 1] = \"This\";\n          UndoChoice[UndoChoice[\"Cancel\"] = 2] = \"Cancel\";\n        })(UndoChoice || (UndoChoice = {}));\n        const {\n          result\n        } = yield this._dialogService.prompt({\n          type: Severity.Info,\n          message: nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label),\n          buttons: [{\n            label: nls.localize({\n              key: 'ok',\n              comment: ['{0} denotes a number that is > 1, && denotes a mnemonic']\n            }, \"&&Undo in {0} Files\", editStackSnapshot.editStacks.length),\n            run: () => UndoChoice.All\n          }, {\n            label: nls.localize({\n              key: 'nok',\n              comment: ['&& denotes a mnemonic']\n            }, \"Undo this &&File\"),\n            run: () => UndoChoice.This\n          }],\n          cancelButton: {\n            run: () => UndoChoice.Cancel\n          }\n        });\n        if (result === UndoChoice.Cancel) {\n          // choice: cancel\n          return;\n        }\n        if (result === UndoChoice.This) {\n          // choice: undo this file\n          this._splitPastWorkspaceElement(element, null);\n          return this._undo(strResource, 0, true);\n        }\n        // choice: undo in all files\n        // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n        const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/false);\n        if (verificationError1) {\n          return verificationError1.returnValue;\n        }\n        undoConfirmed = true;\n      }\n      // prepare\n      let cleanup;\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      }\n      // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n      const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n      if (verificationError2) {\n        cleanup.dispose();\n        return verificationError2.returnValue;\n      }\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveBackward(element);\n      }\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n  _resourceUndo(editStack, element, undoConfirmed) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceUndoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.warn(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveBackward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n    });\n  }\n  _findClosestUndoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the highest groupOrder ready to be undone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestPastElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueUndoInGroup(groupId, undoConfirmed) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._undo(matchedStrResource, 0, undoConfirmed);\n    }\n  }\n  undo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._undo(resourceOrSource, 0, false);\n    }\n    return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n  }\n  _undo(strResource, sourceId = 0, undoConfirmed) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestPastElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure undoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be undone before this one\n        return this._undo(matchedStrResource, sourceId, undoConfirmed);\n      }\n    }\n    const shouldPromptForConfirmation = element.sourceId !== sourceId || element.confirmBeforeUndo;\n    if (shouldPromptForConfirmation && !undoConfirmed) {\n      // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n      return this._confirmAndContinueUndo(strResource, sourceId, element);\n    }\n    try {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        return this._workspaceUndo(strResource, element, undoConfirmed);\n      } else {\n        return this._resourceUndo(editStack, element, undoConfirmed);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('undo');\n      }\n    }\n  }\n  _confirmAndContinueUndo(strResource, sourceId, element) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = yield this._dialogService.confirm({\n        message: nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label),\n        primaryButton: nls.localize({\n          key: 'confirmDifferentSource.yes',\n          comment: ['&& denotes a mnemonic']\n        }, \"&&Yes\"),\n        cancelButton: nls.localize('confirmDifferentSource.no', \"No\")\n      });\n      if (!result.confirmed) {\n        return;\n      }\n      return this._undo(strResource, sourceId, true);\n    });\n  }\n  _findClosestRedoElementWithSource(sourceId) {\n    if (!sourceId) {\n      return [null, null];\n    }\n    // find an element with sourceId and with the lowest sourceOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.sourceId === sourceId) {\n        if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  canRedo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? true : false;\n    }\n    const strResource = this.getUriComparisonKey(resourceOrSource);\n    if (this._editStacks.has(strResource)) {\n      const editStack = this._editStacks.get(strResource);\n      return editStack.hasFutureElements();\n    }\n    return false;\n  }\n  _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n    if (element.canSplit()) {\n      this._splitFutureWorkspaceElement(element, ignoreResources);\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError(this._redo(strResource));\n    } else {\n      // Cannot safely split this workspace element => flush all undo/redo stacks\n      for (const strResource of element.strResources) {\n        this.removeElements(strResource);\n      }\n      this._notificationService.warn(message);\n      return new WorkspaceVerificationError();\n    }\n  }\n  _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n    if (element.removedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n    }\n    if (checkInvalidatedResources && element.invalidatedResources) {\n      return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({\n        key: 'cannotWorkspaceRedo',\n        comment: ['{0} is a label for an operation. {1} is another message.']\n      }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n    }\n    // this must be the last future element in all the impacted resources!\n    const cannotRedoDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.getClosestFutureElement() !== element) {\n        cannotRedoDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotRedoDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToChanges',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n    }\n    const cannotLockDueToResources = [];\n    for (const editStack of editStackSnapshot.editStacks) {\n      if (editStack.locked) {\n        cannotLockDueToResources.push(editStack.resourceLabel);\n      }\n    }\n    if (cannotLockDueToResources.length > 0) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n    }\n    // check if new stack elements were added in the meantime...\n    if (!editStackSnapshot.isValid()) {\n      return this._tryToSplitAndRedo(strResource, element, null, nls.localize({\n        key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo',\n        comment: ['{0} is a label for an operation. {1} is a list of filenames.']\n      }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n    }\n    return null;\n  }\n  _workspaceRedo(strResource, element) {\n    const affectedEditStacks = this._getAffectedEditStacks(element);\n    const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/false);\n    if (verificationError) {\n      return verificationError.returnValue;\n    }\n    return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n  }\n  _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // prepare\n      let cleanup;\n      try {\n        cleanup = yield this._invokeWorkspacePrepare(element);\n      } catch (err) {\n        return this._onError(err, element);\n      }\n      // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n      const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/true);\n      if (verificationError) {\n        cleanup.dispose();\n        return verificationError.returnValue;\n      }\n      for (const editStack of editStackSnapshot.editStacks) {\n        editStack.moveForward(element);\n      }\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n  _resourceRedo(editStack, element) {\n    if (!element.isValid) {\n      // invalid element => immediately flush edit stack!\n      editStack.flushAllElements();\n      return;\n    }\n    if (editStack.locked) {\n      const message = nls.localize({\n        key: 'cannotResourceRedoDueToInProgressUndoRedo',\n        comment: ['{0} is a label for an operation.']\n      }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n      this._notificationService.warn(message);\n      return;\n    }\n    return this._invokeResourcePrepare(element, cleanup => {\n      editStack.moveForward(element);\n      return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n    });\n  }\n  _findClosestRedoElementInGroup(groupId) {\n    if (!groupId) {\n      return [null, null];\n    }\n    // find another element with the same groupId and with the lowest groupOrder ready to be redone\n    let matchedElement = null;\n    let matchedStrResource = null;\n    for (const [strResource, editStack] of this._editStacks) {\n      const candidate = editStack.getClosestFutureElement();\n      if (!candidate) {\n        continue;\n      }\n      if (candidate.groupId === groupId) {\n        if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n          matchedElement = candidate;\n          matchedStrResource = strResource;\n        }\n      }\n    }\n    return [matchedElement, matchedStrResource];\n  }\n  _continueRedoInGroup(groupId) {\n    if (!groupId) {\n      return;\n    }\n    const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n    if (matchedStrResource) {\n      return this._redo(matchedStrResource);\n    }\n  }\n  redo(resourceOrSource) {\n    if (resourceOrSource instanceof UndoRedoSource) {\n      const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n      return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n    }\n    if (typeof resourceOrSource === 'string') {\n      return this._redo(resourceOrSource);\n    }\n    return this._redo(this.getUriComparisonKey(resourceOrSource));\n  }\n  _redo(strResource) {\n    if (!this._editStacks.has(strResource)) {\n      return;\n    }\n    const editStack = this._editStacks.get(strResource);\n    const element = editStack.getClosestFutureElement();\n    if (!element) {\n      return;\n    }\n    if (element.groupId) {\n      // this element is a part of a group, we need to make sure redoing in a group is in order\n      const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n      if (element !== matchedElement && matchedStrResource) {\n        // there is an element in the same group that should be redone before this one\n        return this._redo(matchedStrResource);\n      }\n    }\n    try {\n      if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n        return this._workspaceRedo(strResource, element);\n      } else {\n        return this._resourceRedo(editStack, element);\n      }\n    } finally {\n      if (DEBUG) {\n        this._print('redo');\n      }\n    }\n  }\n};\nUndoRedoService = __decorate([__param(0, IDialogService), __param(1, INotificationService)], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n  constructor(returnValue) {\n    this.returnValue = returnValue;\n  }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService, 1 /* InstantiationType.Delayed */);","map":{"version":3,"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","onUnexpectedError","Disposable","isDisposable","Schemas","Severity","nls","IDialogService","registerSingleton","INotificationService","IUndoRedoService","ResourceEditStackSnapshot","UndoRedoGroup","UndoRedoSource","DEBUG","getResourceLabel","resource","scheme","file","fsPath","path","stackElementCounter","ResourceStackElement","constructor","actual","resourceLabel","strResource","groupId","groupOrder","sourceId","sourceOrder","id","type","label","confirmBeforeUndo","resourceLabels","strResources","isValid","setValid","toString","name","ResourceReasonPair","reason","RemovedResources","elements","Map","createMessage","externalRemoval","noParallelUniverses","element","dest","push","messages","localize","comment","join","size","has","set","delete","WorkspaceStackElement","removedResources","invalidatedResources","canSplit","split","removeResource","ResourceEditStack","_past","_future","locked","versionId","dispose","flushAllElements","_setElementValidFlag","setElementsValidFlag","filter","pushElement","futureElement","createSnapshot","len","restoreSnapshot","snapshot","snapshotLength","isOK","snapshotIndex","removePastAfter","removeFutureBefore","slice","getElements","past","future","getClosestPastElement","getSecondClosestPastElement","getClosestFutureElement","hasPastElements","hasFutureElements","splitPastWorkspaceElement","toRemove","individualMap","j","get","splice","splitFutureWorkspaceElement","moveBackward","pop","moveForward","EditStackSnapshot","editStacks","_versionIds","missingEditStack","UndoRedoService","_dialogService","_notificationService","_editStacks","_uriComparisonKeyComputers","getUriComparisonKey","uriComparisonKeyComputer","getComparisonKey","_print","console","log","str","group","None","source","_pushElement","nextOrder","seen","Set","resources","add","editStack","getLastElement","closestPastElement","_splitPastWorkspaceElement","ignoreResources","individualArr","_element","_splitFutureWorkspaceElement","removeElements","_findClosestUndoElementWithSource","matchedElement","matchedStrResource","candidate","canUndo","resourceOrSource","_onError","err","error","_acquireLocks","editStackSnapshot","Error","_safeInvokeWithLocks","invoke","cleanup","continuation","releaseLocks","_invokeWorkspacePrepare","prepareUndoRedo","_invokeResourcePrepare","callback","disposable","_getAffectedEditStacks","affectedEditStacks","_tryToSplitAndUndo","message","warn","WorkspaceVerificationError","_undo","_checkWorkspaceUndo","checkInvalidatedResources","cannotUndoDueToResources","cannotLockDueToResources","_workspaceUndo","undoConfirmed","verificationError","returnValue","_confirmAndExecuteWorkspaceUndo","_isPartOfUndoGroup","pastElement","secondPastElement","UndoChoice","prompt","Info","buttons","run","All","This","cancelButton","Cancel","verificationError1","verificationError2","undo","_continueUndoInGroup","_resourceUndo","_findClosestUndoElementInGroup","undefined","shouldPromptForConfirmation","_confirmAndContinueUndo","confirm","primaryButton","confirmed","_findClosestRedoElementWithSource","canRedo","_tryToSplitAndRedo","_redo","_checkWorkspaceRedo","cannotRedoDueToResources","_workspaceRedo","_executeWorkspaceRedo","redo","_continueRedoInGroup","_resourceRedo","_findClosestRedoElementInGroup"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedoService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Disposable, isDisposable } from '../../../base/common/lifecycle.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport Severity from '../../../base/common/severity.js';\nimport * as nls from '../../../nls.js';\nimport { IDialogService } from '../../dialogs/common/dialogs.js';\nimport { registerSingleton } from '../../instantiation/common/extensions.js';\nimport { INotificationService } from '../../notification/common/notification.js';\nimport { IUndoRedoService, ResourceEditStackSnapshot, UndoRedoGroup, UndoRedoSource } from './undoRedo.js';\nconst DEBUG = false;\nfunction getResourceLabel(resource) {\n    return resource.scheme === Schemas.file ? resource.fsPath : resource.path;\n}\nlet stackElementCounter = 0;\nclass ResourceStackElement {\n    constructor(actual, resourceLabel, strResource, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 0 /* UndoRedoElementType.Resource */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this.resourceLabels = [this.resourceLabel];\n        this.strResources = [this.strResource];\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.isValid = true;\n    }\n    setValid(isValid) {\n        this.isValid = isValid;\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? '  VALID' : 'INVALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceReasonPair {\n    constructor(resourceLabel, reason) {\n        this.resourceLabel = resourceLabel;\n        this.reason = reason;\n    }\n}\nclass RemovedResources {\n    constructor() {\n        this.elements = new Map();\n    }\n    createMessage() {\n        const externalRemoval = [];\n        const noParallelUniverses = [];\n        for (const [, element] of this.elements) {\n            const dest = (element.reason === 0 /* RemovedResourceReason.ExternalRemoval */\n                ? externalRemoval\n                : noParallelUniverses);\n            dest.push(element.resourceLabel);\n        }\n        const messages = [];\n        if (externalRemoval.length > 0) {\n            messages.push(nls.localize({ key: 'externalRemoval', comment: ['{0} is a list of filenames'] }, \"The following files have been closed and modified on disk: {0}.\", externalRemoval.join(', ')));\n        }\n        if (noParallelUniverses.length > 0) {\n            messages.push(nls.localize({ key: 'noParallelUniverses', comment: ['{0} is a list of filenames'] }, \"The following files have been modified in an incompatible way: {0}.\", noParallelUniverses.join(', ')));\n        }\n        return messages.join('\\n');\n    }\n    get size() {\n        return this.elements.size;\n    }\n    has(strResource) {\n        return this.elements.has(strResource);\n    }\n    set(strResource, value) {\n        this.elements.set(strResource, value);\n    }\n    delete(strResource) {\n        return this.elements.delete(strResource);\n    }\n}\nclass WorkspaceStackElement {\n    constructor(actual, resourceLabels, strResources, groupId, groupOrder, sourceId, sourceOrder) {\n        this.id = (++stackElementCounter);\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this.actual = actual;\n        this.label = actual.label;\n        this.confirmBeforeUndo = actual.confirmBeforeUndo || false;\n        this.resourceLabels = resourceLabels;\n        this.strResources = strResources;\n        this.groupId = groupId;\n        this.groupOrder = groupOrder;\n        this.sourceId = sourceId;\n        this.sourceOrder = sourceOrder;\n        this.removedResources = null;\n        this.invalidatedResources = null;\n    }\n    canSplit() {\n        return (typeof this.actual.split === 'function');\n    }\n    removeResource(resourceLabel, strResource, reason) {\n        if (!this.removedResources) {\n            this.removedResources = new RemovedResources();\n        }\n        if (!this.removedResources.has(strResource)) {\n            this.removedResources.set(strResource, new ResourceReasonPair(resourceLabel, reason));\n        }\n    }\n    setValid(resourceLabel, strResource, isValid) {\n        if (isValid) {\n            if (this.invalidatedResources) {\n                this.invalidatedResources.delete(strResource);\n                if (this.invalidatedResources.size === 0) {\n                    this.invalidatedResources = null;\n                }\n            }\n        }\n        else {\n            if (!this.invalidatedResources) {\n                this.invalidatedResources = new RemovedResources();\n            }\n            if (!this.invalidatedResources.has(strResource)) {\n                this.invalidatedResources.set(strResource, new ResourceReasonPair(resourceLabel, 0 /* RemovedResourceReason.ExternalRemoval */));\n            }\n        }\n    }\n    toString() {\n        return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? 'INVALID' : '  VALID'}] ${this.actual.constructor.name} - ${this.actual}`;\n    }\n}\nclass ResourceEditStack {\n    constructor(resourceLabel, strResource) {\n        this.resourceLabel = resourceLabel;\n        this.strResource = strResource;\n        this._past = [];\n        this._future = [];\n        this.locked = false;\n        this.versionId = 1;\n    }\n    dispose() {\n        for (const element of this._past) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        for (const element of this._future) {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        this.versionId++;\n    }\n    toString() {\n        const result = [];\n        result.push(`* ${this.strResource}:`);\n        for (let i = 0; i < this._past.length; i++) {\n            result.push(`   * [UNDO] ${this._past[i]}`);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            result.push(`   * [REDO] ${this._future[i]}`);\n        }\n        return result.join('\\n');\n    }\n    flushAllElements() {\n        this._past = [];\n        this._future = [];\n        this.versionId++;\n    }\n    _setElementValidFlag(element, isValid) {\n        if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n            element.setValid(this.resourceLabel, this.strResource, isValid);\n        }\n        else {\n            element.setValid(isValid);\n        }\n    }\n    setElementsValidFlag(isValid, filter) {\n        for (const element of this._past) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n        for (const element of this._future) {\n            if (filter(element.actual)) {\n                this._setElementValidFlag(element, isValid);\n            }\n        }\n    }\n    pushElement(element) {\n        // remove the future\n        for (const futureElement of this._future) {\n            if (futureElement.type === 1 /* UndoRedoElementType.Workspace */) {\n                futureElement.removeResource(this.resourceLabel, this.strResource, 1 /* RemovedResourceReason.NoParallelUniverses */);\n            }\n        }\n        this._future = [];\n        this._past.push(element);\n        this.versionId++;\n    }\n    createSnapshot(resource) {\n        const elements = [];\n        for (let i = 0, len = this._past.length; i < len; i++) {\n            elements.push(this._past[i].id);\n        }\n        for (let i = this._future.length - 1; i >= 0; i--) {\n            elements.push(this._future[i].id);\n        }\n        return new ResourceEditStackSnapshot(resource, elements);\n    }\n    restoreSnapshot(snapshot) {\n        const snapshotLength = snapshot.elements.length;\n        let isOK = true;\n        let snapshotIndex = 0;\n        let removePastAfter = -1;\n        for (let i = 0, len = this._past.length; i < len; i++, snapshotIndex++) {\n            const element = this._past[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removePastAfter = 0;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        let removeFutureBefore = -1;\n        for (let i = this._future.length - 1; i >= 0; i--, snapshotIndex++) {\n            const element = this._future[i];\n            if (isOK && (snapshotIndex >= snapshotLength || element.id !== snapshot.elements[snapshotIndex])) {\n                isOK = false;\n                removeFutureBefore = i;\n            }\n            if (!isOK && element.type === 1 /* UndoRedoElementType.Workspace */) {\n                element.removeResource(this.resourceLabel, this.strResource, 0 /* RemovedResourceReason.ExternalRemoval */);\n            }\n        }\n        if (removePastAfter !== -1) {\n            this._past = this._past.slice(0, removePastAfter);\n        }\n        if (removeFutureBefore !== -1) {\n            this._future = this._future.slice(removeFutureBefore + 1);\n        }\n        this.versionId++;\n    }\n    getElements() {\n        const past = [];\n        const future = [];\n        for (const element of this._past) {\n            past.push(element.actual);\n        }\n        for (const element of this._future) {\n            future.push(element.actual);\n        }\n        return { past, future };\n    }\n    getClosestPastElement() {\n        if (this._past.length === 0) {\n            return null;\n        }\n        return this._past[this._past.length - 1];\n    }\n    getSecondClosestPastElement() {\n        if (this._past.length < 2) {\n            return null;\n        }\n        return this._past[this._past.length - 2];\n    }\n    getClosestFutureElement() {\n        if (this._future.length === 0) {\n            return null;\n        }\n        return this._future[this._future.length - 1];\n    }\n    hasPastElements() {\n        return (this._past.length > 0);\n    }\n    hasFutureElements() {\n        return (this._future.length > 0);\n    }\n    splitPastWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._past.length - 1; j >= 0; j--) {\n            if (this._past[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._past[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._past.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    splitFutureWorkspaceElement(toRemove, individualMap) {\n        for (let j = this._future.length - 1; j >= 0; j--) {\n            if (this._future[j] === toRemove) {\n                if (individualMap.has(this.strResource)) {\n                    // gets replaced\n                    this._future[j] = individualMap.get(this.strResource);\n                }\n                else {\n                    // gets deleted\n                    this._future.splice(j, 1);\n                }\n                break;\n            }\n        }\n        this.versionId++;\n    }\n    moveBackward(element) {\n        this._past.pop();\n        this._future.push(element);\n        this.versionId++;\n    }\n    moveForward(element) {\n        this._future.pop();\n        this._past.push(element);\n        this.versionId++;\n    }\n}\nclass EditStackSnapshot {\n    constructor(editStacks) {\n        this.editStacks = editStacks;\n        this._versionIds = [];\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            this._versionIds[i] = this.editStacks[i].versionId;\n        }\n    }\n    isValid() {\n        for (let i = 0, len = this.editStacks.length; i < len; i++) {\n            if (this._versionIds[i] !== this.editStacks[i].versionId) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\nconst missingEditStack = new ResourceEditStack('', '');\nmissingEditStack.locked = true;\nlet UndoRedoService = class UndoRedoService {\n    constructor(_dialogService, _notificationService) {\n        this._dialogService = _dialogService;\n        this._notificationService = _notificationService;\n        this._editStacks = new Map();\n        this._uriComparisonKeyComputers = [];\n    }\n    getUriComparisonKey(resource) {\n        for (const uriComparisonKeyComputer of this._uriComparisonKeyComputers) {\n            if (uriComparisonKeyComputer[0] === resource.scheme) {\n                return uriComparisonKeyComputer[1].getComparisonKey(resource);\n            }\n        }\n        return resource.toString();\n    }\n    _print(label) {\n        console.log(`------------------------------------`);\n        console.log(`AFTER ${label}: `);\n        const str = [];\n        for (const element of this._editStacks) {\n            str.push(element[1].toString());\n        }\n        console.log(str.join('\\n'));\n    }\n    pushElement(element, group = UndoRedoGroup.None, source = UndoRedoSource.None) {\n        if (element.type === 0 /* UndoRedoElementType.Resource */) {\n            const resourceLabel = getResourceLabel(element.resource);\n            const strResource = this.getUriComparisonKey(element.resource);\n            this._pushElement(new ResourceStackElement(element, resourceLabel, strResource, group.id, group.nextOrder(), source.id, source.nextOrder()));\n        }\n        else {\n            const seen = new Set();\n            const resourceLabels = [];\n            const strResources = [];\n            for (const resource of element.resources) {\n                const resourceLabel = getResourceLabel(resource);\n                const strResource = this.getUriComparisonKey(resource);\n                if (seen.has(strResource)) {\n                    continue;\n                }\n                seen.add(strResource);\n                resourceLabels.push(resourceLabel);\n                strResources.push(strResource);\n            }\n            if (resourceLabels.length === 1) {\n                this._pushElement(new ResourceStackElement(element, resourceLabels[0], strResources[0], group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n            else {\n                this._pushElement(new WorkspaceStackElement(element, resourceLabels, strResources, group.id, group.nextOrder(), source.id, source.nextOrder()));\n            }\n        }\n        if (DEBUG) {\n            this._print('pushElement');\n        }\n    }\n    _pushElement(element) {\n        for (let i = 0, len = element.strResources.length; i < len; i++) {\n            const resourceLabel = element.resourceLabels[i];\n            const strResource = element.strResources[i];\n            let editStack;\n            if (this._editStacks.has(strResource)) {\n                editStack = this._editStacks.get(strResource);\n            }\n            else {\n                editStack = new ResourceEditStack(resourceLabel, strResource);\n                this._editStacks.set(strResource, editStack);\n            }\n            editStack.pushElement(element);\n        }\n    }\n    getLastElement(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            if (editStack.hasFutureElements()) {\n                return null;\n            }\n            const closestPastElement = editStack.getClosestPastElement();\n            return closestPastElement ? closestPastElement.actual : null;\n        }\n        return null;\n    }\n    _splitPastWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitPastWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    _splitFutureWorkspaceElement(toRemove, ignoreResources) {\n        const individualArr = toRemove.actual.split();\n        const individualMap = new Map();\n        for (const _element of individualArr) {\n            const resourceLabel = getResourceLabel(_element.resource);\n            const strResource = this.getUriComparisonKey(_element.resource);\n            const element = new ResourceStackElement(_element, resourceLabel, strResource, 0, 0, 0, 0);\n            individualMap.set(element.strResource, element);\n        }\n        for (const strResource of toRemove.strResources) {\n            if (ignoreResources && ignoreResources.has(strResource)) {\n                continue;\n            }\n            const editStack = this._editStacks.get(strResource);\n            editStack.splitFutureWorkspaceElement(toRemove, individualMap);\n        }\n    }\n    removeElements(resource) {\n        const strResource = typeof resource === 'string' ? resource : this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.dispose();\n            this._editStacks.delete(strResource);\n        }\n        if (DEBUG) {\n            this._print('removeElements');\n        }\n    }\n    setElementsValidFlag(resource, isValid, filter) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.setElementsValidFlag(isValid, filter);\n        }\n        if (DEBUG) {\n            this._print('setElementsValidFlag');\n        }\n    }\n    createSnapshot(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.createSnapshot(resource);\n        }\n        return new ResourceEditStackSnapshot(resource, []);\n    }\n    restoreSnapshot(snapshot) {\n        const strResource = this.getUriComparisonKey(snapshot.resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            editStack.restoreSnapshot(snapshot);\n            if (!editStack.hasPastElements() && !editStack.hasFutureElements()) {\n                // the edit stack is now empty, just remove it entirely\n                editStack.dispose();\n                this._editStacks.delete(strResource);\n            }\n        }\n        if (DEBUG) {\n            this._print('restoreSnapshot');\n        }\n    }\n    getElements(resource) {\n        const strResource = this.getUriComparisonKey(resource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.getElements();\n        }\n        return { past: [], future: [] };\n    }\n    _findClosestUndoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with the sourceId and with the highest sourceOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder > matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canUndo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasPastElements();\n        }\n        return false;\n    }\n    _onError(err, element) {\n        onUnexpectedError(err);\n        // An error occurred while undoing or redoing => drop the undo/redo stack for all affected resources\n        for (const strResource of element.strResources) {\n            this.removeElements(strResource);\n        }\n        this._notificationService.error(err);\n    }\n    _acquireLocks(editStackSnapshot) {\n        // first, check if all locks can be acquired\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                throw new Error('Cannot acquire edit stack lock');\n            }\n        }\n        // can acquire all locks\n        for (const editStack of editStackSnapshot.editStacks) {\n            editStack.locked = true;\n        }\n        return () => {\n            // release all locks\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.locked = false;\n            }\n        };\n    }\n    _safeInvokeWithLocks(element, invoke, editStackSnapshot, cleanup, continuation) {\n        const releaseLocks = this._acquireLocks(editStackSnapshot);\n        let result;\n        try {\n            result = invoke();\n        }\n        catch (err) {\n            releaseLocks();\n            cleanup.dispose();\n            return this._onError(err, element);\n        }\n        if (result) {\n            // result is Promise<void>\n            return result.then(() => {\n                releaseLocks();\n                cleanup.dispose();\n                return continuation();\n            }, (err) => {\n                releaseLocks();\n                cleanup.dispose();\n                return this._onError(err, element);\n            });\n        }\n        else {\n            // result is void\n            releaseLocks();\n            cleanup.dispose();\n            return continuation();\n        }\n    }\n    _invokeWorkspacePrepare(element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof element.actual.prepareUndoRedo === 'undefined') {\n                return Disposable.None;\n            }\n            const result = element.actual.prepareUndoRedo();\n            if (typeof result === 'undefined') {\n                return Disposable.None;\n            }\n            return result;\n        });\n    }\n    _invokeResourcePrepare(element, callback) {\n        if (element.actual.type !== 1 /* UndoRedoElementType.Workspace */ || typeof element.actual.prepareUndoRedo === 'undefined') {\n            // no preparation needed\n            return callback(Disposable.None);\n        }\n        const r = element.actual.prepareUndoRedo();\n        if (!r) {\n            // nothing to clean up\n            return callback(Disposable.None);\n        }\n        if (isDisposable(r)) {\n            return callback(r);\n        }\n        return r.then((disposable) => {\n            return callback(disposable);\n        });\n    }\n    _getAffectedEditStacks(element) {\n        const affectedEditStacks = [];\n        for (const strResource of element.strResources) {\n            affectedEditStacks.push(this._editStacks.get(strResource) || missingEditStack);\n        }\n        return new EditStackSnapshot(affectedEditStacks);\n    }\n    _tryToSplitAndUndo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitPastWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._undo(strResource, 0, true));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceUndo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndUndo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceUndo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not undo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last past element in all the impacted resources!\n        const cannotUndoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestPastElement() !== element) {\n                cannotUndoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotUndoDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because changes were made to {1}\", element.label, cannotUndoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndUndo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceUndoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceUndo(strResource, element, undoConfirmed) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceUndo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._confirmAndExecuteWorkspaceUndo(strResource, element, affectedEditStacks, undoConfirmed);\n    }\n    _isPartOfUndoGroup(element) {\n        if (!element.groupId) {\n            return false;\n        }\n        // check that there is at least another element with the same groupId ready to be undone\n        for (const [, editStack] of this._editStacks) {\n            const pastElement = editStack.getClosestPastElement();\n            if (!pastElement) {\n                continue;\n            }\n            if (pastElement === element) {\n                const secondPastElement = editStack.getSecondClosestPastElement();\n                if (secondPastElement && secondPastElement.groupId === element.groupId) {\n                    // there is another element with the same group id in the same stack!\n                    return true;\n                }\n            }\n            if (pastElement.groupId === element.groupId) {\n                // there is another element with the same group id in another stack!\n                return true;\n            }\n        }\n        return false;\n    }\n    _confirmAndExecuteWorkspaceUndo(strResource, element, editStackSnapshot, undoConfirmed) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (element.canSplit() && !this._isPartOfUndoGroup(element)) {\n                // this element can be split\n                let UndoChoice;\n                (function (UndoChoice) {\n                    UndoChoice[UndoChoice[\"All\"] = 0] = \"All\";\n                    UndoChoice[UndoChoice[\"This\"] = 1] = \"This\";\n                    UndoChoice[UndoChoice[\"Cancel\"] = 2] = \"Cancel\";\n                })(UndoChoice || (UndoChoice = {}));\n                const { result } = yield this._dialogService.prompt({\n                    type: Severity.Info,\n                    message: nls.localize('confirmWorkspace', \"Would you like to undo '{0}' across all files?\", element.label),\n                    buttons: [\n                        {\n                            label: nls.localize({ key: 'ok', comment: ['{0} denotes a number that is > 1, && denotes a mnemonic'] }, \"&&Undo in {0} Files\", editStackSnapshot.editStacks.length),\n                            run: () => UndoChoice.All\n                        },\n                        {\n                            label: nls.localize({ key: 'nok', comment: ['&& denotes a mnemonic'] }, \"Undo this &&File\"),\n                            run: () => UndoChoice.This\n                        }\n                    ],\n                    cancelButton: {\n                        run: () => UndoChoice.Cancel\n                    }\n                });\n                if (result === UndoChoice.Cancel) {\n                    // choice: cancel\n                    return;\n                }\n                if (result === UndoChoice.This) {\n                    // choice: undo this file\n                    this._splitPastWorkspaceElement(element, null);\n                    return this._undo(strResource, 0, true);\n                }\n                // choice: undo in all files\n                // At this point, it is possible that the element has been made invalid in the meantime (due to the confirmation await)\n                const verificationError1 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*invalidated resources will be checked after the prepare call*/ false);\n                if (verificationError1) {\n                    return verificationError1.returnValue;\n                }\n                undoConfirmed = true;\n            }\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError2 = this._checkWorkspaceUndo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError2) {\n                cleanup.dispose();\n                return verificationError2.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveBackward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), editStackSnapshot, cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _resourceUndo(editStack, element, undoConfirmed) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceUndoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not undo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveBackward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.undo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueUndoInGroup(element.groupId, undoConfirmed));\n        });\n    }\n    _findClosestUndoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the highest groupOrder ready to be undone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestPastElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder > matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueUndoInGroup(groupId, undoConfirmed) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestUndoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._undo(matchedStrResource, 0, undoConfirmed);\n        }\n    }\n    undo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestUndoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._undo(matchedStrResource, resourceOrSource.id, false) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._undo(resourceOrSource, 0, false);\n        }\n        return this._undo(this.getUriComparisonKey(resourceOrSource), 0, false);\n    }\n    _undo(strResource, sourceId = 0, undoConfirmed) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestPastElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure undoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestUndoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be undone before this one\n                return this._undo(matchedStrResource, sourceId, undoConfirmed);\n            }\n        }\n        const shouldPromptForConfirmation = (element.sourceId !== sourceId || element.confirmBeforeUndo);\n        if (shouldPromptForConfirmation && !undoConfirmed) {\n            // Hit a different source or the element asks for prompt before undo, prompt for confirmation\n            return this._confirmAndContinueUndo(strResource, sourceId, element);\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceUndo(strResource, element, undoConfirmed);\n            }\n            else {\n                return this._resourceUndo(editStack, element, undoConfirmed);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('undo');\n            }\n        }\n    }\n    _confirmAndContinueUndo(strResource, sourceId, element) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._dialogService.confirm({\n                message: nls.localize('confirmDifferentSource', \"Would you like to undo '{0}'?\", element.label),\n                primaryButton: nls.localize({ key: 'confirmDifferentSource.yes', comment: ['&& denotes a mnemonic'] }, \"&&Yes\"),\n                cancelButton: nls.localize('confirmDifferentSource.no', \"No\")\n            });\n            if (!result.confirmed) {\n                return;\n            }\n            return this._undo(strResource, sourceId, true);\n        });\n    }\n    _findClosestRedoElementWithSource(sourceId) {\n        if (!sourceId) {\n            return [null, null];\n        }\n        // find an element with sourceId and with the lowest sourceOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.sourceId === sourceId) {\n                if (!matchedElement || candidate.sourceOrder < matchedElement.sourceOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    canRedo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? true : false;\n        }\n        const strResource = this.getUriComparisonKey(resourceOrSource);\n        if (this._editStacks.has(strResource)) {\n            const editStack = this._editStacks.get(strResource);\n            return editStack.hasFutureElements();\n        }\n        return false;\n    }\n    _tryToSplitAndRedo(strResource, element, ignoreResources, message) {\n        if (element.canSplit()) {\n            this._splitFutureWorkspaceElement(element, ignoreResources);\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError(this._redo(strResource));\n        }\n        else {\n            // Cannot safely split this workspace element => flush all undo/redo stacks\n            for (const strResource of element.strResources) {\n                this.removeElements(strResource);\n            }\n            this._notificationService.warn(message);\n            return new WorkspaceVerificationError();\n        }\n    }\n    _checkWorkspaceRedo(strResource, element, editStackSnapshot, checkInvalidatedResources) {\n        if (element.removedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.removedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.removedResources.createMessage()));\n        }\n        if (checkInvalidatedResources && element.invalidatedResources) {\n            return this._tryToSplitAndRedo(strResource, element, element.invalidatedResources, nls.localize({ key: 'cannotWorkspaceRedo', comment: ['{0} is a label for an operation. {1} is another message.'] }, \"Could not redo '{0}' across all files. {1}\", element.label, element.invalidatedResources.createMessage()));\n        }\n        // this must be the last future element in all the impacted resources!\n        const cannotRedoDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.getClosestFutureElement() !== element) {\n                cannotRedoDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotRedoDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToChanges', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because changes were made to {1}\", element.label, cannotRedoDueToResources.join(', ')));\n        }\n        const cannotLockDueToResources = [];\n        for (const editStack of editStackSnapshot.editStacks) {\n            if (editStack.locked) {\n                cannotLockDueToResources.push(editStack.resourceLabel);\n            }\n        }\n        if (cannotLockDueToResources.length > 0) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}\", element.label, cannotLockDueToResources.join(', ')));\n        }\n        // check if new stack elements were added in the meantime...\n        if (!editStackSnapshot.isValid()) {\n            return this._tryToSplitAndRedo(strResource, element, null, nls.localize({ key: 'cannotWorkspaceRedoDueToInMeantimeUndoRedo', comment: ['{0} is a label for an operation. {1} is a list of filenames.'] }, \"Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime\", element.label));\n        }\n        return null;\n    }\n    _workspaceRedo(strResource, element) {\n        const affectedEditStacks = this._getAffectedEditStacks(element);\n        const verificationError = this._checkWorkspaceRedo(strResource, element, affectedEditStacks, /*invalidated resources will be checked after the prepare call*/ false);\n        if (verificationError) {\n            return verificationError.returnValue;\n        }\n        return this._executeWorkspaceRedo(strResource, element, affectedEditStacks);\n    }\n    _executeWorkspaceRedo(strResource, element, editStackSnapshot) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // prepare\n            let cleanup;\n            try {\n                cleanup = yield this._invokeWorkspacePrepare(element);\n            }\n            catch (err) {\n                return this._onError(err, element);\n            }\n            // At this point, it is possible that the element has been made invalid in the meantime (due to the prepare await)\n            const verificationError = this._checkWorkspaceRedo(strResource, element, editStackSnapshot, /*now also check that there are no more invalidated resources*/ true);\n            if (verificationError) {\n                cleanup.dispose();\n                return verificationError.returnValue;\n            }\n            for (const editStack of editStackSnapshot.editStacks) {\n                editStack.moveForward(element);\n            }\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), editStackSnapshot, cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _resourceRedo(editStack, element) {\n        if (!element.isValid) {\n            // invalid element => immediately flush edit stack!\n            editStack.flushAllElements();\n            return;\n        }\n        if (editStack.locked) {\n            const message = nls.localize({ key: 'cannotResourceRedoDueToInProgressUndoRedo', comment: ['{0} is a label for an operation.'] }, \"Could not redo '{0}' because there is already an undo or redo operation running.\", element.label);\n            this._notificationService.warn(message);\n            return;\n        }\n        return this._invokeResourcePrepare(element, (cleanup) => {\n            editStack.moveForward(element);\n            return this._safeInvokeWithLocks(element, () => element.actual.redo(), new EditStackSnapshot([editStack]), cleanup, () => this._continueRedoInGroup(element.groupId));\n        });\n    }\n    _findClosestRedoElementInGroup(groupId) {\n        if (!groupId) {\n            return [null, null];\n        }\n        // find another element with the same groupId and with the lowest groupOrder ready to be redone\n        let matchedElement = null;\n        let matchedStrResource = null;\n        for (const [strResource, editStack] of this._editStacks) {\n            const candidate = editStack.getClosestFutureElement();\n            if (!candidate) {\n                continue;\n            }\n            if (candidate.groupId === groupId) {\n                if (!matchedElement || candidate.groupOrder < matchedElement.groupOrder) {\n                    matchedElement = candidate;\n                    matchedStrResource = strResource;\n                }\n            }\n        }\n        return [matchedElement, matchedStrResource];\n    }\n    _continueRedoInGroup(groupId) {\n        if (!groupId) {\n            return;\n        }\n        const [, matchedStrResource] = this._findClosestRedoElementInGroup(groupId);\n        if (matchedStrResource) {\n            return this._redo(matchedStrResource);\n        }\n    }\n    redo(resourceOrSource) {\n        if (resourceOrSource instanceof UndoRedoSource) {\n            const [, matchedStrResource] = this._findClosestRedoElementWithSource(resourceOrSource.id);\n            return matchedStrResource ? this._redo(matchedStrResource) : undefined;\n        }\n        if (typeof resourceOrSource === 'string') {\n            return this._redo(resourceOrSource);\n        }\n        return this._redo(this.getUriComparisonKey(resourceOrSource));\n    }\n    _redo(strResource) {\n        if (!this._editStacks.has(strResource)) {\n            return;\n        }\n        const editStack = this._editStacks.get(strResource);\n        const element = editStack.getClosestFutureElement();\n        if (!element) {\n            return;\n        }\n        if (element.groupId) {\n            // this element is a part of a group, we need to make sure redoing in a group is in order\n            const [matchedElement, matchedStrResource] = this._findClosestRedoElementInGroup(element.groupId);\n            if (element !== matchedElement && matchedStrResource) {\n                // there is an element in the same group that should be redone before this one\n                return this._redo(matchedStrResource);\n            }\n        }\n        try {\n            if (element.type === 1 /* UndoRedoElementType.Workspace */) {\n                return this._workspaceRedo(strResource, element);\n            }\n            else {\n                return this._resourceRedo(editStack, element);\n            }\n        }\n        finally {\n            if (DEBUG) {\n                this._print('redo');\n            }\n        }\n    }\n};\nUndoRedoService = __decorate([\n    __param(0, IDialogService),\n    __param(1, INotificationService)\n], UndoRedoService);\nexport { UndoRedoService };\nclass WorkspaceVerificationError {\n    constructor(returnValue) {\n        this.returnValue = returnValue;\n    }\n}\nregisterSingleton(IUndoRedoService, UndoRedoService, 1 /* InstantiationType.Delayed */);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}