{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n    const defaultReplaceRange = getDefaultRange(position, model);\n    const providers = registry.all(model);\n    const multiMap = new SetMap();\n    for (const provider of providers) {\n      if (provider.groupId) {\n        multiMap.add(provider.groupId, provider);\n      }\n    }\n    function getPreferredProviders(provider) {\n      if (!provider.yieldsToGroupIds) {\n        return [];\n      }\n      const result = [];\n      for (const groupId of provider.yieldsToGroupIds || []) {\n        const providers = multiMap.get(groupId);\n        for (const p of providers) {\n          result.push(p);\n        }\n      }\n      return result;\n    }\n    const states = new Map();\n    const seen = new Set();\n    function findPreferredProviderCircle(provider, stack) {\n      stack = [...stack, provider];\n      if (seen.has(provider)) {\n        return stack;\n      }\n      seen.add(provider);\n      try {\n        const preferred = getPreferredProviders(provider);\n        for (const p of preferred) {\n          const c = findPreferredProviderCircle(p, stack);\n          if (c) {\n            return c;\n          }\n        }\n      } finally {\n        seen.delete(provider);\n      }\n      return undefined;\n    }\n    function processProvider(provider) {\n      const state = states.get(provider);\n      if (state) {\n        return state;\n      }\n      const circle = findPreferredProviderCircle(provider, []);\n      if (circle) {\n        onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : '' + s).join(' -> ')}`));\n      }\n      const deferredPromise = new DeferredPromise();\n      states.set(provider, deferredPromise.p);\n      (() => __awaiter(this, void 0, void 0, function* () {\n        if (!circle) {\n          const preferred = getPreferredProviders(provider);\n          for (const p of preferred) {\n            const result = yield processProvider(p);\n            if (result && result.items.length > 0) {\n              // Skip provider\n              return undefined;\n            }\n          }\n        }\n        try {\n          const completions = yield provider.provideInlineCompletions(model, position, context, token);\n          return completions;\n        } catch (e) {\n          onUnexpectedExternalError(e);\n          return undefined;\n        }\n      }))().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n      return deferredPromise.p;\n    }\n    const providerResults = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      return {\n        provider,\n        completions: yield processProvider(provider)\n      };\n    })));\n    const itemsByHash = new Map();\n    const lists = [];\n    for (const result of providerResults) {\n      const completions = result.completions;\n      if (!completions) {\n        continue;\n      }\n      const list = new InlineCompletionList(completions, result.provider);\n      lists.push(list);\n      for (const item of completions.items) {\n        const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n        itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n      }\n    }\n    return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n  });\n}\nexport class InlineCompletionProviderResult {\n  constructor(\n  /**\n   * Free of duplicates.\n   */\n  completions, hashs, providerResults) {\n    this.completions = completions;\n    this.hashs = hashs;\n    this.providerResults = providerResults;\n  }\n  has(item) {\n    return this.hashs.has(item.hash());\n  }\n  dispose() {\n    for (const result of this.providerResults) {\n      result.removeRef();\n    }\n  }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n  constructor(inlineCompletions, provider) {\n    this.inlineCompletions = inlineCompletions;\n    this.provider = provider;\n    this.refCount = 1;\n  }\n  addRef() {\n    this.refCount++;\n  }\n  removeRef() {\n    this.refCount--;\n    if (this.refCount === 0) {\n      this.provider.freeInlineCompletions(this.inlineCompletions);\n    }\n  }\n}\nexport class InlineCompletionItem {\n  static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n    let insertText;\n    let snippetInfo;\n    let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n    if (typeof inlineCompletion.insertText === 'string') {\n      insertText = inlineCompletion.insertText;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = insertText.length - inlineCompletion.insertText.length;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      snippetInfo = undefined;\n    } else if ('snippet' in inlineCompletion.insertText) {\n      const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n      if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n        inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n        // Modify range depending on if brackets are added or removed\n        const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n        if (diff !== 0) {\n          range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n        }\n      }\n      const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n      if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n        insertText = snippet.children[0].value;\n        snippetInfo = undefined;\n      } else {\n        insertText = snippet.toString();\n        snippetInfo = {\n          snippet: inlineCompletion.insertText.snippet,\n          range: range\n        };\n      }\n    } else {\n      assertNever(inlineCompletion.insertText);\n    }\n    return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n  }\n  constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits,\n  /**\n   * A reference to the original inline completion this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  sourceInlineCompletion,\n  /**\n   * A reference to the original inline completion list this inline completion has been constructed from.\n   * Used for event data to ensure referential equality.\n  */\n  source) {\n    this.filterText = filterText;\n    this.command = command;\n    this.range = range;\n    this.insertText = insertText;\n    this.snippetInfo = snippetInfo;\n    this.additionalTextEdits = additionalTextEdits;\n    this.sourceInlineCompletion = sourceInlineCompletion;\n    this.source = source;\n    filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n  }\n  withRange(updatedRange) {\n    return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n  }\n  hash() {\n    return JSON.stringify({\n      insertText: this.insertText,\n      range: this.range.toString()\n    });\n  }\n}\nfunction getDefaultRange(position, model) {\n  const word = model.getWordAtPosition(position);\n  const maxColumn = model.getLineMaxColumn(position.lineNumber);\n  // By default, always replace up until the end of the current line.\n  // This default might be subject to change!\n  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n  const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n  const newLine = lineStart + text;\n  const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n  const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n  if (!slicedTokens) {\n    return text;\n  }\n  const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n  return newText;\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","assertNever","DeferredPromise","CancellationToken","SetMap","onUnexpectedExternalError","Range","fixBracketsInLine","getReadonlyEmptyArray","SnippetParser","Text","provideInlineCompletions","registry","position","model","context","token","None","languageConfigurationService","defaultReplaceRange","getDefaultRange","providers","all","multiMap","provider","groupId","add","getPreferredProviders","yieldsToGroupIds","get","p","push","states","Map","seen","Set","findPreferredProviderCircle","stack","has","preferred","c","delete","undefined","processProvider","state","circle","Error","map","s","toString","join","deferredPromise","set","items","length","completions","complete","error","providerResults","itemsByHash","lists","list","InlineCompletionList","item","inlineCompletionItem","InlineCompletionItem","from","hash","InlineCompletionProviderResult","Array","values","keys","constructor","hashs","dispose","removeRef","inlineCompletions","refCount","addRef","freeInlineCompletions","inlineCompletion","source","textModel","insertText","snippetInfo","range","lift","completeBracketPairs","closeBrackets","getStartPosition","diff","startLineNumber","startColumn","endLineNumber","endColumn","preBracketCompletionLength","snippet","parse","children","command","additionalTextEdits","filterText","sourceInlineCompletion","replace","withRange","updatedRange","JSON","stringify","word","getWordAtPosition","maxColumn","getLineMaxColumn","lineNumber","fromPositions","with","text","lineStart","getLineContent","substring","column","newLine","newTokens","tokenization","tokenizeLineWithEdit","slicedTokens","sliceAndInflate","newText"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/browser/provideInlineCompletions.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { assertNever } from '../../../../base/common/assert.js';\nimport { DeferredPromise } from '../../../../base/common/async.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { SetMap } from '../../../../base/common/map.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Range } from '../../../common/core/range.js';\nimport { fixBracketsInLine } from '../../../common/model/bracketPairsTextModelPart/fixBrackets.js';\nimport { getReadonlyEmptyArray } from './utils.js';\nimport { SnippetParser, Text } from '../../snippet/browser/snippetParser.js';\nexport function provideInlineCompletions(registry, position, model, context, token = CancellationToken.None, languageConfigurationService) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Important: Don't use position after the await calls, as the model could have been changed in the meantime!\n        const defaultReplaceRange = getDefaultRange(position, model);\n        const providers = registry.all(model);\n        const multiMap = new SetMap();\n        for (const provider of providers) {\n            if (provider.groupId) {\n                multiMap.add(provider.groupId, provider);\n            }\n        }\n        function getPreferredProviders(provider) {\n            if (!provider.yieldsToGroupIds) {\n                return [];\n            }\n            const result = [];\n            for (const groupId of provider.yieldsToGroupIds || []) {\n                const providers = multiMap.get(groupId);\n                for (const p of providers) {\n                    result.push(p);\n                }\n            }\n            return result;\n        }\n        const states = new Map();\n        const seen = new Set();\n        function findPreferredProviderCircle(provider, stack) {\n            stack = [...stack, provider];\n            if (seen.has(provider)) {\n                return stack;\n            }\n            seen.add(provider);\n            try {\n                const preferred = getPreferredProviders(provider);\n                for (const p of preferred) {\n                    const c = findPreferredProviderCircle(p, stack);\n                    if (c) {\n                        return c;\n                    }\n                }\n            }\n            finally {\n                seen.delete(provider);\n            }\n            return undefined;\n        }\n        function processProvider(provider) {\n            const state = states.get(provider);\n            if (state) {\n                return state;\n            }\n            const circle = findPreferredProviderCircle(provider, []);\n            if (circle) {\n                onUnexpectedExternalError(new Error(`Inline completions: cyclic yield-to dependency detected. Path: ${circle.map(s => s.toString ? s.toString() : ('' + s)).join(' -> ')}`));\n            }\n            const deferredPromise = new DeferredPromise();\n            states.set(provider, deferredPromise.p);\n            (() => __awaiter(this, void 0, void 0, function* () {\n                if (!circle) {\n                    const preferred = getPreferredProviders(provider);\n                    for (const p of preferred) {\n                        const result = yield processProvider(p);\n                        if (result && result.items.length > 0) {\n                            // Skip provider\n                            return undefined;\n                        }\n                    }\n                }\n                try {\n                    const completions = yield provider.provideInlineCompletions(model, position, context, token);\n                    return completions;\n                }\n                catch (e) {\n                    onUnexpectedExternalError(e);\n                    return undefined;\n                }\n            }))().then(c => deferredPromise.complete(c), e => deferredPromise.error(e));\n            return deferredPromise.p;\n        }\n        const providerResults = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () { return ({ provider, completions: yield processProvider(provider) }); })));\n        const itemsByHash = new Map();\n        const lists = [];\n        for (const result of providerResults) {\n            const completions = result.completions;\n            if (!completions) {\n                continue;\n            }\n            const list = new InlineCompletionList(completions, result.provider);\n            lists.push(list);\n            for (const item of completions.items) {\n                const inlineCompletionItem = InlineCompletionItem.from(item, list, defaultReplaceRange, model, languageConfigurationService);\n                itemsByHash.set(inlineCompletionItem.hash(), inlineCompletionItem);\n            }\n        }\n        return new InlineCompletionProviderResult(Array.from(itemsByHash.values()), new Set(itemsByHash.keys()), lists);\n    });\n}\nexport class InlineCompletionProviderResult {\n    constructor(\n    /**\n     * Free of duplicates.\n     */\n    completions, hashs, providerResults) {\n        this.completions = completions;\n        this.hashs = hashs;\n        this.providerResults = providerResults;\n    }\n    has(item) {\n        return this.hashs.has(item.hash());\n    }\n    dispose() {\n        for (const result of this.providerResults) {\n            result.removeRef();\n        }\n    }\n}\n/**\n * A ref counted pointer to the computed `InlineCompletions` and the `InlineCompletionsProvider` that\n * computed them.\n */\nexport class InlineCompletionList {\n    constructor(inlineCompletions, provider) {\n        this.inlineCompletions = inlineCompletions;\n        this.provider = provider;\n        this.refCount = 1;\n    }\n    addRef() {\n        this.refCount++;\n    }\n    removeRef() {\n        this.refCount--;\n        if (this.refCount === 0) {\n            this.provider.freeInlineCompletions(this.inlineCompletions);\n        }\n    }\n}\nexport class InlineCompletionItem {\n    static from(inlineCompletion, source, defaultReplaceRange, textModel, languageConfigurationService) {\n        let insertText;\n        let snippetInfo;\n        let range = inlineCompletion.range ? Range.lift(inlineCompletion.range) : defaultReplaceRange;\n        if (typeof inlineCompletion.insertText === 'string') {\n            insertText = inlineCompletion.insertText;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                insertText = closeBrackets(insertText, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = insertText.length - inlineCompletion.insertText.length;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            snippetInfo = undefined;\n        }\n        else if ('snippet' in inlineCompletion.insertText) {\n            const preBracketCompletionLength = inlineCompletion.insertText.snippet.length;\n            if (languageConfigurationService && inlineCompletion.completeBracketPairs) {\n                inlineCompletion.insertText.snippet = closeBrackets(inlineCompletion.insertText.snippet, range.getStartPosition(), textModel, languageConfigurationService);\n                // Modify range depending on if brackets are added or removed\n                const diff = inlineCompletion.insertText.snippet.length - preBracketCompletionLength;\n                if (diff !== 0) {\n                    range = new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn + diff);\n                }\n            }\n            const snippet = new SnippetParser().parse(inlineCompletion.insertText.snippet);\n            if (snippet.children.length === 1 && snippet.children[0] instanceof Text) {\n                insertText = snippet.children[0].value;\n                snippetInfo = undefined;\n            }\n            else {\n                insertText = snippet.toString();\n                snippetInfo = {\n                    snippet: inlineCompletion.insertText.snippet,\n                    range: range\n                };\n            }\n        }\n        else {\n            assertNever(inlineCompletion.insertText);\n        }\n        return new InlineCompletionItem(insertText, inlineCompletion.command, range, insertText, snippetInfo, inlineCompletion.additionalTextEdits || getReadonlyEmptyArray(), inlineCompletion, source);\n    }\n    constructor(filterText, command, range, insertText, snippetInfo, additionalTextEdits, \n    /**\n     * A reference to the original inline completion this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    sourceInlineCompletion, \n    /**\n     * A reference to the original inline completion list this inline completion has been constructed from.\n     * Used for event data to ensure referential equality.\n    */\n    source) {\n        this.filterText = filterText;\n        this.command = command;\n        this.range = range;\n        this.insertText = insertText;\n        this.snippetInfo = snippetInfo;\n        this.additionalTextEdits = additionalTextEdits;\n        this.sourceInlineCompletion = sourceInlineCompletion;\n        this.source = source;\n        filterText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n        insertText = filterText.replace(/\\r\\n|\\r/g, '\\n');\n    }\n    withRange(updatedRange) {\n        return new InlineCompletionItem(this.filterText, this.command, updatedRange, this.insertText, this.snippetInfo, this.additionalTextEdits, this.sourceInlineCompletion, this.source);\n    }\n    hash() {\n        return JSON.stringify({ insertText: this.insertText, range: this.range.toString() });\n    }\n}\nfunction getDefaultRange(position, model) {\n    const word = model.getWordAtPosition(position);\n    const maxColumn = model.getLineMaxColumn(position.lineNumber);\n    // By default, always replace up until the end of the current line.\n    // This default might be subject to change!\n    return word\n        ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn)\n        : Range.fromPositions(position, position.with(undefined, maxColumn));\n}\nfunction closeBrackets(text, position, model, languageConfigurationService) {\n    const lineStart = model.getLineContent(position.lineNumber).substring(0, position.column - 1);\n    const newLine = lineStart + text;\n    const newTokens = model.tokenization.tokenizeLineWithEdit(position, newLine.length - (position.column - 1), text);\n    const slicedTokens = newTokens === null || newTokens === void 0 ? void 0 : newTokens.sliceAndInflate(position.column - 1, newLine.length, 0);\n    if (!slicedTokens) {\n        return text;\n    }\n    const newText = fixBracketsInLine(slicedTokens, languageConfigurationService);\n    return newText;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}