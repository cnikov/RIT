{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel {\n  get uri() {\n    return this._uri;\n  }\n  get eol() {\n    return this._eol;\n  }\n  getValue() {\n    return this.getText();\n  }\n  findMatches(regex) {\n    const matches = [];\n    for (let i = 0; i < this._lines.length; i++) {\n      const line = this._lines[i];\n      const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n      const iteratorOverMatches = line.matchAll(regex);\n      for (const match of iteratorOverMatches) {\n        if (match.index || match.index === 0) {\n          match.index = match.index + offsetToAdd;\n        }\n        matches.push(match);\n      }\n    }\n    return matches;\n  }\n  getLinesContent() {\n    return this._lines.slice(0);\n  }\n  getLineCount() {\n    return this._lines.length;\n  }\n  getLineContent(lineNumber) {\n    return this._lines[lineNumber - 1];\n  }\n  getWordAtPosition(position, wordDefinition) {\n    const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n    if (wordAtText) {\n      return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n    }\n    return null;\n  }\n  words(wordDefinition) {\n    const lines = this._lines;\n    const wordenize = this._wordenize.bind(this);\n    let lineNumber = 0;\n    let lineText = '';\n    let wordRangesIdx = 0;\n    let wordRanges = [];\n    return {\n      *[Symbol.iterator]() {\n        while (true) {\n          if (wordRangesIdx < wordRanges.length) {\n            const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n            wordRangesIdx += 1;\n            yield value;\n          } else {\n            if (lineNumber < lines.length) {\n              lineText = lines[lineNumber];\n              wordRanges = wordenize(lineText, wordDefinition);\n              wordRangesIdx = 0;\n              lineNumber += 1;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n    };\n  }\n  getLineWords(lineNumber, wordDefinition) {\n    const content = this._lines[lineNumber - 1];\n    const ranges = this._wordenize(content, wordDefinition);\n    const words = [];\n    for (const range of ranges) {\n      words.push({\n        word: content.substring(range.start, range.end),\n        startColumn: range.start + 1,\n        endColumn: range.end + 1\n      });\n    }\n    return words;\n  }\n  _wordenize(content, wordDefinition) {\n    const result = [];\n    let match;\n    wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n    while (match = wordDefinition.exec(content)) {\n      if (match[0].length === 0) {\n        // it did match the empty string\n        break;\n      }\n      result.push({\n        start: match.index,\n        end: match.index + match[0].length\n      });\n    }\n    return result;\n  }\n  getValueInRange(range) {\n    range = this._validateRange(range);\n    if (range.startLineNumber === range.endLineNumber) {\n      return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n    }\n    const lineEnding = this._eol;\n    const startLineIndex = range.startLineNumber - 1;\n    const endLineIndex = range.endLineNumber - 1;\n    const resultLines = [];\n    resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n    for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n      resultLines.push(this._lines[i]);\n    }\n    resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n    return resultLines.join(lineEnding);\n  }\n  offsetAt(position) {\n    position = this._validatePosition(position);\n    this._ensureLineStarts();\n    return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n  }\n  positionAt(offset) {\n    offset = Math.floor(offset);\n    offset = Math.max(0, offset);\n    this._ensureLineStarts();\n    const out = this._lineStarts.getIndexOf(offset);\n    const lineLength = this._lines[out.index].length;\n    // Ensure we return a valid position\n    return {\n      lineNumber: 1 + out.index,\n      column: 1 + Math.min(out.remainder, lineLength)\n    };\n  }\n  _validateRange(range) {\n    const start = this._validatePosition({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const end = this._validatePosition({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    if (start.lineNumber !== range.startLineNumber || start.column !== range.startColumn || end.lineNumber !== range.endLineNumber || end.column !== range.endColumn) {\n      return {\n        startLineNumber: start.lineNumber,\n        startColumn: start.column,\n        endLineNumber: end.lineNumber,\n        endColumn: end.column\n      };\n    }\n    return range;\n  }\n  _validatePosition(position) {\n    if (!Position.isIPosition(position)) {\n      throw new Error('bad position');\n    }\n    let {\n      lineNumber,\n      column\n    } = position;\n    let hasChanged = false;\n    if (lineNumber < 1) {\n      lineNumber = 1;\n      column = 1;\n      hasChanged = true;\n    } else if (lineNumber > this._lines.length) {\n      lineNumber = this._lines.length;\n      column = this._lines[lineNumber - 1].length + 1;\n      hasChanged = true;\n    } else {\n      const maxCharacter = this._lines[lineNumber - 1].length + 1;\n      if (column < 1) {\n        column = 1;\n        hasChanged = true;\n      } else if (column > maxCharacter) {\n        column = maxCharacter;\n        hasChanged = true;\n      }\n    }\n    if (!hasChanged) {\n      return position;\n    } else {\n      return {\n        lineNumber,\n        column\n      };\n    }\n  }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n  constructor(host, foreignModuleFactory) {\n    this._host = host;\n    this._models = Object.create(null);\n    this._foreignModuleFactory = foreignModuleFactory;\n    this._foreignModule = null;\n  }\n  dispose() {\n    this._models = Object.create(null);\n  }\n  _getModel(uri) {\n    return this._models[uri];\n  }\n  _getModels() {\n    const all = [];\n    Object.keys(this._models).forEach(key => all.push(this._models[key]));\n    return all;\n  }\n  acceptNewModel(data) {\n    this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n  }\n  acceptModelChanged(strURL, e) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    const model = this._models[strURL];\n    model.onEvents(e);\n  }\n  acceptRemovedModel(strURL) {\n    if (!this._models[strURL]) {\n      return;\n    }\n    delete this._models[strURL];\n  }\n  computeUnicodeHighlights(url, options, range) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(url);\n      if (!model) {\n        return {\n          ranges: [],\n          hasMore: false,\n          ambiguousCharacterCount: 0,\n          invisibleCharacterCount: 0,\n          nonBasicAsciiCharacterCount: 0\n        };\n      }\n      return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    });\n  }\n  // ---- BEGIN diff --------------------------------------------------------------------------\n  computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const original = this._getModel(originalUrl);\n      const modified = this._getModel(modifiedUrl);\n      if (!original || !modified) {\n        return null;\n      }\n      return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n    });\n  }\n  static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n    const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n    const originalLines = originalTextModel.getLinesContent();\n    const modifiedLines = modifiedTextModel.getLinesContent();\n    const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n    const identical = result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel);\n    function getLineChanges(changes) {\n      return changes.map(m => {\n        var _a;\n        return [m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [m.originalRange.startLineNumber, m.originalRange.startColumn, m.originalRange.endLineNumber, m.originalRange.endColumn, m.modifiedRange.startLineNumber, m.modifiedRange.startColumn, m.modifiedRange.endLineNumber, m.modifiedRange.endColumn])];\n      });\n    }\n    return {\n      identical,\n      quitEarly: result.hitTimeout,\n      changes: getLineChanges(result.changes),\n      moves: result.moves.map(m => [m.lineRangeMapping.original.startLineNumber, m.lineRangeMapping.original.endLineNumberExclusive, m.lineRangeMapping.modified.startLineNumber, m.lineRangeMapping.modified.endLineNumberExclusive, getLineChanges(m.changes)])\n    };\n  }\n  static _modelsAreIdentical(original, modified) {\n    const originalLineCount = original.getLineCount();\n    const modifiedLineCount = modified.getLineCount();\n    if (originalLineCount !== modifiedLineCount) {\n      return false;\n    }\n    for (let line = 1; line <= originalLineCount; line++) {\n      const originalLine = original.getLineContent(line);\n      const modifiedLine = modified.getLineContent(line);\n      if (originalLine !== modifiedLine) {\n        return false;\n      }\n    }\n    return true;\n  }\n  computeMoreMinimalEdits(modelUrl, edits, pretty) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return edits;\n      }\n      const result = [];\n      let lastEol = undefined;\n      edits = edits.slice(0).sort((a, b) => {\n        if (a.range && b.range) {\n          return Range.compareRangesUsingStarts(a.range, b.range);\n        }\n        // eol only changes should go to the end\n        const aRng = a.range ? 0 : 1;\n        const bRng = b.range ? 0 : 1;\n        return aRng - bRng;\n      });\n      // merge adjacent edits\n      let writeIndex = 0;\n      for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n        if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n          edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n          edits[writeIndex].text += edits[readIndex].text;\n        } else {\n          writeIndex++;\n          edits[writeIndex] = edits[readIndex];\n        }\n      }\n      edits.length = writeIndex + 1;\n      for (let {\n        range,\n        text,\n        eol\n      } of edits) {\n        if (typeof eol === 'number') {\n          lastEol = eol;\n        }\n        if (Range.isEmpty(range) && !text) {\n          // empty change\n          continue;\n        }\n        const original = model.getValueInRange(range);\n        text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n        if (original === text) {\n          // noop\n          continue;\n        }\n        // make sure diff won't take too long\n        if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n          result.push({\n            range,\n            text\n          });\n          continue;\n        }\n        // compute diff between original and edit.text\n        const changes = stringDiff(original, text, pretty);\n        const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n        for (const change of changes) {\n          const start = model.positionAt(editOffset + change.originalStart);\n          const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n          const newEdit = {\n            text: text.substr(change.modifiedStart, change.modifiedLength),\n            range: {\n              startLineNumber: start.lineNumber,\n              startColumn: start.column,\n              endLineNumber: end.lineNumber,\n              endColumn: end.column\n            }\n          };\n          if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n            result.push(newEdit);\n          }\n        }\n      }\n      if (typeof lastEol === 'number') {\n        result.push({\n          eol: lastEol,\n          text: '',\n          range: {\n            startLineNumber: 0,\n            startColumn: 0,\n            endLineNumber: 0,\n            endColumn: 0\n          }\n        });\n      }\n      return result;\n    });\n  }\n  // ---- END minimal edits ---------------------------------------------------------------\n  computeLinks(modelUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return null;\n      }\n      return computeLinks(model);\n    });\n  }\n  // --- BEGIN default document colors -----------------------------------------------------------\n  computeDefaultDocumentColors(modelUrl) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return null;\n      }\n      return computeDefaultDocumentColors(model);\n    });\n  }\n  textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sw = new StopWatch();\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const seen = new Set();\n      outer: for (const url of modelUrls) {\n        const model = this._getModel(url);\n        if (!model) {\n          continue;\n        }\n        for (const word of model.words(wordDefRegExp)) {\n          if (word === leadingWord || !isNaN(Number(word))) {\n            continue;\n          }\n          seen.add(word);\n          if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n            break outer;\n          }\n        }\n      }\n      return {\n        words: Array.from(seen),\n        duration: sw.elapsed()\n      };\n    });\n  }\n  // ---- END suggest --------------------------------------------------------------------------\n  //#region -- word ranges --\n  computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return Object.create(null);\n      }\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      const result = Object.create(null);\n      for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n        const words = model.getLineWords(line, wordDefRegExp);\n        for (const word of words) {\n          if (!isNaN(Number(word.word))) {\n            continue;\n          }\n          let array = result[word.word];\n          if (!array) {\n            array = [];\n            result[word.word] = array;\n          }\n          array.push({\n            startLineNumber: line,\n            startColumn: word.startColumn,\n            endLineNumber: line,\n            endColumn: word.endColumn\n          });\n        }\n      }\n      return result;\n    });\n  }\n  //#endregion\n  navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const model = this._getModel(modelUrl);\n      if (!model) {\n        return null;\n      }\n      const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n      if (range.startColumn === range.endColumn) {\n        range = {\n          startLineNumber: range.startLineNumber,\n          startColumn: range.startColumn,\n          endLineNumber: range.endLineNumber,\n          endColumn: range.endColumn + 1\n        };\n      }\n      const selectionText = model.getValueInRange(range);\n      const wordRange = model.getWordAtPosition({\n        lineNumber: range.startLineNumber,\n        column: range.startColumn\n      }, wordDefRegExp);\n      if (!wordRange) {\n        return null;\n      }\n      const word = model.getValueInRange(wordRange);\n      const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n      return result;\n    });\n  }\n  // ---- BEGIN foreign module support --------------------------------------------------------------------------\n  loadForeignModule(moduleId, createData, foreignHostMethods) {\n    const proxyMethodRequest = (method, args) => {\n      return this._host.fhr(method, args);\n    };\n    const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n    const ctx = {\n      host: foreignHost,\n      getMirrorModels: () => {\n        return this._getModels();\n      }\n    };\n    if (this._foreignModuleFactory) {\n      this._foreignModule = this._foreignModuleFactory(ctx, createData);\n      // static foreing module\n      return Promise.resolve(getAllMethodNames(this._foreignModule));\n    }\n    // ESM-comment-begin\n    // \t\treturn new Promise<any>((resolve, reject) => {\n    // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n    // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n    // \n    // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n    // \n    // \t\t\t}, reject);\n    // \t\t});\n    // ESM-comment-end\n    // ESM-uncomment-begin\n    return Promise.reject(new Error(`Unexpected usage`));\n    // ESM-uncomment-end\n  }\n  // foreign method request\n  fmr(method, args) {\n    if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n      return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n    }\n    try {\n      return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n  return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n  // Running in a web worker\n  globalThis.monaco = createMonacoBaseAPI();\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","stringDiff","URI","Position","Range","MirrorTextModel","BaseMirrorModel","ensureValidWordDefinition","getWordAtText","computeLinks","BasicInplaceReplace","createMonacoBaseAPI","StopWatch","UnicodeTextModelHighlighter","linesDiffComputers","createProxyObject","getAllMethodNames","computeDefaultDocumentColors","MirrorModel","uri","_uri","eol","_eol","getValue","getText","findMatches","regex","matches","i","_lines","length","line","offsetToAdd","offsetAt","iteratorOverMatches","matchAll","match","index","push","getLinesContent","slice","getLineCount","getLineContent","lineNumber","getWordAtPosition","position","wordDefinition","wordAtText","column","startColumn","endColumn","words","lines","wordenize","_wordenize","bind","lineText","wordRangesIdx","wordRanges","Symbol","iterator","substring","start","end","getLineWords","content","ranges","range","word","lastIndex","exec","getValueInRange","_validateRange","startLineNumber","endLineNumber","lineEnding","startLineIndex","endLineIndex","resultLines","join","_validatePosition","_ensureLineStarts","_lineStarts","getPrefixSum","positionAt","offset","Math","floor","max","out","getIndexOf","lineLength","min","remainder","isIPosition","Error","hasChanged","maxCharacter","EditorSimpleWorker","constructor","host","foreignModuleFactory","_host","_models","Object","create","_foreignModuleFactory","_foreignModule","dispose","_getModel","_getModels","all","keys","forEach","key","acceptNewModel","data","url","parse","EOL","versionId","acceptModelChanged","strURL","model","onEvents","acceptRemovedModel","computeUnicodeHighlights","options","hasMore","ambiguousCharacterCount","invisibleCharacterCount","nonBasicAsciiCharacterCount","computeDiff","originalUrl","modifiedUrl","algorithm","original","modified","originalTextModel","modifiedTextModel","diffAlgorithm","getDefault","getLegacy","originalLines","modifiedLines","identical","changes","_modelsAreIdentical","getLineChanges","map","m","_a","endLineNumberExclusive","innerChanges","originalRange","modifiedRange","quitEarly","hitTimeout","moves","lineRangeMapping","originalLineCount","modifiedLineCount","originalLine","modifiedLine","computeMoreMinimalEdits","modelUrl","edits","pretty","lastEol","undefined","sort","a","b","compareRangesUsingStarts","aRng","bRng","writeIndex","readIndex","getEndPosition","equals","getStartPosition","fromPositions","text","isEmpty","replace","_diffLimit","editOffset","lift","change","originalStart","originalLength","newEdit","substr","modifiedStart","modifiedLength","textualSuggest","modelUrls","leadingWord","wordDef","wordDefFlags","sw","wordDefRegExp","RegExp","seen","Set","outer","isNaN","Number","add","size","_suggestionsLimit","Array","from","duration","elapsed","computeWordRanges","array","navigateValueSet","up","selectionText","wordRange","INSTANCE","loadForeignModule","moduleId","createData","foreignHostMethods","proxyMethodRequest","method","args","fhr","foreignHost","ctx","getMirrorModels","fmr","importScripts","globalThis","monaco"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { stringDiff } from '../../../base/common/diff/diff.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { MirrorTextModel as BaseMirrorModel } from '../model/mirrorTextModel.js';\nimport { ensureValidWordDefinition, getWordAtText } from '../core/wordHelper.js';\nimport { computeLinks } from '../languages/linkComputer.js';\nimport { BasicInplaceReplace } from '../languages/supports/inplaceReplaceSupport.js';\nimport { createMonacoBaseAPI } from './editorBaseApi.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { UnicodeTextModelHighlighter } from './unicodeTextModelHighlighter.js';\nimport { linesDiffComputers } from '../diff/linesDiffComputers.js';\nimport { createProxyObject, getAllMethodNames } from '../../../base/common/objects.js';\nimport { computeDefaultDocumentColors } from '../languages/defaultDocumentColorsComputer.js';\n/**\n * @internal\n */\nclass MirrorModel extends BaseMirrorModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    findMatches(regex) {\n        const matches = [];\n        for (let i = 0; i < this._lines.length; i++) {\n            const line = this._lines[i];\n            const offsetToAdd = this.offsetAt(new Position(i + 1, 1));\n            const iteratorOverMatches = line.matchAll(regex);\n            for (const match of iteratorOverMatches) {\n                if (match.index || match.index === 0) {\n                    match.index = match.index + offsetToAdd;\n                }\n                matches.push(match);\n            }\n        }\n        return matches;\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nexport class EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        const all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        const model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    computeUnicodeHighlights(url, options, range) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(url);\n            if (!model) {\n                return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n            }\n            return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n        });\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const original = this._getModel(originalUrl);\n            const modified = this._getModel(modifiedUrl);\n            if (!original || !modified) {\n                return null;\n            }\n            return EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n        });\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return changes.map(m => {\n                var _a;\n                return ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [\n                        m.originalRange.startLineNumber,\n                        m.originalRange.startColumn,\n                        m.originalRange.endLineNumber,\n                        m.originalRange.endColumn,\n                        m.modifiedRange.startLineNumber,\n                        m.modifiedRange.startColumn,\n                        m.modifiedRange.endLineNumber,\n                        m.modifiedRange.endColumn,\n                    ])]);\n            });\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ])),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return edits;\n            }\n            const result = [];\n            let lastEol = undefined;\n            edits = edits.slice(0).sort((a, b) => {\n                if (a.range && b.range) {\n                    return Range.compareRangesUsingStarts(a.range, b.range);\n                }\n                // eol only changes should go to the end\n                const aRng = a.range ? 0 : 1;\n                const bRng = b.range ? 0 : 1;\n                return aRng - bRng;\n            });\n            // merge adjacent edits\n            let writeIndex = 0;\n            for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n                if (Range.getEndPosition(edits[writeIndex].range).equals(Range.getStartPosition(edits[readIndex].range))) {\n                    edits[writeIndex].range = Range.fromPositions(Range.getStartPosition(edits[writeIndex].range), Range.getEndPosition(edits[readIndex].range));\n                    edits[writeIndex].text += edits[readIndex].text;\n                }\n                else {\n                    writeIndex++;\n                    edits[writeIndex] = edits[readIndex];\n                }\n            }\n            edits.length = writeIndex + 1;\n            for (let { range, text, eol } of edits) {\n                if (typeof eol === 'number') {\n                    lastEol = eol;\n                }\n                if (Range.isEmpty(range) && !text) {\n                    // empty change\n                    continue;\n                }\n                const original = model.getValueInRange(range);\n                text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n                if (original === text) {\n                    // noop\n                    continue;\n                }\n                // make sure diff won't take too long\n                if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                    result.push({ range, text });\n                    continue;\n                }\n                // compute diff between original and edit.text\n                const changes = stringDiff(original, text, pretty);\n                const editOffset = model.offsetAt(Range.lift(range).getStartPosition());\n                for (const change of changes) {\n                    const start = model.positionAt(editOffset + change.originalStart);\n                    const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                    const newEdit = {\n                        text: text.substr(change.modifiedStart, change.modifiedLength),\n                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                    };\n                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                        result.push(newEdit);\n                    }\n                }\n            }\n            if (typeof lastEol === 'number') {\n                result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n            }\n            return result;\n        });\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    computeLinks(modelUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            return computeLinks(model);\n        });\n    }\n    // --- BEGIN default document colors -----------------------------------------------------------\n    computeDefaultDocumentColors(modelUrl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            return computeDefaultDocumentColors(model);\n        });\n    }\n    textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const sw = new StopWatch();\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const seen = new Set();\n            outer: for (const url of modelUrls) {\n                const model = this._getModel(url);\n                if (!model) {\n                    continue;\n                }\n                for (const word of model.words(wordDefRegExp)) {\n                    if (word === leadingWord || !isNaN(Number(word))) {\n                        continue;\n                    }\n                    seen.add(word);\n                    if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                        break outer;\n                    }\n                }\n            }\n            return { words: Array.from(seen), duration: sw.elapsed() };\n        });\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return Object.create(null);\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            const result = Object.create(null);\n            for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n                const words = model.getLineWords(line, wordDefRegExp);\n                for (const word of words) {\n                    if (!isNaN(Number(word.word))) {\n                        continue;\n                    }\n                    let array = result[word.word];\n                    if (!array) {\n                        array = [];\n                        result[word.word] = array;\n                    }\n                    array.push({\n                        startLineNumber: line,\n                        startColumn: word.startColumn,\n                        endLineNumber: line,\n                        endColumn: word.endColumn\n                    });\n                }\n            }\n            return result;\n        });\n    }\n    //#endregion\n    navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const model = this._getModel(modelUrl);\n            if (!model) {\n                return null;\n            }\n            const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n            if (range.startColumn === range.endColumn) {\n                range = {\n                    startLineNumber: range.startLineNumber,\n                    startColumn: range.startColumn,\n                    endLineNumber: range.endLineNumber,\n                    endColumn: range.endColumn + 1\n                };\n            }\n            const selectionText = model.getValueInRange(range);\n            const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n            if (!wordRange) {\n                return null;\n            }\n            const word = model.getValueInRange(wordRange);\n            const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n            return result;\n        });\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globalThis.monaco = createMonacoBaseAPI();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}