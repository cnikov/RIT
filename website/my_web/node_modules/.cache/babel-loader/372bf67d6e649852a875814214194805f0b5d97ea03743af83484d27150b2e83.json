{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, getDebugName, getFunctionName, transaction } from './base.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n  return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  get debugName() {\n    return this.toString();\n  }\n  get() {\n    return this.value;\n  }\n  addObserver(observer) {\n    // NO OP\n  }\n  removeObserver(observer) {\n    // NO OP\n  }\n  toString() {\n    return `Const: ${this.value}`;\n  }\n}\nexport function waitForState(observable, predicate) {\n  return new Promise(resolve => {\n    let didRun = false;\n    let shouldDispose = false;\n    const d = autorun(reader => {\n      /** @description waitForState */\n      const currentState = observable.read(reader);\n      if (predicate(currentState)) {\n        if (!didRun) {\n          shouldDispose = true;\n        } else {\n          d.dispose();\n        }\n        resolve(currentState);\n      }\n    });\n    didRun = true;\n    if (shouldDispose) {\n      d.dispose();\n    }\n  });\n}\nexport function observableFromEvent(event, getValue) {\n  return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n  constructor(event, _getValue) {\n    super();\n    this.event = event;\n    this._getValue = _getValue;\n    this.hasValue = false;\n    this.handleEvent = args => {\n      var _a;\n      const newValue = this._getValue(args);\n      const didChange = !this.hasValue || this.value !== newValue;\n      (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, {\n        oldValue: this.value,\n        newValue,\n        change: undefined,\n        didChange,\n        hadValue: this.hasValue\n      });\n      if (didChange) {\n        this.value = newValue;\n        if (this.hasValue) {\n          transaction(tx => {\n            for (const o of this.observers) {\n              tx.updateObserver(o, this);\n              o.handleChange(this, undefined);\n            }\n          }, () => {\n            const name = this.getDebugName();\n            return 'Event fired' + (name ? `: ${name}` : '');\n          });\n        }\n        this.hasValue = true;\n      }\n    };\n  }\n  getDebugName() {\n    return getFunctionName(this._getValue);\n  }\n  get debugName() {\n    const name = this.getDebugName();\n    return 'From Event' + (name ? `: ${name}` : '');\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n    this.hasValue = false;\n    this.value = undefined;\n  }\n  get() {\n    if (this.subscription) {\n      if (!this.hasValue) {\n        this.handleEvent(undefined);\n      }\n      return this.value;\n    } else {\n      // no cache, as there are no subscribers to keep it updated\n      return this._getValue(undefined);\n    }\n  }\n}\n(function (observableFromEvent) {\n  observableFromEvent.Observer = FromEventObservable;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n  return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n  constructor(debugName, event) {\n    super();\n    this.debugName = debugName;\n    this.event = event;\n    this.handleEvent = () => {\n      transaction(tx => {\n        for (const o of this.observers) {\n          tx.updateObserver(o, this);\n          o.handleChange(this, undefined);\n        }\n      }, () => this.debugName);\n    };\n  }\n  onFirstObserverAdded() {\n    this.subscription = this.event(this.handleEvent);\n  }\n  onLastObserverRemoved() {\n    this.subscription.dispose();\n    this.subscription = undefined;\n  }\n  get() {\n    // NO OP\n  }\n}\nexport function observableSignal(debugNameOrOwner) {\n  if (typeof debugNameOrOwner === 'string') {\n    return new ObservableSignal(debugNameOrOwner);\n  } else {\n    return new ObservableSignal(undefined, debugNameOrOwner);\n  }\n}\nclass ObservableSignal extends BaseObservable {\n  get debugName() {\n    var _a;\n    return (_a = getDebugName(this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n  }\n  constructor(_debugName, _owner) {\n    super();\n    this._debugName = _debugName;\n    this._owner = _owner;\n  }\n  trigger(tx, change) {\n    if (!tx) {\n      transaction(tx => {\n        this.trigger(tx, change);\n      }, () => `Trigger signal ${this.debugName}`);\n      return;\n    }\n    for (const o of this.observers) {\n      tx.updateObserver(o, this);\n      o.handleChange(this, change);\n    }\n  }\n  get() {\n    // NO OP\n  }\n}\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable) {\n  const o = new KeepAliveObserver(true);\n  observable.addObserver(o);\n  observable.reportChanges();\n  return toDisposable(() => {\n    observable.removeObserver(o);\n  });\n}\nclass KeepAliveObserver {\n  constructor(forceRecompute) {\n    this.forceRecompute = forceRecompute;\n    this.counter = 0;\n  }\n  beginUpdate(observable) {\n    this.counter++;\n  }\n  endUpdate(observable) {\n    this.counter--;\n    if (this.counter === 0 && this.forceRecompute) {\n      observable.reportChanges();\n    }\n  }\n  handlePossibleChange(observable) {\n    // NO OP\n  }\n  handleChange(observable, change) {\n    // NO OP\n  }\n}","map":{"version":3,"names":["toDisposable","autorun","BaseObservable","ConvenientObservable","getDebugName","getFunctionName","transaction","getLogger","constObservable","value","ConstObservable","constructor","debugName","toString","get","addObserver","observer","removeObserver","waitForState","observable","predicate","Promise","resolve","didRun","shouldDispose","d","reader","currentState","read","dispose","observableFromEvent","event","getValue","FromEventObservable","_getValue","hasValue","handleEvent","args","_a","newValue","didChange","handleFromEventObservableTriggered","oldValue","change","undefined","hadValue","tx","o","observers","updateObserver","handleChange","name","onFirstObserverAdded","subscription","onLastObserverRemoved","Observer","observableSignalFromEvent","FromEventObservableSignal","observableSignal","debugNameOrOwner","ObservableSignal","_debugName","_owner","trigger","recomputeInitiallyAndOnChange","KeepAliveObserver","reportChanges","forceRecompute","counter","beginUpdate","endUpdate","handlePossibleChange"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { toDisposable } from '../lifecycle.js';\nimport { autorun } from './autorun.js';\nimport { BaseObservable, ConvenientObservable, getDebugName, getFunctionName, transaction } from './base.js';\nimport { getLogger } from './logging.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function waitForState(observable, predicate) {\n    return new Promise(resolve => {\n        let didRun = false;\n        let shouldDispose = false;\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const currentState = observable.read(reader);\n            if (predicate(currentState)) {\n                if (!didRun) {\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                resolve(currentState);\n            }\n        });\n        didRun = true;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\nexport function observableFromEvent(event, getValue) {\n    return new FromEventObservable(event, getValue);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(event, _getValue) {\n        super();\n        this.event = event;\n        this._getValue = _getValue;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            var _a;\n            const newValue = this._getValue(args);\n            const didChange = !this.hasValue || this.value !== newValue;\n            (_a = getLogger()) === null || _a === void 0 ? void 0 : _a.handleFromEventObservableTriggered(this, { oldValue: this.value, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    transaction((tx) => {\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n        };\n    }\n    getDebugName() {\n        return getFunctionName(this._getValue);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            return this._getValue(undefined);\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        var _a;\n        return (_a = getDebugName(this._debugName, undefined, this._owner, this)) !== null && _a !== void 0 ? _a : 'Observable Signal';\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable) {\n    const o = new KeepAliveObserver(true);\n    observable.addObserver(o);\n    observable.reportChanges();\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\nclass KeepAliveObserver {\n    constructor(forceRecompute) {\n        this.forceRecompute = forceRecompute;\n        this.counter = 0;\n    }\n    beginUpdate(observable) {\n        this.counter++;\n    }\n    endUpdate(observable) {\n        this.counter--;\n        if (this.counter === 0 && this.forceRecompute) {\n            observable.reportChanges();\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}