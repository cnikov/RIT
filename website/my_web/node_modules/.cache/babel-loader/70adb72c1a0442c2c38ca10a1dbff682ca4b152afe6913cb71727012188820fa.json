{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nexport function createStringDataTransferItem(stringOrPromise) {\n  return {\n    asString: () => __awaiter(this, void 0, void 0, function* () {\n      return stringOrPromise;\n    }),\n    asFile: () => undefined,\n    value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined\n  };\n}\nexport function createFileDataTransferItem(fileName, uri, data) {\n  const file = {\n    id: generateUuid(),\n    name: fileName,\n    uri,\n    data\n  };\n  return {\n    asString: () => __awaiter(this, void 0, void 0, function* () {\n      return '';\n    }),\n    asFile: () => file,\n    value: undefined\n  };\n}\nexport class VSDataTransfer {\n  constructor() {\n    this._entries = new Map();\n  }\n  get size() {\n    let size = 0;\n    for (const _ of this._entries) {\n      size++;\n    }\n    return size;\n  }\n  has(mimeType) {\n    return this._entries.has(this.toKey(mimeType));\n  }\n  matches(pattern) {\n    const mimes = [...this._entries.keys()];\n    if (Iterable.some(this, ([_, item]) => item.asFile())) {\n      mimes.push('files');\n    }\n    return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n  }\n  get(mimeType) {\n    var _a;\n    return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];\n  }\n  /**\n   * Add a new entry to this data transfer.\n   *\n   * This does not replace existing entries for `mimeType`.\n   */\n  append(mimeType, value) {\n    const existing = this._entries.get(mimeType);\n    if (existing) {\n      existing.push(value);\n    } else {\n      this._entries.set(this.toKey(mimeType), [value]);\n    }\n  }\n  /**\n   * Set the entry for a given mime type.\n   *\n   * This replaces all existing entries for `mimeType`.\n   */\n  replace(mimeType, value) {\n    this._entries.set(this.toKey(mimeType), [value]);\n  }\n  /**\n   * Remove all entries for `mimeType`.\n   */\n  delete(mimeType) {\n    this._entries.delete(this.toKey(mimeType));\n  }\n  /**\n   * Iterate over all `[mime, item]` pairs in this data transfer.\n   *\n   * There may be multiple entries for each mime type.\n   */\n  *[Symbol.iterator]() {\n    for (const [mine, items] of this._entries) {\n      for (const item of items) {\n        yield [mine, item];\n      }\n    }\n  }\n  toKey(mimeType) {\n    return normalizeMimeType(mimeType);\n  }\n}\nfunction normalizeMimeType(mimeType) {\n  return mimeType.toLowerCase();\n}\nexport function matchesMimeType(pattern, mimeTypes) {\n  return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n  // Anything wildcard\n  if (normalizedPattern === '*/*') {\n    return normalizedMimeTypes.length > 0;\n  }\n  // Exact match\n  if (normalizedMimeTypes.includes(normalizedPattern)) {\n    return true;\n  }\n  // Wildcard, such as `image/*`\n  const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n  if (!wildcard) {\n    return false;\n  }\n  const [_, type, subtype] = wildcard;\n  if (subtype === '*') {\n    return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n  }\n  return false;\n}\nexport const UriList = Object.freeze({\n  // http://amundsen.com/hypermedia/urilist/\n  create: entries => {\n    return distinct(entries.map(x => x.toString())).join('\\r\\n');\n  },\n  split: str => {\n    return str.split('\\r\\n');\n  },\n  parse: str => {\n    return UriList.split(str).filter(value => !value.startsWith('#'));\n  }\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","distinct","Iterable","generateUuid","createStringDataTransferItem","stringOrPromise","asString","asFile","undefined","createFileDataTransferItem","fileName","uri","data","file","id","name","VSDataTransfer","constructor","_entries","Map","size","_","has","mimeType","toKey","matches","pattern","mimes","keys","some","item","push","matchesMimeType_normalized","normalizeMimeType","get","_a","append","existing","set","replace","delete","Symbol","iterator","mine","items","toLowerCase","matchesMimeType","mimeTypes","map","normalizedPattern","normalizedMimeTypes","length","includes","wildcard","match","type","subtype","mime","startsWith","UriList","Object","freeze","create","entries","x","toString","join","split","str","parse","filter"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/base/common/dataTransfer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { distinct } from './arrays.js';\nimport { Iterable } from './iterator.js';\nimport { generateUuid } from './uuid.js';\nexport function createStringDataTransferItem(stringOrPromise) {\n    return {\n        asString: () => __awaiter(this, void 0, void 0, function* () { return stringOrPromise; }),\n        asFile: () => undefined,\n        value: typeof stringOrPromise === 'string' ? stringOrPromise : undefined,\n    };\n}\nexport function createFileDataTransferItem(fileName, uri, data) {\n    const file = { id: generateUuid(), name: fileName, uri, data };\n    return {\n        asString: () => __awaiter(this, void 0, void 0, function* () { return ''; }),\n        asFile: () => file,\n        value: undefined,\n    };\n}\nexport class VSDataTransfer {\n    constructor() {\n        this._entries = new Map();\n    }\n    get size() {\n        let size = 0;\n        for (const _ of this._entries) {\n            size++;\n        }\n        return size;\n    }\n    has(mimeType) {\n        return this._entries.has(this.toKey(mimeType));\n    }\n    matches(pattern) {\n        const mimes = [...this._entries.keys()];\n        if (Iterable.some(this, ([_, item]) => item.asFile())) {\n            mimes.push('files');\n        }\n        return matchesMimeType_normalized(normalizeMimeType(pattern), mimes);\n    }\n    get(mimeType) {\n        var _a;\n        return (_a = this._entries.get(this.toKey(mimeType))) === null || _a === void 0 ? void 0 : _a[0];\n    }\n    /**\n     * Add a new entry to this data transfer.\n     *\n     * This does not replace existing entries for `mimeType`.\n     */\n    append(mimeType, value) {\n        const existing = this._entries.get(mimeType);\n        if (existing) {\n            existing.push(value);\n        }\n        else {\n            this._entries.set(this.toKey(mimeType), [value]);\n        }\n    }\n    /**\n     * Set the entry for a given mime type.\n     *\n     * This replaces all existing entries for `mimeType`.\n     */\n    replace(mimeType, value) {\n        this._entries.set(this.toKey(mimeType), [value]);\n    }\n    /**\n     * Remove all entries for `mimeType`.\n     */\n    delete(mimeType) {\n        this._entries.delete(this.toKey(mimeType));\n    }\n    /**\n     * Iterate over all `[mime, item]` pairs in this data transfer.\n     *\n     * There may be multiple entries for each mime type.\n     */\n    *[Symbol.iterator]() {\n        for (const [mine, items] of this._entries) {\n            for (const item of items) {\n                yield [mine, item];\n            }\n        }\n    }\n    toKey(mimeType) {\n        return normalizeMimeType(mimeType);\n    }\n}\nfunction normalizeMimeType(mimeType) {\n    return mimeType.toLowerCase();\n}\nexport function matchesMimeType(pattern, mimeTypes) {\n    return matchesMimeType_normalized(normalizeMimeType(pattern), mimeTypes.map(normalizeMimeType));\n}\nfunction matchesMimeType_normalized(normalizedPattern, normalizedMimeTypes) {\n    // Anything wildcard\n    if (normalizedPattern === '*/*') {\n        return normalizedMimeTypes.length > 0;\n    }\n    // Exact match\n    if (normalizedMimeTypes.includes(normalizedPattern)) {\n        return true;\n    }\n    // Wildcard, such as `image/*`\n    const wildcard = normalizedPattern.match(/^([a-z]+)\\/([a-z]+|\\*)$/i);\n    if (!wildcard) {\n        return false;\n    }\n    const [_, type, subtype] = wildcard;\n    if (subtype === '*') {\n        return normalizedMimeTypes.some(mime => mime.startsWith(type + '/'));\n    }\n    return false;\n}\nexport const UriList = Object.freeze({\n    // http://amundsen.com/hypermedia/urilist/\n    create: (entries) => {\n        return distinct(entries.map(x => x.toString())).join('\\r\\n');\n    },\n    split: (str) => {\n        return str.split('\\r\\n');\n    },\n    parse: (str) => {\n        return UriList.split(str).filter(value => !value.startsWith('#'));\n    }\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}