{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n  constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView) {\n    super();\n    this.languageConfigurationService = languageConfigurationService;\n    this._themeService = _themeService;\n    this._attachedView = _attachedView;\n    this.hiddenAreasModel = new HiddenAreasModel();\n    this.previousHiddenAreas = [];\n    this._editorId = editorId;\n    this._configuration = configuration;\n    this.model = model;\n    this._eventDispatcher = new ViewModelEventDispatcher();\n    this.onEvent = this._eventDispatcher.onEvent;\n    this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n    this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n    this._hasFocus = false;\n    this._viewportStart = ViewportStart.create(this.model);\n    if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n      this._lines = new ViewModelLinesFromModelAsIs(this.model);\n    } else {\n      const options = this._configuration.options;\n      const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n      const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n      const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n      const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n      const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n      this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n    }\n    this.coordinatesConverter = this._lines.createCoordinatesConverter();\n    this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n    this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n    this._register(this.viewLayout.onDidScroll(e => {\n      if (e.scrollTopChanged) {\n        this._handleVisibleLinesChanged();\n      }\n      if (e.scrollTopChanged) {\n        this._viewportStart.invalidate();\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n      this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n    }));\n    this._register(this.viewLayout.onDidContentSizeChange(e => {\n      this._eventDispatcher.emitOutgoingEvent(e);\n    }));\n    this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n    this._registerModelEvents();\n    this._register(this._configuration.onDidChangeFast(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        this._onConfigurationChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n    }));\n    this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n    }));\n    this._register(this._themeService.onDidColorThemeChange(theme => {\n      this._invalidateDecorationsColorCache();\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n    }));\n    this._updateConfigurationViewLineCountNow();\n  }\n  dispose() {\n    // First remove listeners, as disposing the lines might end up sending\n    // model decoration changed events ... and we no longer care about them ...\n    super.dispose();\n    this._decorations.dispose();\n    this._lines.dispose();\n    this._viewportStart.dispose();\n    this._eventDispatcher.dispose();\n  }\n  createLineBreaksComputer() {\n    return this._lines.createLineBreaksComputer();\n  }\n  addViewEventHandler(eventHandler) {\n    this._eventDispatcher.addViewEventHandler(eventHandler);\n  }\n  removeViewEventHandler(eventHandler) {\n    this._eventDispatcher.removeViewEventHandler(eventHandler);\n  }\n  _updateConfigurationViewLineCountNow() {\n    this._configuration.setViewLineCount(this._lines.getViewLineCount());\n  }\n  getModelVisibleRanges() {\n    const linesViewportData = this.viewLayout.getLinesViewportData();\n    const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n    const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n    return modelVisibleRanges;\n  }\n  visibleLinesStabilized() {\n    const modelVisibleRanges = this.getModelVisibleRanges();\n    this._attachedView.setVisibleLines(modelVisibleRanges, true);\n  }\n  _handleVisibleLinesChanged() {\n    const modelVisibleRanges = this.getModelVisibleRanges();\n    this._attachedView.setVisibleLines(modelVisibleRanges, false);\n  }\n  setHasFocus(hasFocus) {\n    this._hasFocus = hasFocus;\n    this._cursor.setHasFocus(hasFocus);\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n    this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n  }\n  onCompositionStart() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n  }\n  onCompositionEnd() {\n    this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n  }\n  _captureStableViewport() {\n    // We might need to restore the current start view range, so save it (if available)\n    // But only if the scroll position is not at the top of the file\n    if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n      const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n      const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n      return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n    }\n    return new StableViewport(null, 0);\n  }\n  _onConfigurationChanged(eventsCollector, e) {\n    const stableViewport = this._captureStableViewport();\n    const options = this._configuration.options;\n    const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n    const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n    const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n    const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n    const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n    if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n      eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n      this._cursor.onLineMappingChanged(eventsCollector);\n      this._decorations.onLineMappingChanged();\n      this.viewLayout.onFlushed(this.getLineCount());\n      this._updateConfigurationViewLineCount.schedule();\n    }\n    if (e.hasChanged(90 /* EditorOption.readOnly */)) {\n      // Must read again all decorations due to readOnly filtering\n      this._decorations.reset();\n      eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n    }\n    eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n    this.viewLayout.onConfigurationChanged(e);\n    stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n    if (CursorConfiguration.shouldRecreate(e)) {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n    }\n  }\n  _registerModelEvents() {\n    this._register(this.model.onDidChangeContentOrInjectedText(e => {\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        let hadOtherModelChange = false;\n        let hadModelLineChangeThatChangedLineMapping = false;\n        const changes = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes;\n        const versionId = e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null;\n        // Do a first pass to compute line mappings, and a second pass to actually interpret them\n        const lineBreaksComputer = this._lines.createLineBreaksComputer();\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 4 /* textModelEvents.RawContentChangedType.LinesInserted */:\n              {\n                for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                  const line = change.detail[lineIdx];\n                  let injectedText = change.injectedTexts[lineIdx];\n                  if (injectedText) {\n                    injectedText = injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                  }\n                  lineBreaksComputer.addRequest(line, injectedText, null);\n                }\n                break;\n              }\n            case 2 /* textModelEvents.RawContentChangedType.LineChanged */:\n              {\n                let injectedText = null;\n                if (change.injectedText) {\n                  injectedText = change.injectedText.filter(element => !element.ownerId || element.ownerId === this._editorId);\n                }\n                lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                break;\n              }\n          }\n        }\n        const lineBreaks = lineBreaksComputer.finalize();\n        const lineBreakQueue = new ArrayQueue(lineBreaks);\n        for (const change of changes) {\n          switch (change.changeType) {\n            case 1 /* textModelEvents.RawContentChangedType.Flush */:\n              {\n                this._lines.onModelFlushed();\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                this._decorations.reset();\n                this.viewLayout.onFlushed(this.getLineCount());\n                hadOtherModelChange = true;\n                break;\n              }\n            case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */:\n              {\n                const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                if (linesDeletedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 4 /* textModelEvents.RawContentChangedType.LinesInserted */:\n              {\n                const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                if (linesInsertedEvent !== null) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                hadOtherModelChange = true;\n                break;\n              }\n            case 2 /* textModelEvents.RawContentChangedType.LineChanged */:\n              {\n                const changedLineBreakData = lineBreakQueue.dequeue();\n                const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                if (linesChangedEvent) {\n                  eventsCollector.emitViewEvent(linesChangedEvent);\n                }\n                if (linesInsertedEvent) {\n                  eventsCollector.emitViewEvent(linesInsertedEvent);\n                  this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                }\n                if (linesDeletedEvent) {\n                  eventsCollector.emitViewEvent(linesDeletedEvent);\n                  this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                }\n                break;\n              }\n            case 5 /* textModelEvents.RawContentChangedType.EOLChanged */:\n              {\n                // Nothing to do. The new version will be accepted below\n                break;\n              }\n          }\n        }\n        if (versionId !== null) {\n          this._lines.acceptVersionId(versionId);\n        }\n        this.viewLayout.onHeightMaybeChanged();\n        if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n        }\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n      // Update the configuration and reset the centered view line\n      const viewportStartWasValid = this._viewportStart.isValid;\n      this._viewportStart.invalidate();\n      this._configuration.setModelLineCount(this.model.getLineCount());\n      this._updateConfigurationViewLineCountNow();\n      // Recover viewport\n      if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n        const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n        if (modelRange) {\n          const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n          const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n          this.viewLayout.setScrollPosition({\n            scrollTop: viewPositionTop + this._viewportStart.startLineDelta\n          }, 1 /* ScrollType.Immediate */);\n        }\n      }\n\n      try {\n        const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n        if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n          eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n        }\n        this._cursor.onModelContentChanged(eventsCollector, e);\n      } finally {\n        this._eventDispatcher.endEmitViewEvents();\n      }\n      this._handleVisibleLinesChanged();\n    }));\n    this._register(this.model.onDidChangeTokens(e => {\n      const viewRanges = [];\n      for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n        const modelRange = e.ranges[j];\n        const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n        const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n        viewRanges[j] = {\n          fromLineNumber: viewStartLineNumber,\n          toLineNumber: viewEndLineNumber\n        };\n      }\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n      this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeLanguageConfiguration(e => {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeLanguage(e => {\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeOptions(e => {\n      // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n        try {\n          const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n          eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n          eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n          this._cursor.onLineMappingChanged(eventsCollector);\n          this._decorations.onLineMappingChanged();\n          this.viewLayout.onFlushed(this.getLineCount());\n        } finally {\n          this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n      }\n      this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n      this._cursor.updateConfiguration(this.cursorConfig);\n      this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n    }));\n    this._register(this.model.onDidChangeDecorations(e => {\n      this._decorations.onModelDecorationsChanged();\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n      this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n    }));\n  }\n  setHiddenAreas(ranges, source) {\n    this.hiddenAreasModel.setHiddenAreas(source, ranges);\n    const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n    if (mergedRanges === this.previousHiddenAreas) {\n      return;\n    }\n    this.previousHiddenAreas = mergedRanges;\n    const stableViewport = this._captureStableViewport();\n    let lineMappingChanged = false;\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n      if (lineMappingChanged) {\n        eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n        eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        this._cursor.onLineMappingChanged(eventsCollector);\n        this._decorations.onLineMappingChanged();\n        this.viewLayout.onFlushed(this.getLineCount());\n        this.viewLayout.onHeightMaybeChanged();\n      }\n      stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n    this._updateConfigurationViewLineCount.schedule();\n    if (lineMappingChanged) {\n      this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n    }\n  }\n  getVisibleRangesPlusViewportAboveBelow() {\n    const layoutInfo = this._configuration.options.get(143 /* EditorOption.layoutInfo */);\n    const lineHeight = this._configuration.options.get(66 /* EditorOption.lineHeight */);\n    const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n    const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n    return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n  }\n  getVisibleRanges() {\n    const visibleViewRange = this.getCompletelyVisibleViewRange();\n    return this._toModelVisibleRanges(visibleViewRange);\n  }\n  getHiddenAreas() {\n    return this._lines.getHiddenAreas();\n  }\n  _toModelVisibleRanges(visibleViewRange) {\n    const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n    const hiddenAreas = this._lines.getHiddenAreas();\n    if (hiddenAreas.length === 0) {\n      return [visibleRange];\n    }\n    const result = [];\n    let resultLen = 0;\n    let startLineNumber = visibleRange.startLineNumber;\n    let startColumn = visibleRange.startColumn;\n    const endLineNumber = visibleRange.endLineNumber;\n    const endColumn = visibleRange.endColumn;\n    for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n      const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n      const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n      if (hiddenEndLineNumber < startLineNumber) {\n        continue;\n      }\n      if (hiddenStartLineNumber > endLineNumber) {\n        continue;\n      }\n      if (startLineNumber < hiddenStartLineNumber) {\n        result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n      }\n      startLineNumber = hiddenEndLineNumber + 1;\n      startColumn = 1;\n    }\n    if (startLineNumber < endLineNumber || startLineNumber === endLineNumber && startColumn < endColumn) {\n      result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    return result;\n  }\n  getCompletelyVisibleViewRange() {\n    const partialData = this.viewLayout.getLinesViewportData();\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n    const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n    const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n    const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n    return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n  }\n  saveState() {\n    const compatViewState = this.viewLayout.saveState();\n    const scrollTop = compatViewState.scrollTop;\n    const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n    const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n    const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n    return {\n      scrollLeft: compatViewState.scrollLeft,\n      firstPosition: firstPosition,\n      firstPositionDeltaTop: firstPositionDeltaTop\n    };\n  }\n  reduceRestoreState(state) {\n    if (typeof state.firstPosition === 'undefined') {\n      // This is a view state serialized by an older version\n      return this._reduceRestoreStateCompatibility(state);\n    }\n    const modelPosition = this.model.validatePosition(state.firstPosition);\n    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n    const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  _reduceRestoreStateCompatibility(state) {\n    return {\n      scrollLeft: state.scrollLeft,\n      scrollTop: state.scrollTopWithoutViewZones\n    };\n  }\n  getTabSize() {\n    return this.model.getOptions().tabSize;\n  }\n  getLineCount() {\n    return this._lines.getViewLineCount();\n  }\n  /**\n   * Gives a hint that a lot of requests are about to come in for these line numbers.\n   */\n  setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n    this._viewportStart.update(this, startLineNumber);\n  }\n  getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n    return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n  }\n  getLinesIndentGuides(startLineNumber, endLineNumber) {\n    return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n  }\n  getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n    return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n  }\n  getLineContent(lineNumber) {\n    return this._lines.getViewLineContent(lineNumber);\n  }\n  getLineLength(lineNumber) {\n    return this._lines.getViewLineLength(lineNumber);\n  }\n  getLineMinColumn(lineNumber) {\n    return this._lines.getViewLineMinColumn(lineNumber);\n  }\n  getLineMaxColumn(lineNumber) {\n    return this._lines.getViewLineMaxColumn(lineNumber);\n  }\n  getLineFirstNonWhitespaceColumn(lineNumber) {\n    const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 1;\n  }\n  getLineLastNonWhitespaceColumn(lineNumber) {\n    const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n    if (result === -1) {\n      return 0;\n    }\n    return result + 2;\n  }\n  getMinimapDecorationsInRange(range) {\n    return this._decorations.getMinimapDecorationsInRange(range);\n  }\n  getDecorationsInViewport(visibleRange) {\n    return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n  }\n  getInjectedTextAt(viewPosition) {\n    return this._lines.getInjectedTextAt(viewPosition);\n  }\n  getViewportViewLineRenderingData(visibleRange, lineNumber) {\n    const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n    const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n    return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n  }\n  getViewLineRenderingData(lineNumber) {\n    const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n    return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n  }\n  _getViewLineRenderingData(lineNumber, inlineDecorations) {\n    const mightContainRTL = this.model.mightContainRTL();\n    const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n    const tabSize = this.getTabSize();\n    const lineData = this._lines.getViewLineData(lineNumber);\n    if (lineData.inlineDecorations) {\n      inlineDecorations = [...inlineDecorations, ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))];\n    }\n    return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n  }\n  getViewLineData(lineNumber) {\n    return this._lines.getViewLineData(lineNumber);\n  }\n  getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n    const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n    return new MinimapLinesRenderingData(this.getTabSize(), result);\n  }\n  getAllOverviewRulerDecorations(theme) {\n    const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n    const result = new OverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const decorationOptions = decoration.options;\n      const opts = decorationOptions.overviewRuler;\n      if (!opts) {\n        continue;\n      }\n      const lane = opts.position;\n      if (lane === 0) {\n        continue;\n      }\n      const color = opts.getColor(theme.value);\n      const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n      const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n      result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n    }\n    return result.asArray;\n  }\n  _invalidateDecorationsColorCache() {\n    const decorations = this.model.getOverviewRulerDecorations();\n    for (const decoration of decorations) {\n      const opts1 = decoration.options.overviewRuler;\n      opts1 === null || opts1 === void 0 ? void 0 : opts1.invalidateCachedColor();\n      const opts2 = decoration.options.minimap;\n      opts2 === null || opts2 === void 0 ? void 0 : opts2.invalidateCachedColor();\n    }\n  }\n  getValueInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueInRange(modelRange, eol);\n  }\n  getValueLengthInRange(range, eol) {\n    const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n    return this.model.getValueLengthInRange(modelRange, eol);\n  }\n  modifyPosition(position, offset) {\n    const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n    return this.model.modifyPosition(modelPosition, offset);\n  }\n  deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n    const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n    if (this.model.getEOL().length === 2) {\n      // This model uses CRLF, so the delta must take that into account\n      if (deltaOffset < 0) {\n        deltaOffset -= lineFeedCnt;\n      } else {\n        deltaOffset += lineFeedCnt;\n      }\n    }\n    const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n    const resultOffset = modelAnchorOffset + deltaOffset;\n    return this.model.getPositionAt(resultOffset);\n  }\n  getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n    const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n    modelRanges = modelRanges.slice(0);\n    modelRanges.sort(Range.compareRangesUsingStarts);\n    let hasEmptyRange = false;\n    let hasNonEmptyRange = false;\n    for (const range of modelRanges) {\n      if (range.isEmpty()) {\n        hasEmptyRange = true;\n      } else {\n        hasNonEmptyRange = true;\n      }\n    }\n    if (!hasNonEmptyRange) {\n      // all ranges are empty\n      if (!emptySelectionClipboard) {\n        return '';\n      }\n      const modelLineNumbers = modelRanges.map(r => r.startLineNumber);\n      let result = '';\n      for (let i = 0; i < modelLineNumbers.length; i++) {\n        if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n          continue;\n        }\n        result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n      }\n      return result;\n    }\n    if (hasEmptyRange && emptySelectionClipboard) {\n      // mixed empty selections and non-empty selections\n      const result = [];\n      let prevModelLineNumber = 0;\n      for (const modelRange of modelRanges) {\n        const modelLineNumber = modelRange.startLineNumber;\n        if (modelRange.isEmpty()) {\n          if (modelLineNumber !== prevModelLineNumber) {\n            result.push(this.model.getLineContent(modelLineNumber));\n          }\n        } else {\n          result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n        }\n\n        prevModelLineNumber = modelLineNumber;\n      }\n      return result.length === 1 ? result[0] : result;\n    }\n    const result = [];\n    for (const modelRange of modelRanges) {\n      if (!modelRange.isEmpty()) {\n        result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n      }\n    }\n\n    return result.length === 1 ? result[0] : result;\n  }\n  getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n    const languageId = this.model.getLanguageId();\n    if (languageId === PLAINTEXT_LANGUAGE_ID) {\n      return null;\n    }\n    if (modelRanges.length !== 1) {\n      // no multiple selection support at this time\n      return null;\n    }\n    let range = modelRanges[0];\n    if (range.isEmpty()) {\n      if (!emptySelectionClipboard) {\n        // nothing to copy\n        return null;\n      }\n      const lineNumber = range.startLineNumber;\n      range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n    }\n    const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n    const colorMap = this._getColorMap();\n    const hasBadChars = /[:;\\\\\\/<>]/.test(fontInfo.fontFamily);\n    const useDefaultFontFamily = hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily;\n    let fontFamily;\n    if (useDefaultFontFamily) {\n      fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n    } else {\n      fontFamily = fontInfo.fontFamily;\n      fontFamily = fontFamily.replace(/\"/g, '\\'');\n      const hasQuotesOrIsList = /[,']/.test(fontFamily);\n      if (!hasQuotesOrIsList) {\n        const needsQuotes = /[+ ]/.test(fontFamily);\n        if (needsQuotes) {\n          fontFamily = `'${fontFamily}'`;\n        }\n      }\n      fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n    }\n    return {\n      mode: languageId,\n      html: `<div style=\"` + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};` + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};` + `font-family: ${fontFamily};` + `font-weight: ${fontInfo.fontWeight};` + `font-size: ${fontInfo.fontSize}px;` + `line-height: ${fontInfo.lineHeight}px;` + `white-space: pre;` + `\">` + this._getHTMLToCopy(range, colorMap) + '</div>'\n    };\n  }\n  _getHTMLToCopy(modelRange, colorMap) {\n    const startLineNumber = modelRange.startLineNumber;\n    const startColumn = modelRange.startColumn;\n    const endLineNumber = modelRange.endLineNumber;\n    const endColumn = modelRange.endColumn;\n    const tabSize = this.getTabSize();\n    let result = '';\n    for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n      const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n      const lineContent = lineTokens.getLineContent();\n      const startOffset = lineNumber === startLineNumber ? startColumn - 1 : 0;\n      const endOffset = lineNumber === endLineNumber ? endColumn - 1 : lineContent.length;\n      if (lineContent === '') {\n        result += '<br>';\n      } else {\n        result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n      }\n    }\n    return result;\n  }\n  _getColorMap() {\n    const colorMap = TokenizationRegistry.getColorMap();\n    const result = ['#000000'];\n    if (colorMap) {\n      for (let i = 1, len = colorMap.length; i < len; i++) {\n        result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n      }\n    }\n    return result;\n  }\n  //#region cursor operations\n  getPrimaryCursorState() {\n    return this._cursor.getPrimaryCursorState();\n  }\n  getLastAddedCursorIndex() {\n    return this._cursor.getLastAddedCursorIndex();\n  }\n  getCursorStates() {\n    return this._cursor.getCursorStates();\n  }\n  setCursorStates(source, reason, states) {\n    return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n  }\n  getCursorColumnSelectData() {\n    return this._cursor.getCursorColumnSelectData();\n  }\n  getCursorAutoClosedCharacters() {\n    return this._cursor.getAutoClosedCharacters();\n  }\n  setCursorColumnSelectData(columnSelectData) {\n    this._cursor.setCursorColumnSelectData(columnSelectData);\n  }\n  getPrevEditOperationType() {\n    return this._cursor.getPrevEditOperationType();\n  }\n  setPrevEditOperationType(type) {\n    this._cursor.setPrevEditOperationType(type);\n  }\n  getSelection() {\n    return this._cursor.getSelection();\n  }\n  getSelections() {\n    return this._cursor.getSelections();\n  }\n  getPosition() {\n    return this._cursor.getPrimaryCursorState().modelState.position;\n  }\n  setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n  }\n  saveCursorState() {\n    return this._cursor.saveState();\n  }\n  restoreCursorState(states) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n  }\n  _executeCursorEdit(callback) {\n    if (this._cursor.context.cursorConfig.readOnly) {\n      // we cannot edit when read only...\n      this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n      return;\n    }\n    this._withViewEventsCollector(callback);\n  }\n  executeEdits(source, edits, cursorStateComputer) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n  }\n  startComposition() {\n    this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n  }\n  endComposition(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n  }\n  type(text, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n  }\n  compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n  }\n  paste(text, pasteOnNewLine, multicursorText, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n  }\n  cut(source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n  }\n  executeCommand(command, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n  }\n  executeCommands(commands, source) {\n    this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n  }\n  revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n    this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n  }\n\n  revealTopMostCursor(source) {\n    const viewPosition = this._cursor.getTopMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n  }\n\n  revealBottomMostCursor(source) {\n    const viewPosition = this._cursor.getBottomMostViewPosition();\n    const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n  }\n\n  revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n    this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n  }\n  //#endregion\n  //#region viewLayout\n  changeWhitespace(callback) {\n    const hadAChange = this.viewLayout.changeWhitespace(callback);\n    if (hadAChange) {\n      this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n      this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n    }\n  }\n  //#endregion\n  _withViewEventsCollector(callback) {\n    try {\n      const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n      return callback(eventsCollector);\n    } finally {\n      this._eventDispatcher.endEmitViewEvents();\n    }\n  }\n  normalizePosition(position, affinity) {\n    return this._lines.normalizePosition(position, affinity);\n  }\n  /**\n   * Gets the column at which indentation stops at a given line.\n   * @internal\n  */\n  getLineIndentColumn(lineNumber) {\n    return this._lines.getLineIndentColumn(lineNumber);\n  }\n}\nclass ViewportStart {\n  static create(model) {\n    const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n  }\n  get viewLineNumber() {\n    return this._viewLineNumber;\n  }\n  get isValid() {\n    return this._isValid;\n  }\n  get modelTrackedRange() {\n    return this._modelTrackedRange;\n  }\n  get startLineDelta() {\n    return this._startLineDelta;\n  }\n  constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n    this._model = _model;\n    this._viewLineNumber = _viewLineNumber;\n    this._isValid = _isValid;\n    this._modelTrackedRange = _modelTrackedRange;\n    this._startLineDelta = _startLineDelta;\n  }\n  dispose() {\n    this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n  }\n\n  update(viewModel, startLineNumber) {\n    const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n    const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n    const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n    this._viewLineNumber = startLineNumber;\n    this._isValid = true;\n    this._modelTrackedRange = viewportStartLineTrackedRange;\n    this._startLineDelta = scrollTop - viewportStartLineTop;\n  }\n  invalidate() {\n    this._isValid = false;\n  }\n}\nclass OverviewRulerDecorations {\n  constructor() {\n    this._asMap = Object.create(null);\n    this.asArray = [];\n  }\n  accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n    const prevGroup = this._asMap[color];\n    if (prevGroup) {\n      const prevData = prevGroup.data;\n      const prevLane = prevData[prevData.length - 3];\n      const prevEndLineNumber = prevData[prevData.length - 1];\n      if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n        // merge into prev\n        if (endLineNumber > prevEndLineNumber) {\n          prevData[prevData.length - 1] = endLineNumber;\n        }\n        return;\n      }\n      // push\n      prevData.push(lane, startLineNumber, endLineNumber);\n    } else {\n      const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n      this._asMap[color] = group;\n      this.asArray.push(group);\n    }\n  }\n}\nclass HiddenAreasModel {\n  constructor() {\n    this.hiddenAreas = new Map();\n    this.shouldRecompute = false;\n    this.ranges = [];\n  }\n  setHiddenAreas(source, ranges) {\n    const existing = this.hiddenAreas.get(source);\n    if (existing && rangeArraysEqual(existing, ranges)) {\n      return;\n    }\n    this.hiddenAreas.set(source, ranges);\n    this.shouldRecompute = true;\n  }\n  /**\n   * The returned array is immutable.\n  */\n  getMergedRanges() {\n    if (!this.shouldRecompute) {\n      return this.ranges;\n    }\n    this.shouldRecompute = false;\n    const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n    if (rangeArraysEqual(this.ranges, newRanges)) {\n      return this.ranges;\n    }\n    this.ranges = newRanges;\n    return this.ranges;\n  }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < arr1.length && j < arr2.length) {\n    const item1 = arr1[i];\n    const item2 = arr2[j];\n    if (item1.endLineNumber < item2.startLineNumber - 1) {\n      result.push(arr1[i++]);\n    } else if (item2.endLineNumber < item1.startLineNumber - 1) {\n      result.push(arr2[j++]);\n    } else {\n      const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n      const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n      result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n      i++;\n      j++;\n    }\n  }\n  while (i < arr1.length) {\n    result.push(arr1[i++]);\n  }\n  while (j < arr2.length) {\n    result.push(arr2[j++]);\n  }\n  return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (!arr1[i].equalsRange(arr2[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n  constructor(viewportStartModelPosition, startLineDelta) {\n    this.viewportStartModelPosition = viewportStartModelPosition;\n    this.startLineDelta = startLineDelta;\n  }\n  recoverViewportStart(coordinatesConverter, viewLayout) {\n    if (!this.viewportStartModelPosition) {\n      return;\n    }\n    const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n    const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n    viewLayout.setScrollPosition({\n      scrollTop: viewPositionTop + this.startLineDelta\n    }, 1 /* ScrollType.Immediate */);\n  }\n}","map":{"version":3,"names":["ArrayQueue","RunOnceScheduler","Color","Disposable","platform","strings","EDITOR_FONT_DEFAULTS","filterValidationDecorations","CursorsController","CursorConfiguration","Position","Range","textModelEvents","TokenizationRegistry","PLAINTEXT_LANGUAGE_ID","tokenizeLineToHTML","viewEvents","ViewLayout","MinimapTokensColorTracker","MinimapLinesRenderingData","OverviewRulerDecorationsGroup","ViewLineRenderingData","ViewModelDecorations","FocusChangedEvent","HiddenAreasChangedEvent","ModelContentChangedEvent","ModelDecorationsChangedEvent","ModelLanguageChangedEvent","ModelLanguageConfigurationChangedEvent","ModelOptionsChangedEvent","ModelTokensChangedEvent","ReadOnlyEditAttemptEvent","ScrollChangedEvent","ViewModelEventDispatcher","ViewZonesChangedEvent","ViewModelLinesFromModelAsIs","ViewModelLinesFromProjectedModel","USE_IDENTITY_LINES_COLLECTION","ViewModel","constructor","editorId","configuration","model","domLineBreaksComputerFactory","monospaceLineBreaksComputerFactory","scheduleAtNextAnimationFrame","languageConfigurationService","_themeService","_attachedView","hiddenAreasModel","HiddenAreasModel","previousHiddenAreas","_editorId","_configuration","_eventDispatcher","onEvent","cursorConfig","getLanguageId","getOptions","_updateConfigurationViewLineCount","_register","_updateConfigurationViewLineCountNow","_hasFocus","_viewportStart","ViewportStart","create","isTooLargeForTokenization","_lines","options","fontInfo","get","wrappingStrategy","wrappingInfo","wrappingIndent","wordBreak","tabSize","wrappingColumn","coordinatesConverter","createCoordinatesConverter","_cursor","viewLayout","getLineCount","onDidScroll","e","scrollTopChanged","_handleVisibleLinesChanged","invalidate","emitSingleViewEvent","ViewScrollChangedEvent","emitOutgoingEvent","oldScrollWidth","oldScrollLeft","oldScrollHeight","oldScrollTop","scrollWidth","scrollLeft","scrollHeight","scrollTop","onDidContentSizeChange","_decorations","_registerModelEvents","onDidChangeFast","eventsCollector","beginEmitViewEvents","_onConfigurationChanged","endEmitViewEvents","getInstance","onDidChange","ViewTokensColorsChangedEvent","onDidColorThemeChange","theme","_invalidateDecorationsColorCache","ViewThemeChangedEvent","dispose","createLineBreaksComputer","addViewEventHandler","eventHandler","removeViewEventHandler","setViewLineCount","getViewLineCount","getModelVisibleRanges","linesViewportData","getLinesViewportData","viewVisibleRange","startLineNumber","getLineMinColumn","endLineNumber","getLineMaxColumn","modelVisibleRanges","_toModelVisibleRanges","visibleLinesStabilized","setVisibleLines","setHasFocus","hasFocus","ViewFocusChangedEvent","onCompositionStart","ViewCompositionStartEvent","onCompositionEnd","ViewCompositionEndEvent","_captureStableViewport","isValid","getCurrentScrollTop","previousViewportStartViewPosition","viewLineNumber","previousViewportStartModelPosition","convertViewPositionToModelPosition","StableViewport","startLineDelta","stableViewport","setWrappingSettings","emitViewEvent","ViewFlushedEvent","ViewLineMappingChangedEvent","ViewDecorationsChangedEvent","onLineMappingChanged","onFlushed","schedule","hasChanged","reset","ViewConfigurationChangedEvent","onConfigurationChanged","recoverViewportStart","shouldRecreate","updateConfiguration","onDidChangeContentOrInjectedText","hadOtherModelChange","hadModelLineChangeThatChangedLineMapping","changes","InternalModelContentChangeEvent","rawContentChangedEvent","versionId","lineBreaksComputer","change","changeType","lineIdx","detail","length","line","injectedText","injectedTexts","filter","element","ownerId","addRequest","lineBreaks","finalize","lineBreakQueue","onModelFlushed","linesDeletedEvent","onModelLinesDeleted","fromLineNumber","toLineNumber","onLinesDeleted","insertedLineBreaks","takeCount","linesInsertedEvent","onModelLinesInserted","onLinesInserted","changedLineBreakData","dequeue","lineMappingChanged","linesChangedEvent","onModelLineChanged","lineNumber","acceptVersionId","onHeightMaybeChanged","viewportStartWasValid","setModelLineCount","getAttachedEditorCount","modelRange","_getTrackedRange","modelTrackedRange","viewPosition","convertModelPositionToViewPosition","getStartPosition","viewPositionTop","getVerticalOffsetForLineNumber","setScrollPosition","contentChangedEvent","onModelContentChanged","onDidChangeTokens","viewRanges","j","lenJ","ranges","viewStartLineNumber","viewEndLineNumber","ViewTokensChangedEvent","onDidChangeLanguageConfiguration","ViewLanguageConfigurationEvent","onDidChangeLanguage","onDidChangeOptions","setTabSize","onDidChangeDecorations","onModelDecorationsChanged","setHiddenAreas","source","mergedRanges","getMergedRanges","getVisibleRangesPlusViewportAboveBelow","layoutInfo","lineHeight","linesAround","Math","max","round","height","partialData","startViewLineNumber","completelyVisibleStartLineNumber","endViewLineNumber","min","completelyVisibleEndLineNumber","getVisibleRanges","visibleViewRange","getCompletelyVisibleViewRange","getHiddenAreas","visibleRange","convertViewRangeToModelRange","hiddenAreas","result","resultLen","startColumn","endColumn","i","len","hiddenStartLineNumber","hiddenEndLineNumber","getCompletelyVisibleViewRangeAtScrollTop","getLinesViewportDataAtScrollTop","saveState","compatViewState","firstViewLineNumber","getLineNumberAtVerticalOffset","firstPosition","firstPositionDeltaTop","reduceRestoreState","state","_reduceRestoreStateCompatibility","modelPosition","validatePosition","scrollTopWithoutViewZones","getTabSize","setViewport","centeredLineNumber","update","getActiveIndentGuide","minLineNumber","maxLineNumber","getLinesIndentGuides","getViewLinesIndentGuides","getBracketGuidesInRangeByLine","activePosition","getViewLinesBracketGuides","getLineContent","getViewLineContent","getLineLength","getViewLineLength","getViewLineMinColumn","getViewLineMaxColumn","getLineFirstNonWhitespaceColumn","firstNonWhitespaceIndex","getLineLastNonWhitespaceColumn","lastNonWhitespaceIndex","getMinimapDecorationsInRange","range","getDecorationsInViewport","getDecorationsViewportData","decorations","getInjectedTextAt","getViewportViewLineRenderingData","allInlineDecorations","inlineDecorations","_getViewLineRenderingData","getViewLineRenderingData","getInlineDecorationsOnLine","mightContainRTL","mightContainNonBasicASCII","lineData","getViewLineData","map","d","toInlineDecoration","minColumn","maxColumn","content","continuesWithWrappedLine","tokens","startVisibleColumn","getMinimapLinesRenderingData","needed","getViewLinesData","getAllOverviewRulerDecorations","getOverviewRulerDecorations","OverviewRulerDecorations","decoration","decorationOptions","opts","overviewRuler","lane","position","color","getColor","value","getViewLineNumberOfModelPosition","accept","zIndex","asArray","opts1","invalidateCachedColor","opts2","minimap","getValueInRange","eol","getValueLengthInRange","modifyPosition","offset","deduceModelPositionRelativeToViewPosition","viewAnchorPosition","deltaOffset","lineFeedCnt","modelAnchor","getEOL","modelAnchorOffset","getOffsetAt","resultOffset","getPositionAt","getPlainTextToCopy","modelRanges","emptySelectionClipboard","forceCRLF","newLineCharacter","slice","sort","compareRangesUsingStarts","hasEmptyRange","hasNonEmptyRange","isEmpty","modelLineNumbers","r","prevModelLineNumber","modelLineNumber","push","getRichTextToCopy","languageId","colorMap","_getColorMap","hasBadChars","test","fontFamily","useDefaultFontFamily","replace","hasQuotesOrIsList","needsQuotes","mode","html","fontWeight","fontSize","_getHTMLToCopy","lineTokens","tokenization","getLineTokens","lineContent","startOffset","endOffset","inflate","isWindows","getColorMap","Format","CSS","formatHex","getPrimaryCursorState","getLastAddedCursorIndex","getCursorStates","setCursorStates","reason","states","_withViewEventsCollector","setStates","getCursorColumnSelectData","getCursorAutoClosedCharacters","getAutoClosedCharacters","setCursorColumnSelectData","columnSelectData","getPrevEditOperationType","setPrevEditOperationType","type","getSelection","getSelections","getPosition","modelState","setSelections","selections","saveCursorState","restoreCursorState","restoreState","_executeCursorEdit","callback","context","readOnly","executeEdits","edits","cursorStateComputer","startComposition","endComposition","text","compositionType","replacePrevCharCnt","replaceNextCharCnt","positionDelta","paste","pasteOnNewLine","multicursorText","cut","executeCommand","command","executeCommands","commands","revealPrimaryCursor","revealHorizontal","minimalReveal","revealPrimary","revealTopMostCursor","getTopMostViewPosition","viewRange","column","ViewRevealRangeRequestEvent","revealBottomMostCursor","getBottomMostViewPosition","revealRange","verticalType","scrollType","changeWhitespace","hadAChange","normalizePosition","affinity","getLineIndentColumn","viewportStartLineTrackedRange","_setTrackedRange","_viewLineNumber","_isValid","_modelTrackedRange","_startLineDelta","_model","viewModel","viewportStartLineTop","_asMap","Object","prevGroup","prevData","data","prevLane","prevEndLineNumber","group","Map","shouldRecompute","existing","rangeArraysEqual","set","newRanges","Array","from","values","reduce","mergeLineRangeArray","arr1","arr2","item1","item2","equalsRange","viewportStartModelPosition"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/common/viewModel/viewModelImpl.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Color } from '../../../base/common/color.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { EDITOR_FONT_DEFAULTS, filterValidationDecorations } from '../config/editorOptions.js';\nimport { CursorsController } from '../cursor/cursor.js';\nimport { CursorConfiguration } from '../cursorCommon.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport * as textModelEvents from '../textModelEvents.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { tokenizeLineToHTML } from '../languages/textToHtmlTokenizer.js';\nimport * as viewEvents from '../viewEvents.js';\nimport { ViewLayout } from '../viewLayout/viewLayout.js';\nimport { MinimapTokensColorTracker } from './minimapTokensColorTracker.js';\nimport { MinimapLinesRenderingData, OverviewRulerDecorationsGroup, ViewLineRenderingData } from '../viewModel.js';\nimport { ViewModelDecorations } from './viewModelDecorations.js';\nimport { FocusChangedEvent, HiddenAreasChangedEvent, ModelContentChangedEvent, ModelDecorationsChangedEvent, ModelLanguageChangedEvent, ModelLanguageConfigurationChangedEvent, ModelOptionsChangedEvent, ModelTokensChangedEvent, ReadOnlyEditAttemptEvent, ScrollChangedEvent, ViewModelEventDispatcher, ViewZonesChangedEvent } from '../viewModelEventDispatcher.js';\nimport { ViewModelLinesFromModelAsIs, ViewModelLinesFromProjectedModel } from './viewModelLines.js';\nconst USE_IDENTITY_LINES_COLLECTION = true;\nexport class ViewModel extends Disposable {\n    constructor(editorId, configuration, model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, scheduleAtNextAnimationFrame, languageConfigurationService, _themeService, _attachedView) {\n        super();\n        this.languageConfigurationService = languageConfigurationService;\n        this._themeService = _themeService;\n        this._attachedView = _attachedView;\n        this.hiddenAreasModel = new HiddenAreasModel();\n        this.previousHiddenAreas = [];\n        this._editorId = editorId;\n        this._configuration = configuration;\n        this.model = model;\n        this._eventDispatcher = new ViewModelEventDispatcher();\n        this.onEvent = this._eventDispatcher.onEvent;\n        this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n        this._updateConfigurationViewLineCount = this._register(new RunOnceScheduler(() => this._updateConfigurationViewLineCountNow(), 0));\n        this._hasFocus = false;\n        this._viewportStart = ViewportStart.create(this.model);\n        if (USE_IDENTITY_LINES_COLLECTION && this.model.isTooLargeForTokenization()) {\n            this._lines = new ViewModelLinesFromModelAsIs(this.model);\n        }\n        else {\n            const options = this._configuration.options;\n            const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n            const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n            const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n            const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n            const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n            this._lines = new ViewModelLinesFromProjectedModel(this._editorId, this.model, domLineBreaksComputerFactory, monospaceLineBreaksComputerFactory, fontInfo, this.model.getOptions().tabSize, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak);\n        }\n        this.coordinatesConverter = this._lines.createCoordinatesConverter();\n        this._cursor = this._register(new CursorsController(model, this, this.coordinatesConverter, this.cursorConfig));\n        this.viewLayout = this._register(new ViewLayout(this._configuration, this.getLineCount(), scheduleAtNextAnimationFrame));\n        this._register(this.viewLayout.onDidScroll((e) => {\n            if (e.scrollTopChanged) {\n                this._handleVisibleLinesChanged();\n            }\n            if (e.scrollTopChanged) {\n                this._viewportStart.invalidate();\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewScrollChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ScrollChangedEvent(e.oldScrollWidth, e.oldScrollLeft, e.oldScrollHeight, e.oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop));\n        }));\n        this._register(this.viewLayout.onDidContentSizeChange((e) => {\n            this._eventDispatcher.emitOutgoingEvent(e);\n        }));\n        this._decorations = new ViewModelDecorations(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter);\n        this._registerModelEvents();\n        this._register(this._configuration.onDidChangeFast((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                this._onConfigurationChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n        }));\n        this._register(MinimapTokensColorTracker.getInstance().onDidChange(() => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensColorsChangedEvent());\n        }));\n        this._register(this._themeService.onDidColorThemeChange((theme) => {\n            this._invalidateDecorationsColorCache();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewThemeChangedEvent(theme));\n        }));\n        this._updateConfigurationViewLineCountNow();\n    }\n    dispose() {\n        // First remove listeners, as disposing the lines might end up sending\n        // model decoration changed events ... and we no longer care about them ...\n        super.dispose();\n        this._decorations.dispose();\n        this._lines.dispose();\n        this._viewportStart.dispose();\n        this._eventDispatcher.dispose();\n    }\n    createLineBreaksComputer() {\n        return this._lines.createLineBreaksComputer();\n    }\n    addViewEventHandler(eventHandler) {\n        this._eventDispatcher.addViewEventHandler(eventHandler);\n    }\n    removeViewEventHandler(eventHandler) {\n        this._eventDispatcher.removeViewEventHandler(eventHandler);\n    }\n    _updateConfigurationViewLineCountNow() {\n        this._configuration.setViewLineCount(this._lines.getViewLineCount());\n    }\n    getModelVisibleRanges() {\n        const linesViewportData = this.viewLayout.getLinesViewportData();\n        const viewVisibleRange = new Range(linesViewportData.startLineNumber, this.getLineMinColumn(linesViewportData.startLineNumber), linesViewportData.endLineNumber, this.getLineMaxColumn(linesViewportData.endLineNumber));\n        const modelVisibleRanges = this._toModelVisibleRanges(viewVisibleRange);\n        return modelVisibleRanges;\n    }\n    visibleLinesStabilized() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, true);\n    }\n    _handleVisibleLinesChanged() {\n        const modelVisibleRanges = this.getModelVisibleRanges();\n        this._attachedView.setVisibleLines(modelVisibleRanges, false);\n    }\n    setHasFocus(hasFocus) {\n        this._hasFocus = hasFocus;\n        this._cursor.setHasFocus(hasFocus);\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewFocusChangedEvent(hasFocus));\n        this._eventDispatcher.emitOutgoingEvent(new FocusChangedEvent(!hasFocus, hasFocus));\n    }\n    onCompositionStart() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionStartEvent());\n    }\n    onCompositionEnd() {\n        this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewCompositionEndEvent());\n    }\n    _captureStableViewport() {\n        // We might need to restore the current start view range, so save it (if available)\n        // But only if the scroll position is not at the top of the file\n        if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {\n            const previousViewportStartViewPosition = new Position(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber));\n            const previousViewportStartModelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(previousViewportStartViewPosition);\n            return new StableViewport(previousViewportStartModelPosition, this._viewportStart.startLineDelta);\n        }\n        return new StableViewport(null, 0);\n    }\n    _onConfigurationChanged(eventsCollector, e) {\n        const stableViewport = this._captureStableViewport();\n        const options = this._configuration.options;\n        const fontInfo = options.get(50 /* EditorOption.fontInfo */);\n        const wrappingStrategy = options.get(137 /* EditorOption.wrappingStrategy */);\n        const wrappingInfo = options.get(144 /* EditorOption.wrappingInfo */);\n        const wrappingIndent = options.get(136 /* EditorOption.wrappingIndent */);\n        const wordBreak = options.get(128 /* EditorOption.wordBreak */);\n        if (this._lines.setWrappingSettings(fontInfo, wrappingStrategy, wrappingInfo.wrappingColumn, wrappingIndent, wordBreak)) {\n            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n            this._cursor.onLineMappingChanged(eventsCollector);\n            this._decorations.onLineMappingChanged();\n            this.viewLayout.onFlushed(this.getLineCount());\n            this._updateConfigurationViewLineCount.schedule();\n        }\n        if (e.hasChanged(90 /* EditorOption.readOnly */)) {\n            // Must read again all decorations due to readOnly filtering\n            this._decorations.reset();\n            eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n        }\n        eventsCollector.emitViewEvent(new viewEvents.ViewConfigurationChangedEvent(e));\n        this.viewLayout.onConfigurationChanged(e);\n        stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        if (CursorConfiguration.shouldRecreate(e)) {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n        }\n    }\n    _registerModelEvents() {\n        this._register(this.model.onDidChangeContentOrInjectedText((e) => {\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                let hadOtherModelChange = false;\n                let hadModelLineChangeThatChangedLineMapping = false;\n                const changes = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.changes : e.changes);\n                const versionId = (e instanceof textModelEvents.InternalModelContentChangeEvent ? e.rawContentChangedEvent.versionId : null);\n                // Do a first pass to compute line mappings, and a second pass to actually interpret them\n                const lineBreaksComputer = this._lines.createLineBreaksComputer();\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            for (let lineIdx = 0; lineIdx < change.detail.length; lineIdx++) {\n                                const line = change.detail[lineIdx];\n                                let injectedText = change.injectedTexts[lineIdx];\n                                if (injectedText) {\n                                    injectedText = injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                                }\n                                lineBreaksComputer.addRequest(line, injectedText, null);\n                            }\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            let injectedText = null;\n                            if (change.injectedText) {\n                                injectedText = change.injectedText.filter(element => (!element.ownerId || element.ownerId === this._editorId));\n                            }\n                            lineBreaksComputer.addRequest(change.detail, injectedText, null);\n                            break;\n                        }\n                    }\n                }\n                const lineBreaks = lineBreaksComputer.finalize();\n                const lineBreakQueue = new ArrayQueue(lineBreaks);\n                for (const change of changes) {\n                    switch (change.changeType) {\n                        case 1 /* textModelEvents.RawContentChangedType.Flush */: {\n                            this._lines.onModelFlushed();\n                            eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                            this._decorations.reset();\n                            this.viewLayout.onFlushed(this.getLineCount());\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 3 /* textModelEvents.RawContentChangedType.LinesDeleted */: {\n                            const linesDeletedEvent = this._lines.onModelLinesDeleted(versionId, change.fromLineNumber, change.toLineNumber);\n                            if (linesDeletedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 4 /* textModelEvents.RawContentChangedType.LinesInserted */: {\n                            const insertedLineBreaks = lineBreakQueue.takeCount(change.detail.length);\n                            const linesInsertedEvent = this._lines.onModelLinesInserted(versionId, change.fromLineNumber, change.toLineNumber, insertedLineBreaks);\n                            if (linesInsertedEvent !== null) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            hadOtherModelChange = true;\n                            break;\n                        }\n                        case 2 /* textModelEvents.RawContentChangedType.LineChanged */: {\n                            const changedLineBreakData = lineBreakQueue.dequeue();\n                            const [lineMappingChanged, linesChangedEvent, linesInsertedEvent, linesDeletedEvent] = this._lines.onModelLineChanged(versionId, change.lineNumber, changedLineBreakData);\n                            hadModelLineChangeThatChangedLineMapping = lineMappingChanged;\n                            if (linesChangedEvent) {\n                                eventsCollector.emitViewEvent(linesChangedEvent);\n                            }\n                            if (linesInsertedEvent) {\n                                eventsCollector.emitViewEvent(linesInsertedEvent);\n                                this.viewLayout.onLinesInserted(linesInsertedEvent.fromLineNumber, linesInsertedEvent.toLineNumber);\n                            }\n                            if (linesDeletedEvent) {\n                                eventsCollector.emitViewEvent(linesDeletedEvent);\n                                this.viewLayout.onLinesDeleted(linesDeletedEvent.fromLineNumber, linesDeletedEvent.toLineNumber);\n                            }\n                            break;\n                        }\n                        case 5 /* textModelEvents.RawContentChangedType.EOLChanged */: {\n                            // Nothing to do. The new version will be accepted below\n                            break;\n                        }\n                    }\n                }\n                if (versionId !== null) {\n                    this._lines.acceptVersionId(versionId);\n                }\n                this.viewLayout.onHeightMaybeChanged();\n                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                }\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            // Update the configuration and reset the centered view line\n            const viewportStartWasValid = this._viewportStart.isValid;\n            this._viewportStart.invalidate();\n            this._configuration.setModelLineCount(this.model.getLineCount());\n            this._updateConfigurationViewLineCountNow();\n            // Recover viewport\n            if (!this._hasFocus && this.model.getAttachedEditorCount() >= 2 && viewportStartWasValid) {\n                const modelRange = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);\n                if (modelRange) {\n                    const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelRange.getStartPosition());\n                    const viewPositionTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n                    this.viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this._viewportStart.startLineDelta }, 1 /* ScrollType.Immediate */);\n                }\n            }\n            try {\n                const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                if (e instanceof textModelEvents.InternalModelContentChangeEvent) {\n                    eventsCollector.emitOutgoingEvent(new ModelContentChangedEvent(e.contentChangedEvent));\n                }\n                this._cursor.onModelContentChanged(eventsCollector, e);\n            }\n            finally {\n                this._eventDispatcher.endEmitViewEvents();\n            }\n            this._handleVisibleLinesChanged();\n        }));\n        this._register(this.model.onDidChangeTokens((e) => {\n            const viewRanges = [];\n            for (let j = 0, lenJ = e.ranges.length; j < lenJ; j++) {\n                const modelRange = e.ranges[j];\n                const viewStartLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.fromLineNumber, 1)).lineNumber;\n                const viewEndLineNumber = this.coordinatesConverter.convertModelPositionToViewPosition(new Position(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber))).lineNumber;\n                viewRanges[j] = {\n                    fromLineNumber: viewStartLineNumber,\n                    toLineNumber: viewEndLineNumber\n                };\n            }\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewTokensChangedEvent(viewRanges));\n            this._eventDispatcher.emitOutgoingEvent(new ModelTokensChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguageConfiguration((e) => {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewLanguageConfigurationEvent());\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageConfigurationChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeLanguage((e) => {\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelLanguageChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeOptions((e) => {\n            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here\n            if (this._lines.setTabSize(this.model.getOptions().tabSize)) {\n                try {\n                    const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n                    eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                    eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                    this._cursor.onLineMappingChanged(eventsCollector);\n                    this._decorations.onLineMappingChanged();\n                    this.viewLayout.onFlushed(this.getLineCount());\n                }\n                finally {\n                    this._eventDispatcher.endEmitViewEvents();\n                }\n                this._updateConfigurationViewLineCount.schedule();\n            }\n            this.cursorConfig = new CursorConfiguration(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService);\n            this._cursor.updateConfiguration(this.cursorConfig);\n            this._eventDispatcher.emitOutgoingEvent(new ModelOptionsChangedEvent(e));\n        }));\n        this._register(this.model.onDidChangeDecorations((e) => {\n            this._decorations.onModelDecorationsChanged();\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewDecorationsChangedEvent(e));\n            this._eventDispatcher.emitOutgoingEvent(new ModelDecorationsChangedEvent(e));\n        }));\n    }\n    setHiddenAreas(ranges, source) {\n        this.hiddenAreasModel.setHiddenAreas(source, ranges);\n        const mergedRanges = this.hiddenAreasModel.getMergedRanges();\n        if (mergedRanges === this.previousHiddenAreas) {\n            return;\n        }\n        this.previousHiddenAreas = mergedRanges;\n        const stableViewport = this._captureStableViewport();\n        let lineMappingChanged = false;\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            lineMappingChanged = this._lines.setHiddenAreas(mergedRanges);\n            if (lineMappingChanged) {\n                eventsCollector.emitViewEvent(new viewEvents.ViewFlushedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewLineMappingChangedEvent());\n                eventsCollector.emitViewEvent(new viewEvents.ViewDecorationsChangedEvent(null));\n                this._cursor.onLineMappingChanged(eventsCollector);\n                this._decorations.onLineMappingChanged();\n                this.viewLayout.onFlushed(this.getLineCount());\n                this.viewLayout.onHeightMaybeChanged();\n            }\n            stableViewport.recoverViewportStart(this.coordinatesConverter, this.viewLayout);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n        this._updateConfigurationViewLineCount.schedule();\n        if (lineMappingChanged) {\n            this._eventDispatcher.emitOutgoingEvent(new HiddenAreasChangedEvent());\n        }\n    }\n    getVisibleRangesPlusViewportAboveBelow() {\n        const layoutInfo = this._configuration.options.get(143 /* EditorOption.layoutInfo */);\n        const lineHeight = this._configuration.options.get(66 /* EditorOption.lineHeight */);\n        const linesAround = Math.max(20, Math.round(layoutInfo.height / lineHeight));\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = Math.max(1, partialData.completelyVisibleStartLineNumber - linesAround);\n        const endViewLineNumber = Math.min(this.getLineCount(), partialData.completelyVisibleEndLineNumber + linesAround);\n        return this._toModelVisibleRanges(new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber)));\n    }\n    getVisibleRanges() {\n        const visibleViewRange = this.getCompletelyVisibleViewRange();\n        return this._toModelVisibleRanges(visibleViewRange);\n    }\n    getHiddenAreas() {\n        return this._lines.getHiddenAreas();\n    }\n    _toModelVisibleRanges(visibleViewRange) {\n        const visibleRange = this.coordinatesConverter.convertViewRangeToModelRange(visibleViewRange);\n        const hiddenAreas = this._lines.getHiddenAreas();\n        if (hiddenAreas.length === 0) {\n            return [visibleRange];\n        }\n        const result = [];\n        let resultLen = 0;\n        let startLineNumber = visibleRange.startLineNumber;\n        let startColumn = visibleRange.startColumn;\n        const endLineNumber = visibleRange.endLineNumber;\n        const endColumn = visibleRange.endColumn;\n        for (let i = 0, len = hiddenAreas.length; i < len; i++) {\n            const hiddenStartLineNumber = hiddenAreas[i].startLineNumber;\n            const hiddenEndLineNumber = hiddenAreas[i].endLineNumber;\n            if (hiddenEndLineNumber < startLineNumber) {\n                continue;\n            }\n            if (hiddenStartLineNumber > endLineNumber) {\n                continue;\n            }\n            if (startLineNumber < hiddenStartLineNumber) {\n                result[resultLen++] = new Range(startLineNumber, startColumn, hiddenStartLineNumber - 1, this.model.getLineMaxColumn(hiddenStartLineNumber - 1));\n            }\n            startLineNumber = hiddenEndLineNumber + 1;\n            startColumn = 1;\n        }\n        if (startLineNumber < endLineNumber || (startLineNumber === endLineNumber && startColumn < endColumn)) {\n            result[resultLen++] = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return result;\n    }\n    getCompletelyVisibleViewRange() {\n        const partialData = this.viewLayout.getLinesViewportData();\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    getCompletelyVisibleViewRangeAtScrollTop(scrollTop) {\n        const partialData = this.viewLayout.getLinesViewportDataAtScrollTop(scrollTop);\n        const startViewLineNumber = partialData.completelyVisibleStartLineNumber;\n        const endViewLineNumber = partialData.completelyVisibleEndLineNumber;\n        return new Range(startViewLineNumber, this.getLineMinColumn(startViewLineNumber), endViewLineNumber, this.getLineMaxColumn(endViewLineNumber));\n    }\n    saveState() {\n        const compatViewState = this.viewLayout.saveState();\n        const scrollTop = compatViewState.scrollTop;\n        const firstViewLineNumber = this.viewLayout.getLineNumberAtVerticalOffset(scrollTop);\n        const firstPosition = this.coordinatesConverter.convertViewPositionToModelPosition(new Position(firstViewLineNumber, this.getLineMinColumn(firstViewLineNumber)));\n        const firstPositionDeltaTop = this.viewLayout.getVerticalOffsetForLineNumber(firstViewLineNumber) - scrollTop;\n        return {\n            scrollLeft: compatViewState.scrollLeft,\n            firstPosition: firstPosition,\n            firstPositionDeltaTop: firstPositionDeltaTop\n        };\n    }\n    reduceRestoreState(state) {\n        if (typeof state.firstPosition === 'undefined') {\n            // This is a view state serialized by an older version\n            return this._reduceRestoreStateCompatibility(state);\n        }\n        const modelPosition = this.model.validatePosition(state.firstPosition);\n        const viewPosition = this.coordinatesConverter.convertModelPositionToViewPosition(modelPosition);\n        const scrollTop = this.viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber) - state.firstPositionDeltaTop;\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    _reduceRestoreStateCompatibility(state) {\n        return {\n            scrollLeft: state.scrollLeft,\n            scrollTop: state.scrollTopWithoutViewZones\n        };\n    }\n    getTabSize() {\n        return this.model.getOptions().tabSize;\n    }\n    getLineCount() {\n        return this._lines.getViewLineCount();\n    }\n    /**\n     * Gives a hint that a lot of requests are about to come in for these line numbers.\n     */\n    setViewport(startLineNumber, endLineNumber, centeredLineNumber) {\n        this._viewportStart.update(this, startLineNumber);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        return this._lines.getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        return this._lines.getViewLinesIndentGuides(startLineNumber, endLineNumber);\n    }\n    getBracketGuidesInRangeByLine(startLineNumber, endLineNumber, activePosition, options) {\n        return this._lines.getViewLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options);\n    }\n    getLineContent(lineNumber) {\n        return this._lines.getViewLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        return this._lines.getViewLineLength(lineNumber);\n    }\n    getLineMinColumn(lineNumber) {\n        return this._lines.getViewLineMinColumn(lineNumber);\n    }\n    getLineMaxColumn(lineNumber) {\n        return this._lines.getViewLineMaxColumn(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    getMinimapDecorationsInRange(range) {\n        return this._decorations.getMinimapDecorationsInRange(range);\n    }\n    getDecorationsInViewport(visibleRange) {\n        return this._decorations.getDecorationsViewportData(visibleRange).decorations;\n    }\n    getInjectedTextAt(viewPosition) {\n        return this._lines.getInjectedTextAt(viewPosition);\n    }\n    getViewportViewLineRenderingData(visibleRange, lineNumber) {\n        const allInlineDecorations = this._decorations.getDecorationsViewportData(visibleRange).inlineDecorations;\n        const inlineDecorations = allInlineDecorations[lineNumber - visibleRange.startLineNumber];\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    getViewLineRenderingData(lineNumber) {\n        const inlineDecorations = this._decorations.getInlineDecorationsOnLine(lineNumber);\n        return this._getViewLineRenderingData(lineNumber, inlineDecorations);\n    }\n    _getViewLineRenderingData(lineNumber, inlineDecorations) {\n        const mightContainRTL = this.model.mightContainRTL();\n        const mightContainNonBasicASCII = this.model.mightContainNonBasicASCII();\n        const tabSize = this.getTabSize();\n        const lineData = this._lines.getViewLineData(lineNumber);\n        if (lineData.inlineDecorations) {\n            inlineDecorations = [\n                ...inlineDecorations,\n                ...lineData.inlineDecorations.map(d => d.toInlineDecoration(lineNumber))\n            ];\n        }\n        return new ViewLineRenderingData(lineData.minColumn, lineData.maxColumn, lineData.content, lineData.continuesWithWrappedLine, mightContainRTL, mightContainNonBasicASCII, lineData.tokens, inlineDecorations, tabSize, lineData.startVisibleColumn);\n    }\n    getViewLineData(lineNumber) {\n        return this._lines.getViewLineData(lineNumber);\n    }\n    getMinimapLinesRenderingData(startLineNumber, endLineNumber, needed) {\n        const result = this._lines.getViewLinesData(startLineNumber, endLineNumber, needed);\n        return new MinimapLinesRenderingData(this.getTabSize(), result);\n    }\n    getAllOverviewRulerDecorations(theme) {\n        const decorations = this.model.getOverviewRulerDecorations(this._editorId, filterValidationDecorations(this._configuration.options));\n        const result = new OverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const decorationOptions = decoration.options;\n            const opts = decorationOptions.overviewRuler;\n            if (!opts) {\n                continue;\n            }\n            const lane = opts.position;\n            if (lane === 0) {\n                continue;\n            }\n            const color = opts.getColor(theme.value);\n            const viewStartLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.startLineNumber, decoration.range.startColumn);\n            const viewEndLineNumber = this.coordinatesConverter.getViewLineNumberOfModelPosition(decoration.range.endLineNumber, decoration.range.endColumn);\n            result.accept(color, decorationOptions.zIndex, viewStartLineNumber, viewEndLineNumber, lane);\n        }\n        return result.asArray;\n    }\n    _invalidateDecorationsColorCache() {\n        const decorations = this.model.getOverviewRulerDecorations();\n        for (const decoration of decorations) {\n            const opts1 = decoration.options.overviewRuler;\n            opts1 === null || opts1 === void 0 ? void 0 : opts1.invalidateCachedColor();\n            const opts2 = decoration.options.minimap;\n            opts2 === null || opts2 === void 0 ? void 0 : opts2.invalidateCachedColor();\n        }\n    }\n    getValueInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueInRange(modelRange, eol);\n    }\n    getValueLengthInRange(range, eol) {\n        const modelRange = this.coordinatesConverter.convertViewRangeToModelRange(range);\n        return this.model.getValueLengthInRange(modelRange, eol);\n    }\n    modifyPosition(position, offset) {\n        const modelPosition = this.coordinatesConverter.convertViewPositionToModelPosition(position);\n        return this.model.modifyPosition(modelPosition, offset);\n    }\n    deduceModelPositionRelativeToViewPosition(viewAnchorPosition, deltaOffset, lineFeedCnt) {\n        const modelAnchor = this.coordinatesConverter.convertViewPositionToModelPosition(viewAnchorPosition);\n        if (this.model.getEOL().length === 2) {\n            // This model uses CRLF, so the delta must take that into account\n            if (deltaOffset < 0) {\n                deltaOffset -= lineFeedCnt;\n            }\n            else {\n                deltaOffset += lineFeedCnt;\n            }\n        }\n        const modelAnchorOffset = this.model.getOffsetAt(modelAnchor);\n        const resultOffset = modelAnchorOffset + deltaOffset;\n        return this.model.getPositionAt(resultOffset);\n    }\n    getPlainTextToCopy(modelRanges, emptySelectionClipboard, forceCRLF) {\n        const newLineCharacter = forceCRLF ? '\\r\\n' : this.model.getEOL();\n        modelRanges = modelRanges.slice(0);\n        modelRanges.sort(Range.compareRangesUsingStarts);\n        let hasEmptyRange = false;\n        let hasNonEmptyRange = false;\n        for (const range of modelRanges) {\n            if (range.isEmpty()) {\n                hasEmptyRange = true;\n            }\n            else {\n                hasNonEmptyRange = true;\n            }\n        }\n        if (!hasNonEmptyRange) {\n            // all ranges are empty\n            if (!emptySelectionClipboard) {\n                return '';\n            }\n            const modelLineNumbers = modelRanges.map((r) => r.startLineNumber);\n            let result = '';\n            for (let i = 0; i < modelLineNumbers.length; i++) {\n                if (i > 0 && modelLineNumbers[i - 1] === modelLineNumbers[i]) {\n                    continue;\n                }\n                result += this.model.getLineContent(modelLineNumbers[i]) + newLineCharacter;\n            }\n            return result;\n        }\n        if (hasEmptyRange && emptySelectionClipboard) {\n            // mixed empty selections and non-empty selections\n            const result = [];\n            let prevModelLineNumber = 0;\n            for (const modelRange of modelRanges) {\n                const modelLineNumber = modelRange.startLineNumber;\n                if (modelRange.isEmpty()) {\n                    if (modelLineNumber !== prevModelLineNumber) {\n                        result.push(this.model.getLineContent(modelLineNumber));\n                    }\n                }\n                else {\n                    result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n                }\n                prevModelLineNumber = modelLineNumber;\n            }\n            return result.length === 1 ? result[0] : result;\n        }\n        const result = [];\n        for (const modelRange of modelRanges) {\n            if (!modelRange.isEmpty()) {\n                result.push(this.model.getValueInRange(modelRange, forceCRLF ? 2 /* EndOfLinePreference.CRLF */ : 0 /* EndOfLinePreference.TextDefined */));\n            }\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    getRichTextToCopy(modelRanges, emptySelectionClipboard) {\n        const languageId = this.model.getLanguageId();\n        if (languageId === PLAINTEXT_LANGUAGE_ID) {\n            return null;\n        }\n        if (modelRanges.length !== 1) {\n            // no multiple selection support at this time\n            return null;\n        }\n        let range = modelRanges[0];\n        if (range.isEmpty()) {\n            if (!emptySelectionClipboard) {\n                // nothing to copy\n                return null;\n            }\n            const lineNumber = range.startLineNumber;\n            range = new Range(lineNumber, this.model.getLineMinColumn(lineNumber), lineNumber, this.model.getLineMaxColumn(lineNumber));\n        }\n        const fontInfo = this._configuration.options.get(50 /* EditorOption.fontInfo */);\n        const colorMap = this._getColorMap();\n        const hasBadChars = (/[:;\\\\\\/<>]/.test(fontInfo.fontFamily));\n        const useDefaultFontFamily = (hasBadChars || fontInfo.fontFamily === EDITOR_FONT_DEFAULTS.fontFamily);\n        let fontFamily;\n        if (useDefaultFontFamily) {\n            fontFamily = EDITOR_FONT_DEFAULTS.fontFamily;\n        }\n        else {\n            fontFamily = fontInfo.fontFamily;\n            fontFamily = fontFamily.replace(/\"/g, '\\'');\n            const hasQuotesOrIsList = /[,']/.test(fontFamily);\n            if (!hasQuotesOrIsList) {\n                const needsQuotes = /[+ ]/.test(fontFamily);\n                if (needsQuotes) {\n                    fontFamily = `'${fontFamily}'`;\n                }\n            }\n            fontFamily = `${fontFamily}, ${EDITOR_FONT_DEFAULTS.fontFamily}`;\n        }\n        return {\n            mode: languageId,\n            html: (`<div style=\"`\n                + `color: ${colorMap[1 /* ColorId.DefaultForeground */]};`\n                + `background-color: ${colorMap[2 /* ColorId.DefaultBackground */]};`\n                + `font-family: ${fontFamily};`\n                + `font-weight: ${fontInfo.fontWeight};`\n                + `font-size: ${fontInfo.fontSize}px;`\n                + `line-height: ${fontInfo.lineHeight}px;`\n                + `white-space: pre;`\n                + `\">`\n                + this._getHTMLToCopy(range, colorMap)\n                + '</div>')\n        };\n    }\n    _getHTMLToCopy(modelRange, colorMap) {\n        const startLineNumber = modelRange.startLineNumber;\n        const startColumn = modelRange.startColumn;\n        const endLineNumber = modelRange.endLineNumber;\n        const endColumn = modelRange.endColumn;\n        const tabSize = this.getTabSize();\n        let result = '';\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const lineTokens = this.model.tokenization.getLineTokens(lineNumber);\n            const lineContent = lineTokens.getLineContent();\n            const startOffset = (lineNumber === startLineNumber ? startColumn - 1 : 0);\n            const endOffset = (lineNumber === endLineNumber ? endColumn - 1 : lineContent.length);\n            if (lineContent === '') {\n                result += '<br>';\n            }\n            else {\n                result += tokenizeLineToHTML(lineContent, lineTokens.inflate(), colorMap, startOffset, endOffset, tabSize, platform.isWindows);\n            }\n        }\n        return result;\n    }\n    _getColorMap() {\n        const colorMap = TokenizationRegistry.getColorMap();\n        const result = ['#000000'];\n        if (colorMap) {\n            for (let i = 1, len = colorMap.length; i < len; i++) {\n                result[i] = Color.Format.CSS.formatHex(colorMap[i]);\n            }\n        }\n        return result;\n    }\n    //#region cursor operations\n    getPrimaryCursorState() {\n        return this._cursor.getPrimaryCursorState();\n    }\n    getLastAddedCursorIndex() {\n        return this._cursor.getLastAddedCursorIndex();\n    }\n    getCursorStates() {\n        return this._cursor.getCursorStates();\n    }\n    setCursorStates(source, reason, states) {\n        return this._withViewEventsCollector(eventsCollector => this._cursor.setStates(eventsCollector, source, reason, states));\n    }\n    getCursorColumnSelectData() {\n        return this._cursor.getCursorColumnSelectData();\n    }\n    getCursorAutoClosedCharacters() {\n        return this._cursor.getAutoClosedCharacters();\n    }\n    setCursorColumnSelectData(columnSelectData) {\n        this._cursor.setCursorColumnSelectData(columnSelectData);\n    }\n    getPrevEditOperationType() {\n        return this._cursor.getPrevEditOperationType();\n    }\n    setPrevEditOperationType(type) {\n        this._cursor.setPrevEditOperationType(type);\n    }\n    getSelection() {\n        return this._cursor.getSelection();\n    }\n    getSelections() {\n        return this._cursor.getSelections();\n    }\n    getPosition() {\n        return this._cursor.getPrimaryCursorState().modelState.position;\n    }\n    setSelections(source, selections, reason = 0 /* CursorChangeReason.NotSet */) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.setSelections(eventsCollector, source, selections, reason));\n    }\n    saveCursorState() {\n        return this._cursor.saveState();\n    }\n    restoreCursorState(states) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.restoreState(eventsCollector, states));\n    }\n    _executeCursorEdit(callback) {\n        if (this._cursor.context.cursorConfig.readOnly) {\n            // we cannot edit when read only...\n            this._eventDispatcher.emitOutgoingEvent(new ReadOnlyEditAttemptEvent());\n            return;\n        }\n        this._withViewEventsCollector(callback);\n    }\n    executeEdits(source, edits, cursorStateComputer) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeEdits(eventsCollector, source, edits, cursorStateComputer));\n    }\n    startComposition() {\n        this._executeCursorEdit(eventsCollector => this._cursor.startComposition(eventsCollector));\n    }\n    endComposition(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.endComposition(eventsCollector, source));\n    }\n    type(text, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.type(eventsCollector, text, source));\n    }\n    compositionType(text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.compositionType(eventsCollector, text, replacePrevCharCnt, replaceNextCharCnt, positionDelta, source));\n    }\n    paste(text, pasteOnNewLine, multicursorText, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.paste(eventsCollector, text, pasteOnNewLine, multicursorText, source));\n    }\n    cut(source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.cut(eventsCollector, source));\n    }\n    executeCommand(command, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommand(eventsCollector, command, source));\n    }\n    executeCommands(commands, source) {\n        this._executeCursorEdit(eventsCollector => this._cursor.executeCommands(eventsCollector, commands, source));\n    }\n    revealPrimaryCursor(source, revealHorizontal, minimalReveal = false) {\n        this._withViewEventsCollector(eventsCollector => this._cursor.revealPrimary(eventsCollector, source, minimalReveal, 0 /* viewEvents.VerticalRevealType.Simple */, revealHorizontal, 0 /* ScrollType.Smooth */));\n    }\n    revealTopMostCursor(source) {\n        const viewPosition = this._cursor.getTopMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealBottomMostCursor(source) {\n        const viewPosition = this._cursor.getBottomMostViewPosition();\n        const viewRange = new Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, 0 /* viewEvents.VerticalRevealType.Simple */, true, 0 /* ScrollType.Smooth */)));\n    }\n    revealRange(source, revealHorizontal, viewRange, verticalType, scrollType) {\n        this._withViewEventsCollector(eventsCollector => eventsCollector.emitViewEvent(new viewEvents.ViewRevealRangeRequestEvent(source, false, viewRange, null, verticalType, revealHorizontal, scrollType)));\n    }\n    //#endregion\n    //#region viewLayout\n    changeWhitespace(callback) {\n        const hadAChange = this.viewLayout.changeWhitespace(callback);\n        if (hadAChange) {\n            this._eventDispatcher.emitSingleViewEvent(new viewEvents.ViewZonesChangedEvent());\n            this._eventDispatcher.emitOutgoingEvent(new ViewZonesChangedEvent());\n        }\n    }\n    //#endregion\n    _withViewEventsCollector(callback) {\n        try {\n            const eventsCollector = this._eventDispatcher.beginEmitViewEvents();\n            return callback(eventsCollector);\n        }\n        finally {\n            this._eventDispatcher.endEmitViewEvents();\n        }\n    }\n    normalizePosition(position, affinity) {\n        return this._lines.normalizePosition(position, affinity);\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        return this._lines.getLineIndentColumn(lineNumber);\n    }\n}\nclass ViewportStart {\n    static create(model) {\n        const viewportStartLineTrackedRange = model._setTrackedRange(null, new Range(1, 1, 1, 1), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        return new ViewportStart(model, 1, false, viewportStartLineTrackedRange, 0);\n    }\n    get viewLineNumber() {\n        return this._viewLineNumber;\n    }\n    get isValid() {\n        return this._isValid;\n    }\n    get modelTrackedRange() {\n        return this._modelTrackedRange;\n    }\n    get startLineDelta() {\n        return this._startLineDelta;\n    }\n    constructor(_model, _viewLineNumber, _isValid, _modelTrackedRange, _startLineDelta) {\n        this._model = _model;\n        this._viewLineNumber = _viewLineNumber;\n        this._isValid = _isValid;\n        this._modelTrackedRange = _modelTrackedRange;\n        this._startLineDelta = _startLineDelta;\n    }\n    dispose() {\n        this._model._setTrackedRange(this._modelTrackedRange, null, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n    }\n    update(viewModel, startLineNumber) {\n        const position = viewModel.coordinatesConverter.convertViewPositionToModelPosition(new Position(startLineNumber, viewModel.getLineMinColumn(startLineNumber)));\n        const viewportStartLineTrackedRange = viewModel.model._setTrackedRange(this._modelTrackedRange, new Range(position.lineNumber, position.column, position.lineNumber, position.column), 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        const viewportStartLineTop = viewModel.viewLayout.getVerticalOffsetForLineNumber(startLineNumber);\n        const scrollTop = viewModel.viewLayout.getCurrentScrollTop();\n        this._viewLineNumber = startLineNumber;\n        this._isValid = true;\n        this._modelTrackedRange = viewportStartLineTrackedRange;\n        this._startLineDelta = scrollTop - viewportStartLineTop;\n    }\n    invalidate() {\n        this._isValid = false;\n    }\n}\nclass OverviewRulerDecorations {\n    constructor() {\n        this._asMap = Object.create(null);\n        this.asArray = [];\n    }\n    accept(color, zIndex, startLineNumber, endLineNumber, lane) {\n        const prevGroup = this._asMap[color];\n        if (prevGroup) {\n            const prevData = prevGroup.data;\n            const prevLane = prevData[prevData.length - 3];\n            const prevEndLineNumber = prevData[prevData.length - 1];\n            if (prevLane === lane && prevEndLineNumber + 1 >= startLineNumber) {\n                // merge into prev\n                if (endLineNumber > prevEndLineNumber) {\n                    prevData[prevData.length - 1] = endLineNumber;\n                }\n                return;\n            }\n            // push\n            prevData.push(lane, startLineNumber, endLineNumber);\n        }\n        else {\n            const group = new OverviewRulerDecorationsGroup(color, zIndex, [lane, startLineNumber, endLineNumber]);\n            this._asMap[color] = group;\n            this.asArray.push(group);\n        }\n    }\n}\nclass HiddenAreasModel {\n    constructor() {\n        this.hiddenAreas = new Map();\n        this.shouldRecompute = false;\n        this.ranges = [];\n    }\n    setHiddenAreas(source, ranges) {\n        const existing = this.hiddenAreas.get(source);\n        if (existing && rangeArraysEqual(existing, ranges)) {\n            return;\n        }\n        this.hiddenAreas.set(source, ranges);\n        this.shouldRecompute = true;\n    }\n    /**\n     * The returned array is immutable.\n    */\n    getMergedRanges() {\n        if (!this.shouldRecompute) {\n            return this.ranges;\n        }\n        this.shouldRecompute = false;\n        const newRanges = Array.from(this.hiddenAreas.values()).reduce((r, hiddenAreas) => mergeLineRangeArray(r, hiddenAreas), []);\n        if (rangeArraysEqual(this.ranges, newRanges)) {\n            return this.ranges;\n        }\n        this.ranges = newRanges;\n        return this.ranges;\n    }\n}\nfunction mergeLineRangeArray(arr1, arr2) {\n    const result = [];\n    let i = 0;\n    let j = 0;\n    while (i < arr1.length && j < arr2.length) {\n        const item1 = arr1[i];\n        const item2 = arr2[j];\n        if (item1.endLineNumber < item2.startLineNumber - 1) {\n            result.push(arr1[i++]);\n        }\n        else if (item2.endLineNumber < item1.startLineNumber - 1) {\n            result.push(arr2[j++]);\n        }\n        else {\n            const startLineNumber = Math.min(item1.startLineNumber, item2.startLineNumber);\n            const endLineNumber = Math.max(item1.endLineNumber, item2.endLineNumber);\n            result.push(new Range(startLineNumber, 1, endLineNumber, 1));\n            i++;\n            j++;\n        }\n    }\n    while (i < arr1.length) {\n        result.push(arr1[i++]);\n    }\n    while (j < arr2.length) {\n        result.push(arr2[j++]);\n    }\n    return result;\n}\nfunction rangeArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!arr1[i].equalsRange(arr2[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Maintain a stable viewport by trying to keep the first line in the viewport constant.\n */\nclass StableViewport {\n    constructor(viewportStartModelPosition, startLineDelta) {\n        this.viewportStartModelPosition = viewportStartModelPosition;\n        this.startLineDelta = startLineDelta;\n    }\n    recoverViewportStart(coordinatesConverter, viewLayout) {\n        if (!this.viewportStartModelPosition) {\n            return;\n        }\n        const viewPosition = coordinatesConverter.convertModelPositionToViewPosition(this.viewportStartModelPosition);\n        const viewPositionTop = viewLayout.getVerticalOffsetForLineNumber(viewPosition.lineNumber);\n        viewLayout.setScrollPosition({ scrollTop: viewPositionTop + this.startLineDelta }, 1 /* ScrollType.Immediate */);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}