{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../../nls.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nexport function alertFormattingEdits(edits) {\n  edits = edits.filter(edit => edit.range);\n  if (!edits.length) {\n    return;\n  }\n  let {\n    range\n  } = edits[0];\n  for (let i = 1; i < edits.length; i++) {\n    range = Range.plusRange(range, edits[i].range);\n  }\n  const {\n    startLineNumber,\n    endLineNumber\n  } = range;\n  if (startLineNumber === endLineNumber) {\n    if (edits.length === 1) {\n      alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n    } else {\n      alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n    }\n  } else {\n    if (edits.length === 1) {\n      alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n    } else {\n      alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n    }\n  }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n  const result = [];\n  const seen = new ExtensionIdentifierSet();\n  // (1) add all document formatter\n  const docFormatter = documentFormattingEditProvider.ordered(model);\n  for (const formatter of docFormatter) {\n    result.push(formatter);\n    if (formatter.extensionId) {\n      seen.add(formatter.extensionId);\n    }\n  }\n  // (2) add all range formatter as document formatter (unless the same extension already did that)\n  const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n  for (const formatter of rangeFormatter) {\n    if (formatter.extensionId) {\n      if (seen.has(formatter.extensionId)) {\n        continue;\n      }\n      seen.add(formatter.extensionId);\n    }\n    result.push({\n      displayName: formatter.displayName,\n      extensionId: formatter.extensionId,\n      provideDocumentFormattingEdits(model, options, token) {\n        return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n      }\n    });\n  }\n  return result;\n}\nexport class FormattingConflicts {\n  static setFormatterSelector(selector) {\n    const remove = FormattingConflicts._selectors.unshift(selector);\n    return {\n      dispose: remove\n    };\n  }\n  static select(formatter, document, mode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (formatter.length === 0) {\n        return undefined;\n      }\n      const selector = Iterable.first(FormattingConflicts._selectors);\n      if (selector) {\n        return yield selector(formatter, document, mode);\n      }\n      return undefined;\n    });\n  }\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const {\n      documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry\n    } = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n    }\n  });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    const logService = accessor.get(ILogService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    // make sure that ranges don't overlap nor touch each other\n    const ranges = [];\n    let len = 0;\n    for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n      if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n        ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n      } else {\n        len = ranges.push(range);\n      }\n    }\n    const computeEdits = range => __awaiter(this, void 0, void 0, function* () {\n      var _c, _d;\n      logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_c = provider.extensionId) === null || _c === void 0 ? void 0 : _c.value, range);\n      const result = (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n      logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_d = provider.extensionId) === null || _d === void 0 ? void 0 : _d.value, result);\n      return result;\n    });\n    const hasIntersectingEdit = (a, b) => {\n      if (!a.length || !b.length) {\n        return false;\n      }\n      // quick exit if the list of ranges are completely unrelated [O(n)]\n      const mergedA = a.reduce((acc, val) => {\n        return Range.plusRange(acc, val.range);\n      }, a[0].range);\n      if (!b.some(x => {\n        return Range.intersectRanges(mergedA, x.range);\n      })) {\n        return false;\n      }\n      // fallback to a complete check [O(n^2)]\n      for (const edit of a) {\n        for (const otherEdit of b) {\n          if (Range.intersectRanges(edit.range, otherEdit.range)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const allEdits = [];\n    const rawEditsList = [];\n    try {\n      if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_a = provider.extensionId) === null || _a === void 0 ? void 0 : _a.value, ranges);\n        const result = (yield provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n        logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_b = provider.extensionId) === null || _b === void 0 ? void 0 : _b.value, result);\n        rawEditsList.push(result);\n      } else {\n        for (const range of ranges) {\n          if (cts.token.isCancellationRequested) {\n            return true;\n          }\n          rawEditsList.push(yield computeEdits(range));\n        }\n        for (let i = 0; i < ranges.length; ++i) {\n          for (let j = i + 1; j < ranges.length; ++j) {\n            if (cts.token.isCancellationRequested) {\n              return true;\n            }\n            if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n              // Merge ranges i and j into a single range, recompute the associated edits\n              const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n              const edits = yield computeEdits(mergedRange);\n              ranges.splice(j, 1);\n              ranges.splice(i, 1);\n              ranges.push(mergedRange);\n              rawEditsList.splice(j, 1);\n              rawEditsList.splice(i, 1);\n              rawEditsList.push(edits);\n              // Restart scanning\n              i = 0;\n              j = 0;\n            }\n          }\n        }\n      }\n      for (const rawEdits of rawEditsList) {\n        if (cts.token.isCancellationRequested) {\n          return true;\n        }\n        const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n        if (minimalEdits) {\n          allEdits.push(...minimalEdits);\n        }\n      }\n    } finally {\n      cts.dispose();\n    }\n    if (allEdits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, allEdits, true);\n      alertFormattingEdits(allEdits);\n      editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = allEdits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], allEdits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    return true;\n  });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const instaService = accessor.get(IInstantiationService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n    const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    const selected = yield FormattingConflicts.select(provider, model, mode);\n    if (selected) {\n      progress.report(selected);\n      yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n    }\n  });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const workerService = accessor.get(IEditorWorkerService);\n    let model;\n    let cts;\n    if (isCodeEditor(editorOrModel)) {\n      model = editorOrModel.getModel();\n      cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n    } else {\n      model = editorOrModel;\n      cts = new TextModelCancellationTokenSource(editorOrModel, token);\n    }\n    let edits;\n    try {\n      const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n      edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      if (cts.token.isCancellationRequested) {\n        return true;\n      }\n    } finally {\n      cts.dispose();\n    }\n    if (!edits || edits.length === 0) {\n      return false;\n    }\n    if (isCodeEditor(editorOrModel)) {\n      // use editor to apply edits\n      FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n      if (mode !== 2 /* FormattingMode.Silent */) {\n        alertFormattingEdits(edits);\n        editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n      }\n    } else {\n      // use model to apply edits\n      const [{\n        range\n      }] = edits;\n      const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n      model.pushEditOperations([initialSelection], edits.map(edit => {\n        return {\n          text: edit.text,\n          range: Range.lift(edit.range),\n          forceMoveMarkers: true\n        };\n      }), undoEdits => {\n        for (const {\n          range\n        } of undoEdits) {\n          if (Range.areIntersectingOrTouching(range, initialSelection)) {\n            return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n          }\n        }\n        return null;\n      });\n    }\n    return true;\n  });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n    for (const provider of providers) {\n      const rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n    for (const provider of providers) {\n      const rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n      if (isNonEmptyArray(rawEdits)) {\n        return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n      }\n    }\n    return undefined;\n  });\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n  const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n  if (providers.length === 0) {\n    return Promise.resolve(undefined);\n  }\n  if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n    return Promise.resolve(undefined);\n  }\n  return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n    return workerService.computeMoreMinimalEdits(model.uri, edits);\n  });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, range, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Range.isIRange(range));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, options] = args;\n    assertType(URI.isUri(resource));\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const [resource, position, ch, options] = args;\n    assertType(URI.isUri(resource));\n    assertType(Position.isIPosition(position));\n    assertType(typeof ch === 'string');\n    const resolverService = accessor.get(ITextModelService);\n    const workerService = accessor.get(IEditorWorkerService);\n    const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n    const reference = yield resolverService.createModelReference(resource);\n    try {\n      return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n    } finally {\n      reference.dispose();\n    }\n  });\n});","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","alert","asArray","isNonEmptyArray","CancellationToken","onUnexpectedExternalError","Iterable","LinkedList","assertType","URI","EditorStateCancellationTokenSource","TextModelCancellationTokenSource","isCodeEditor","Position","Range","Selection","IEditorWorkerService","ITextModelService","FormattingEdit","nls","CommandsRegistry","ExtensionIdentifierSet","IInstantiationService","ILanguageFeaturesService","ILogService","alertFormattingEdits","edits","filter","edit","range","length","i","plusRange","startLineNumber","endLineNumber","localize","getRealAndSyntheticDocumentFormattersOrdered","documentFormattingEditProvider","documentRangeFormattingEditProvider","model","seen","docFormatter","ordered","formatter","push","extensionId","add","rangeFormatter","has","displayName","provideDocumentFormattingEdits","options","token","provideDocumentRangeFormattingEdits","getFullModelRange","FormattingConflicts","setFormatterSelector","selector","remove","_selectors","unshift","dispose","select","document","mode","undefined","first","formatDocumentRangesWithSelectedProvider","accessor","editorOrModel","rangeOrRanges","progress","instaService","get","documentRangeFormattingEditProviderRegistry","getModel","provider","selected","report","invokeFunction","formatDocumentRangesWithProvider","_a","_b","workerService","logService","cts","ranges","len","sort","compareRangesUsingStarts","areIntersectingOrTouching","fromPositions","getStartPosition","getEndPosition","computeEdits","_c","_d","trace","getFormattingOptions","hasIntersectingEdit","a","b","mergedA","reduce","acc","val","some","x","intersectRanges","otherEdit","allEdits","rawEditsList","provideDocumentRangesFormattingEdits","isCancellationRequested","j","mergedRange","splice","rawEdits","minimalEdits","computeMoreMinimalEdits","uri","execute","revealPositionInCenterIfOutsideViewport","getPosition","initialSelection","startColumn","endColumn","pushEditOperations","map","text","lift","forceMoveMarkers","undoEdits","formatDocumentWithSelectedProvider","languageFeaturesService","formatDocumentWithProvider","getDocumentRangeFormattingEditsUntilResult","providers","catch","getDocumentFormattingEditsUntilResult","getOnTypeFormattingEdits","position","ch","onTypeFormattingEditProvider","autoFormatTriggerCharacters","indexOf","provideOnTypeFormattingEdits","registerCommand","args","resource","isUri","isIRange","resolverService","reference","createModelReference","object","textEditorModel","None","isIPosition"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/contrib/format/browser/format.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { alert } from '../../../../base/browser/ui/aria/aria.js';\nimport { asArray, isNonEmptyArray } from '../../../../base/common/arrays.js';\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { Iterable } from '../../../../base/common/iterator.js';\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { EditorStateCancellationTokenSource, TextModelCancellationTokenSource } from '../../editorState/browser/editorState.js';\nimport { isCodeEditor } from '../../../browser/editorBrowser.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nimport { Selection } from '../../../common/core/selection.js';\nimport { IEditorWorkerService } from '../../../common/services/editorWorker.js';\nimport { ITextModelService } from '../../../common/services/resolverService.js';\nimport { FormattingEdit } from './formattingEdit.js';\nimport * as nls from '../../../../nls.js';\nimport { CommandsRegistry } from '../../../../platform/commands/common/commands.js';\nimport { ExtensionIdentifierSet } from '../../../../platform/extensions/common/extensions.js';\nimport { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nimport { ILogService } from '../../../../platform/log/common/log.js';\nexport function alertFormattingEdits(edits) {\n    edits = edits.filter(edit => edit.range);\n    if (!edits.length) {\n        return;\n    }\n    let { range } = edits[0];\n    for (let i = 1; i < edits.length; i++) {\n        range = Range.plusRange(range, edits[i].range);\n    }\n    const { startLineNumber, endLineNumber } = range;\n    if (startLineNumber === endLineNumber) {\n        if (edits.length === 1) {\n            alert(nls.localize('hint11', \"Made 1 formatting edit on line {0}\", startLineNumber));\n        }\n        else {\n            alert(nls.localize('hintn1', \"Made {0} formatting edits on line {1}\", edits.length, startLineNumber));\n        }\n    }\n    else {\n        if (edits.length === 1) {\n            alert(nls.localize('hint1n', \"Made 1 formatting edit between lines {0} and {1}\", startLineNumber, endLineNumber));\n        }\n        else {\n            alert(nls.localize('hintnn', \"Made {0} formatting edits between lines {1} and {2}\", edits.length, startLineNumber, endLineNumber));\n        }\n    }\n}\nexport function getRealAndSyntheticDocumentFormattersOrdered(documentFormattingEditProvider, documentRangeFormattingEditProvider, model) {\n    const result = [];\n    const seen = new ExtensionIdentifierSet();\n    // (1) add all document formatter\n    const docFormatter = documentFormattingEditProvider.ordered(model);\n    for (const formatter of docFormatter) {\n        result.push(formatter);\n        if (formatter.extensionId) {\n            seen.add(formatter.extensionId);\n        }\n    }\n    // (2) add all range formatter as document formatter (unless the same extension already did that)\n    const rangeFormatter = documentRangeFormattingEditProvider.ordered(model);\n    for (const formatter of rangeFormatter) {\n        if (formatter.extensionId) {\n            if (seen.has(formatter.extensionId)) {\n                continue;\n            }\n            seen.add(formatter.extensionId);\n        }\n        result.push({\n            displayName: formatter.displayName,\n            extensionId: formatter.extensionId,\n            provideDocumentFormattingEdits(model, options, token) {\n                return formatter.provideDocumentRangeFormattingEdits(model, model.getFullModelRange(), options, token);\n            }\n        });\n    }\n    return result;\n}\nexport class FormattingConflicts {\n    static setFormatterSelector(selector) {\n        const remove = FormattingConflicts._selectors.unshift(selector);\n        return { dispose: remove };\n    }\n    static select(formatter, document, mode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (formatter.length === 0) {\n                return undefined;\n            }\n            const selector = Iterable.first(FormattingConflicts._selectors);\n            if (selector) {\n                return yield selector(formatter, document, mode);\n            }\n            return undefined;\n        });\n    }\n}\nFormattingConflicts._selectors = new LinkedList();\nexport function formatDocumentRangesWithSelectedProvider(accessor, editorOrModel, rangeOrRanges, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const { documentRangeFormattingEditProvider: documentRangeFormattingEditProviderRegistry } = accessor.get(ILanguageFeaturesService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = documentRangeFormattingEditProviderRegistry.ordered(model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentRangesWithProvider, selected, editorOrModel, rangeOrRanges, token);\n        }\n    });\n}\nexport function formatDocumentRangesWithProvider(accessor, provider, editorOrModel, rangeOrRanges, token) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        const logService = accessor.get(ILogService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        // make sure that ranges don't overlap nor touch each other\n        const ranges = [];\n        let len = 0;\n        for (const range of asArray(rangeOrRanges).sort(Range.compareRangesUsingStarts)) {\n            if (len > 0 && Range.areIntersectingOrTouching(ranges[len - 1], range)) {\n                ranges[len - 1] = Range.fromPositions(ranges[len - 1].getStartPosition(), range.getEndPosition());\n            }\n            else {\n                len = ranges.push(range);\n            }\n        }\n        const computeEdits = (range) => __awaiter(this, void 0, void 0, function* () {\n            var _c, _d;\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_c = provider.extensionId) === null || _c === void 0 ? void 0 : _c.value, range);\n            const result = (yield provider.provideDocumentRangeFormattingEdits(model, range, model.getFormattingOptions(), cts.token)) || [];\n            logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_d = provider.extensionId) === null || _d === void 0 ? void 0 : _d.value, result);\n            return result;\n        });\n        const hasIntersectingEdit = (a, b) => {\n            if (!a.length || !b.length) {\n                return false;\n            }\n            // quick exit if the list of ranges are completely unrelated [O(n)]\n            const mergedA = a.reduce((acc, val) => { return Range.plusRange(acc, val.range); }, a[0].range);\n            if (!b.some(x => { return Range.intersectRanges(mergedA, x.range); })) {\n                return false;\n            }\n            // fallback to a complete check [O(n^2)]\n            for (const edit of a) {\n                for (const otherEdit of b) {\n                    if (Range.intersectRanges(edit.range, otherEdit.range)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        const allEdits = [];\n        const rawEditsList = [];\n        try {\n            if (typeof provider.provideDocumentRangesFormattingEdits === 'function') {\n                logService.trace(`[format][provideDocumentRangeFormattingEdits] (request)`, (_a = provider.extensionId) === null || _a === void 0 ? void 0 : _a.value, ranges);\n                const result = (yield provider.provideDocumentRangesFormattingEdits(model, ranges, model.getFormattingOptions(), cts.token)) || [];\n                logService.trace(`[format][provideDocumentRangeFormattingEdits] (response)`, (_b = provider.extensionId) === null || _b === void 0 ? void 0 : _b.value, result);\n                rawEditsList.push(result);\n            }\n            else {\n                for (const range of ranges) {\n                    if (cts.token.isCancellationRequested) {\n                        return true;\n                    }\n                    rawEditsList.push(yield computeEdits(range));\n                }\n                for (let i = 0; i < ranges.length; ++i) {\n                    for (let j = i + 1; j < ranges.length; ++j) {\n                        if (cts.token.isCancellationRequested) {\n                            return true;\n                        }\n                        if (hasIntersectingEdit(rawEditsList[i], rawEditsList[j])) {\n                            // Merge ranges i and j into a single range, recompute the associated edits\n                            const mergedRange = Range.plusRange(ranges[i], ranges[j]);\n                            const edits = yield computeEdits(mergedRange);\n                            ranges.splice(j, 1);\n                            ranges.splice(i, 1);\n                            ranges.push(mergedRange);\n                            rawEditsList.splice(j, 1);\n                            rawEditsList.splice(i, 1);\n                            rawEditsList.push(edits);\n                            // Restart scanning\n                            i = 0;\n                            j = 0;\n                        }\n                    }\n                }\n            }\n            for (const rawEdits of rawEditsList) {\n                if (cts.token.isCancellationRequested) {\n                    return true;\n                }\n                const minimalEdits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n                if (minimalEdits) {\n                    allEdits.push(...minimalEdits);\n                }\n            }\n        }\n        finally {\n            cts.dispose();\n        }\n        if (allEdits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, allEdits, true);\n            alertFormattingEdits(allEdits);\n            editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = allEdits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], allEdits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function formatDocumentWithSelectedProvider(accessor, editorOrModel, mode, progress, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const instaService = accessor.get(IInstantiationService);\n        const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n        const model = isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel;\n        const provider = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n        const selected = yield FormattingConflicts.select(provider, model, mode);\n        if (selected) {\n            progress.report(selected);\n            yield instaService.invokeFunction(formatDocumentWithProvider, selected, editorOrModel, mode, token);\n        }\n    });\n}\nexport function formatDocumentWithProvider(accessor, provider, editorOrModel, mode, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const workerService = accessor.get(IEditorWorkerService);\n        let model;\n        let cts;\n        if (isCodeEditor(editorOrModel)) {\n            model = editorOrModel.getModel();\n            cts = new EditorStateCancellationTokenSource(editorOrModel, 1 /* CodeEditorStateFlag.Value */ | 4 /* CodeEditorStateFlag.Position */, undefined, token);\n        }\n        else {\n            model = editorOrModel;\n            cts = new TextModelCancellationTokenSource(editorOrModel, token);\n        }\n        let edits;\n        try {\n            const rawEdits = yield provider.provideDocumentFormattingEdits(model, model.getFormattingOptions(), cts.token);\n            edits = yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            if (cts.token.isCancellationRequested) {\n                return true;\n            }\n        }\n        finally {\n            cts.dispose();\n        }\n        if (!edits || edits.length === 0) {\n            return false;\n        }\n        if (isCodeEditor(editorOrModel)) {\n            // use editor to apply edits\n            FormattingEdit.execute(editorOrModel, edits, mode !== 2 /* FormattingMode.Silent */);\n            if (mode !== 2 /* FormattingMode.Silent */) {\n                alertFormattingEdits(edits);\n                editorOrModel.revealPositionInCenterIfOutsideViewport(editorOrModel.getPosition(), 1 /* ScrollType.Immediate */);\n            }\n        }\n        else {\n            // use model to apply edits\n            const [{ range }] = edits;\n            const initialSelection = new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n            model.pushEditOperations([initialSelection], edits.map(edit => {\n                return {\n                    text: edit.text,\n                    range: Range.lift(edit.range),\n                    forceMoveMarkers: true\n                };\n            }), undoEdits => {\n                for (const { range } of undoEdits) {\n                    if (Range.areIntersectingOrTouching(range, initialSelection)) {\n                        return [new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn)];\n                    }\n                }\n                return null;\n            });\n        }\n        return true;\n    });\n}\nexport function getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, model, range, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = languageFeaturesService.documentRangeFormattingEditProvider.ordered(model);\n        for (const provider of providers) {\n            const rawEdits = yield Promise.resolve(provider.provideDocumentRangeFormattingEdits(model, range, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, model, options, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getRealAndSyntheticDocumentFormattersOrdered(languageFeaturesService.documentFormattingEditProvider, languageFeaturesService.documentRangeFormattingEditProvider, model);\n        for (const provider of providers) {\n            const rawEdits = yield Promise.resolve(provider.provideDocumentFormattingEdits(model, options, token)).catch(onUnexpectedExternalError);\n            if (isNonEmptyArray(rawEdits)) {\n                return yield workerService.computeMoreMinimalEdits(model.uri, rawEdits);\n            }\n        }\n        return undefined;\n    });\n}\nexport function getOnTypeFormattingEdits(workerService, languageFeaturesService, model, position, ch, options, token) {\n    const providers = languageFeaturesService.onTypeFormattingEditProvider.ordered(model);\n    if (providers.length === 0) {\n        return Promise.resolve(undefined);\n    }\n    if (providers[0].autoFormatTriggerCharacters.indexOf(ch) < 0) {\n        return Promise.resolve(undefined);\n    }\n    return Promise.resolve(providers[0].provideOnTypeFormattingEdits(model, position, ch, options, token)).catch(onUnexpectedExternalError).then(edits => {\n        return workerService.computeMoreMinimalEdits(model.uri, edits);\n    });\n}\nCommandsRegistry.registerCommand('_executeFormatRangeProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, range, options] = args;\n        assertType(URI.isUri(resource));\n        assertType(Range.isIRange(range));\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getDocumentRangeFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, Range.lift(range), options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\nCommandsRegistry.registerCommand('_executeFormatDocumentProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, options] = args;\n        assertType(URI.isUri(resource));\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getDocumentFormattingEditsUntilResult(workerService, languageFeaturesService, reference.object.textEditorModel, options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\nCommandsRegistry.registerCommand('_executeFormatOnTypeProvider', function (accessor, ...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [resource, position, ch, options] = args;\n        assertType(URI.isUri(resource));\n        assertType(Position.isIPosition(position));\n        assertType(typeof ch === 'string');\n        const resolverService = accessor.get(ITextModelService);\n        const workerService = accessor.get(IEditorWorkerService);\n        const languageFeaturesService = accessor.get(ILanguageFeaturesService);\n        const reference = yield resolverService.createModelReference(resource);\n        try {\n            return getOnTypeFormattingEdits(workerService, languageFeaturesService, reference.object.textEditorModel, Position.lift(position), ch, options, CancellationToken.None);\n        }\n        finally {\n            reference.dispose();\n        }\n    });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}