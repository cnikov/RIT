{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n  return function (word, wordToMatchAgainst) {\n    for (let i = 0, len = filter.length; i < len; i++) {\n      const match = filter[i](word, wordToMatchAgainst);\n      if (match) {\n        return match;\n      }\n    }\n    return null;\n  };\n}\n// Prefix\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n  let matches;\n  if (ignoreCase) {\n    matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n  if (!matches) {\n    return null;\n  }\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n  if (index === -1) {\n    return null;\n  }\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      let result = null;\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n      return null;\n    }\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n}\n// CamelCase\nfunction isLower(code) {\n  return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\n\nexport function isUpper(code) {\n  return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\n\nfunction isNumber(code) {\n  return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\n\nfunction isWhitespace(code) {\n  return code === 32 /* CharCode.Space */ || code === 9 /* CharCode.Tab */ || code === 10 /* CharCode.LineFeed */ || code === 13 /* CharCode.CarriageReturn */;\n}\n\nconst wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'.split('').forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n  return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n  for (let i = start; i < camelCaseWord.length; i++) {\n    const c = camelCaseWord.charCodeAt(i);\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    let result = null;\n    let nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n  let upper = 0,\n    lower = 0,\n    alpha = 0,\n    numeric = 0,\n    code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n  const upperPercent = upper / word.length;\n  const lowerPercent = lower / word.length;\n  const alphaPercent = alpha / word.length;\n  const numericPercent = numeric / word.length;\n  return {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  };\n}\nfunction isUpperCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent\n  } = analysis;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  } = analysis;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n  let upper = 0,\n    lower = 0,\n    code = 0,\n    whitespace = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n  camelCaseWord = camelCaseWord.trim();\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n  if (camelCaseWord.length > 60) {\n    return null;\n  }\n  const analysis = analyzeCamelCaseWord(camelCaseWord);\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n  return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n  if (!target || target.length === 0) {\n    return null;\n  }\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n  while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n    i = nextWord(target, i + 1);\n  }\n  return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n  if (i === word.length) {\n    return [];\n  } else if (j === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n    return null;\n  } else {\n    let result = null;\n    let nextWordIndex = j + 1;\n    result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n    if (!contiguous) {\n      while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n        result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n        nextWordIndex++;\n      }\n    }\n    if (!result) {\n      return null;\n    }\n    // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n    // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n    if (word.charCodeAt(i) !== target.charCodeAt(j)) {\n      return result;\n    }\n    return join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\nfunction nextWord(word, start) {\n  for (let i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null; // return early for invalid input\n  }\n  // Form RegExp for wildcard matches\n  let regexp = fuzzyRegExpCache.get(word);\n  if (!regexp) {\n    regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  }\n  // RegExp Filter\n  const match = regexp.exec(wordToMatchAgainst);\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  }\n  // Default Filter\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern, word) {\n  const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, {\n    firstMatchCanBeWeak: true,\n    boostFullMatch: true\n  });\n  return score ? createMatches(score) : null;\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n  const max = Math.min(13, pattern.length);\n  for (; patternPos < max; patternPos++) {\n    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, {\n      firstMatchCanBeWeak: true,\n      boostFullMatch: true\n    });\n    if (result) {\n      return result;\n    }\n  }\n  return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n  const res = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n  const table = [];\n  const row = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction initArr(maxLen) {\n  const row = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n  function pad(s, n, pad = ' ') {\n    while (s.length < n) {\n      s = pad + s;\n    }\n    return s;\n  }\n  let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n  for (let i = 0; i <= patternLen; i++) {\n    if (i === 0) {\n      ret += ' |';\n    } else {\n      ret += `${pattern[i - 1]}|`;\n    }\n    ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n  }\n  return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n  pattern = pattern.substr(patternStart);\n  word = word.substr(wordStart);\n  console.log(printTable(_table, pattern, pattern.length, word, word.length));\n  console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n  console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case 95 /* CharCode.Underline */:\n    case 45 /* CharCode.Dash */:\n    case 46 /* CharCode.Period */:\n    case 32 /* CharCode.Space */:\n    case 47 /* CharCode.Slash */:\n    case 92 /* CharCode.Backslash */:\n    case 39 /* CharCode.SingleQuote */:\n    case 34 /* CharCode.DoubleQuote */:\n    case 58 /* CharCode.Colon */:\n    case 36 /* CharCode.DollarSign */:\n    case 60 /* CharCode.LessThan */:\n    case 62 /* CharCode.GreaterThan */:\n    case 40 /* CharCode.OpenParen */:\n    case 41 /* CharCode.CloseParen */:\n    case 91 /* CharCode.OpenSquareBracket */:\n    case 93 /* CharCode.CloseSquareBracket */:\n    case 123 /* CharCode.OpenCurlyBrace */:\n    case 125 /* CharCode.CloseCurlyBrace */:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (strings.isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case 32 /* CharCode.Space */:\n    case 9 /* CharCode.Tab */:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        // Remember the min word position for each pattern position\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen; // pattern must be exhausted\n}\n\nexport var FuzzyScore;\n(function (FuzzyScore) {\n  /**\n   * No matches and value `-100`\n   */\n  FuzzyScore.Default = [-100, 0];\n  function isDefault(score) {\n    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;\n  }\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport class FuzzyScoreOptions {\n  constructor(firstMatchCanBeWeak, boostFullMatch) {\n    this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n    this.boostFullMatch = boostFullMatch;\n  }\n}\nFuzzyScoreOptions.default = {\n  boostFullMatch: true,\n  firstMatchCanBeWeak: false\n};\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n  // Run a simple check if the characters of pattern occur\n  // (in order) at all in word. If that isn't the case we\n  // stop because no match will be possible\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n  // Find the max matching word position for each pattern position\n  // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  let row = 1;\n  let column = 1;\n  let patternPos = patternStart;\n  let wordPos = wordStart;\n  const hasStrongFirstMatch = [false];\n  // There will be a match, fill in tables\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    // Reduce search space to possible matching word positions and to possible access from next row\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3 /* Arrow.LeftLeft */;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        // always prefer choosing left since that means a match is earlier in the word\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2 /* Arrow.Left */;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1 /* Arrow.Diag */;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n  if (_debug) {\n    printTables(pattern, patternStart, word, wordStart);\n  }\n  if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n  while (row >= 1) {\n    // Find the column where we go diagonally up\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === 3 /* Arrow.LeftLeft */) {\n        diagColumn = diagColumn - 2;\n      } else if (arrow === 2 /* Arrow.Left */) {\n        diagColumn = diagColumn - 1;\n      } else {\n        // found the diagonal\n        break;\n      }\n    } while (diagColumn >= 1);\n    // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n    if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n    && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n    && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n    && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n    ) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      // this is a contiguous match\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      // remember the last matched column\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen && options.boostFullMatch) {\n    // the word matches the pattern with all characters!\n    // giving the score a total match boost (to come up ahead other words)\n    result[0] += 2;\n  }\n  // Add 1 penalty for each skipped character in the word\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    // common prefix: `foobar <-> foobaz`\n    //                            ^^^^^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    // hitting upper-case: `foo <-> forOthers`\n    //                              ^^ ^\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    // hitting a separator: `. <-> foo.bar`\n    //                                ^\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    // post separator: `foo <-> bar_foo`\n    //                              ^^^\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n  //\n  if (patternPos === patternStart) {\n    // first character in pattern\n    if (wordPos > wordStart) {\n      // the first pattern character would match a word character that is not at the word start\n      // so introduce a penalty to account for the gap preceding this match\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      // this would be the beginning of a new match (i.e. there would be a gap before this location)\n      score += isGapLocation ? 2 : 0;\n    } else {\n      // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n  if (wordPos + 1 === wordLen) {\n    // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n    // so pretend there is a gap after the last character in the word to normalize things\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n  if (top && !aggressive) {\n    // when using the original pattern yield a result we`\n    // return it unless we are aggressive and try to find\n    // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n    return top;\n  }\n  if (pattern.length >= 3) {\n    // When the pattern is long enough then try a few (max 7)\n    // permutations of the pattern to find a better match. The\n    // permutations only swap neighbouring characters, e.g\n    // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n    const tries = Math.min(7, pattern.length - 1);\n    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n      if (newPattern) {\n        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n        if (candidate) {\n          candidate[0] -= 3; // permutation penalty\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n  return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n  const swap1 = pattern[patternPos];\n  const swap2 = pattern[patternPos + 1];\n  if (swap1 === swap2) {\n    return undefined;\n  }\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n}\n//#endregion","map":{"version":3,"names":["LRUCache","strings","or","filter","word","wordToMatchAgainst","i","len","length","match","matchesStrictPrefix","_matchesPrefix","bind","undefined","matchesPrefix","ignoreCase","matches","startsWithIgnoreCase","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","matchesWords","target","contiguous","_matchesWords","nextWord","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","get","RegExp","convertSimple2RegExpPattern","set","exec","matchesFuzzy2","pattern","score","fuzzyScore","firstMatchCanBeWeak","boostFullMatch","createMatches","anyScore","lowPattern","patternPos","lowWord","wordPos","max","Math","min","res","pos","last","push","_maxLen","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","_debug","printTable","patternLen","wordLen","pad","n","ret","map","toString","printTables","patternStart","wordStart","substr","console","log","isSeparatorAtPos","value","codePointAt","isEmojiImprecise","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","fillMinWordPosArr","FuzzyScore","Default","isDefault","FuzzyScoreOptions","constructor","default","options","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/base/common/filters.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LRUCache } from './map.js';\nimport * as strings from './strings.js';\n// Combined filters\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n// Prefix\nexport const matchesStrictPrefix = _matchesPrefix.bind(undefined, false);\nexport const matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = strings.startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n// Contiguous Substring\nexport function matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\n// Substring\nexport function matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\n// CamelCase\nfunction isLower(code) {\n    return 97 /* CharCode.a */ <= code && code <= 122 /* CharCode.z */;\n}\nexport function isUpper(code) {\n    return 65 /* CharCode.A */ <= code && code <= 90 /* CharCode.Z */;\n}\nfunction isNumber(code) {\n    return 48 /* CharCode.Digit0 */ <= code && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isWhitespace(code) {\n    return (code === 32 /* CharCode.Space */\n        || code === 9 /* CharCode.Tab */\n        || code === 10 /* CharCode.LineFeed */\n        || code === 13 /* CharCode.CarriageReturn */);\n}\nconst wordSeparators = new Set();\n// These are chosen as natural word separators based on writen text.\n// It is a subset of the word separators used by the monaco editor.\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nexport function matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        return null;\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\n// Matches beginning of words supporting non-ASCII languages\n// If `contiguous` is true then matches word with beginnings of the words in the target. E.g. \"pul\" will match \"Git: Pull\"\n// Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\nexport function matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (i < target.length && (result = _matchesWords(word, target, 0, i, contiguous)) === null) {\n        i = nextWord(target, i + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, i, j, contiguous) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(i), target.charCodeAt(j))) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextWordIndex = j + 1;\n        result = _matchesWords(word, target, i + 1, j + 1, contiguous);\n        if (!contiguous) {\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n                result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);\n                nextWordIndex++;\n            }\n        }\n        if (!result) {\n            return null;\n        }\n        // If the characters don't exactly match, then they must be word separators (see charactersMatch(...)).\n        // We don't want to include this in the matches but we don't want to throw the target out all together so we return `result`.\n        if (word.charCodeAt(i) !== target.charCodeAt(j)) {\n            return result;\n        }\n        return join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\n// Fuzzy\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000); // bounded to 10000 elements\nexport function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null; // return early for invalid input\n    }\n    // Form RegExp for wildcard matches\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    // RegExp Filter\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    // Default Filter\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n/**\n * Match pattern against word in a fuzzy way. As in IntelliSense and faster and more\n * powerful than `matchesFuzzy`\n */\nexport function matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    return score ? createMatches(score) : null;\n}\nexport function anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\n//#region --- fuzzyScore ---\nexport function createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen); // min word position for a certain pattern position\nconst _maxWordMatchPos = initArr(2 * _maxLen); // max word position for a certain pattern position\nconst _diag = initTable(); // the length of a contiguous diagonal match\nconst _table = initTable();\nconst _arrows = initTable();\nconst _debug = false;\nfunction printTable(table, pattern, patternLen, word, wordLen) {\n    function pad(s, n, pad = ' ') {\n        while (s.length < n) {\n            s = pad + s;\n        }\n        return s;\n    }\n    let ret = ` |   |${word.split('').map(c => pad(c, 3)).join('|')}\\n`;\n    for (let i = 0; i <= patternLen; i++) {\n        if (i === 0) {\n            ret += ' |';\n        }\n        else {\n            ret += `${pattern[i - 1]}|`;\n        }\n        ret += table[i].slice(0, wordLen + 1).map(n => pad(n.toString(), 3)).join('|') + '\\n';\n    }\n    return ret;\n}\nfunction printTables(pattern, patternStart, word, wordStart) {\n    pattern = pattern.substr(patternStart);\n    word = word.substr(wordStart);\n    console.log(printTable(_table, pattern, pattern.length, word, word.length));\n    console.log(printTable(_arrows, pattern, pattern.length, word, word.length));\n    console.log(printTable(_diag, pattern, pattern.length, word, word.length));\n}\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 /* CharCode.Underline */:\n        case 45 /* CharCode.Dash */:\n        case 46 /* CharCode.Period */:\n        case 32 /* CharCode.Space */:\n        case 47 /* CharCode.Slash */:\n        case 92 /* CharCode.Backslash */:\n        case 39 /* CharCode.SingleQuote */:\n        case 34 /* CharCode.DoubleQuote */:\n        case 58 /* CharCode.Colon */:\n        case 36 /* CharCode.DollarSign */:\n        case 60 /* CharCode.LessThan */:\n        case 62 /* CharCode.GreaterThan */:\n        case 40 /* CharCode.OpenParen */:\n        case 41 /* CharCode.CloseParen */:\n        case 91 /* CharCode.OpenSquareBracket */:\n        case 93 /* CharCode.CloseSquareBracket */:\n        case 123 /* CharCode.OpenCurlyBrace */:\n        case 125 /* CharCode.CloseCurlyBrace */:\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (strings.isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 /* CharCode.Space */:\n        case 9 /* CharCode.Tab */:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nexport function isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                // Remember the min word position for each pattern position\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen; // pattern must be exhausted\n}\nexport var FuzzyScore;\n(function (FuzzyScore) {\n    /**\n     * No matches and value `-100`\n     */\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nexport class FuzzyScoreOptions {\n    constructor(firstMatchCanBeWeak, boostFullMatch) {\n        this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n        this.boostFullMatch = boostFullMatch;\n    }\n}\nFuzzyScoreOptions.default = { boostFullMatch: true, firstMatchCanBeWeak: false };\nexport function fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    // Run a simple check if the characters of pattern occur\n    // (in order) at all in word. If that isn't the case we\n    // stop because no match will be possible\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    // Find the max matching word position for each pattern position\n    // NOTE: the min matching word position was filled in above, in the `isPatternInWord` call\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    // There will be a match, fill in tables\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        // Reduce search space to possible matching word positions and to possible access from next row\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0; // penalty for a gap start\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                // always prefer choosing left left to jump over a diagonal because that means a match is earlier in the word\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 /* Arrow.LeftLeft */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                // always prefer choosing left since that means a match is earlier in the word\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 /* Arrow.Left */;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 /* Arrow.Diag */;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw new Error(`not possible`);\n            }\n        }\n    }\n    if (_debug) {\n        printTables(pattern, patternStart, word, wordStart);\n    }\n    if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        // Find the column where we go diagonally up\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 /* Arrow.LeftLeft */) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 /* Arrow.Left */) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                // found the diagonal\n                break;\n            }\n        } while (diagColumn >= 1);\n        // Overturn the \"forwards\" decision if keeping the \"backwards\" diagonal would give a better match\n        if (backwardsDiagLength > 1 // only if we would have a contiguous match of 3 characters\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] // only if we can do a contiguous match diagonally\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) // only if the forwards chose diagonal is not an uppercase\n            && backwardsDiagLength + 1 > _diag[row][diagColumn] // only if our contiguous match would be longer than the \"forwards\" contiguous match\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            // this is a contiguous match\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            // remember the last matched column\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen && options.boostFullMatch) {\n        // the word matches the pattern with all characters!\n        // giving the score a total match boost (to come up ahead other words)\n        result[0] += 2;\n    }\n    // Add 1 penalty for each skipped character in the word\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        // common prefix: `foobar <-> foobaz`\n        //                            ^^^^^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        // hitting upper-case: `foo <-> forOthers`\n        //                              ^^ ^\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        // hitting a separator: `. <-> foo.bar`\n        //                                ^\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        // post separator: `foo <-> bar_foo`\n        //                              ^^^\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    //\n    if (patternPos === patternStart) { // first character in pattern\n        if (wordPos > wordStart) {\n            // the first pattern character would match a word character that is not at the word start\n            // so introduce a penalty to account for the gap preceding this match\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            // this would be the beginning of a new match (i.e. there would be a gap before this location)\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            // this is part of a contiguous match, so give it a slight bonus, but do so only if it would not be a preferred gap location\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        // we always penalize gaps, but this gives unfair advantages to a match that would match the last character in the word\n        // so pretend there is a gap after the last character in the word to normalize things\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\n//#endregion\n//#region --- graceful ---\nexport function fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n    if (top && !aggressive) {\n        // when using the original pattern yield a result we`\n        // return it unless we are aggressive and try to find\n        // a better alignment, e.g. `cno` -> `^co^ns^ole` or `^c^o^nsole`.\n        return top;\n    }\n    if (pattern.length >= 3) {\n        // When the pattern is long enough then try a few (max 7)\n        // permutations of the pattern to find a better match. The\n        // permutations only swap neighbouring characters, e.g\n        // `cnoso` becomes `conso`, `cnsoo`, `cnoos`.\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n                if (candidate) {\n                    candidate[0] -= 3; // permutation penalty\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\n//#endregion\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}