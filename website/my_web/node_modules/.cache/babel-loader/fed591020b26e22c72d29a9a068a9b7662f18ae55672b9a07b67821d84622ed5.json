{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nexport class BracketSelectionRangeProvider {\n  provideSelectionRanges(model, positions) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const result = [];\n      for (const position of positions) {\n        const bucket = [];\n        result.push(bucket);\n        const ranges = new Map();\n        yield new Promise(resolve => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));\n        yield new Promise(resolve => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));\n      }\n      return result;\n    });\n  }\n  static _bracketsRightYield(resolve, round, model, pos, ranges) {\n    const counts = new Map();\n    const t1 = Date.now();\n    while (true) {\n      if (round >= BracketSelectionRangeProvider._maxRounds) {\n        resolve();\n        break;\n      }\n      if (!pos) {\n        resolve();\n        break;\n      }\n      const bracket = model.bracketPairs.findNextBracket(pos);\n      if (!bracket) {\n        resolve();\n        break;\n      }\n      const d = Date.now() - t1;\n      if (d > BracketSelectionRangeProvider._maxDuration) {\n        setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));\n        break;\n      }\n      if (bracket.bracketInfo.isOpeningBracket) {\n        const key = bracket.bracketInfo.bracketText;\n        // wait for closing\n        const val = counts.has(key) ? counts.get(key) : 0;\n        counts.set(key, val + 1);\n      } else {\n        const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;\n        // process closing\n        let val = counts.has(key) ? counts.get(key) : 0;\n        val -= 1;\n        counts.set(key, Math.max(0, val));\n        if (val < 0) {\n          let list = ranges.get(key);\n          if (!list) {\n            list = new LinkedList();\n            ranges.set(key, list);\n          }\n          list.push(bracket.range);\n        }\n      }\n      pos = bracket.range.getEndPosition();\n    }\n  }\n  static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {\n    const counts = new Map();\n    const t1 = Date.now();\n    while (true) {\n      if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {\n        resolve();\n        break;\n      }\n      if (!pos) {\n        resolve();\n        break;\n      }\n      const bracket = model.bracketPairs.findPrevBracket(pos);\n      if (!bracket) {\n        resolve();\n        break;\n      }\n      const d = Date.now() - t1;\n      if (d > BracketSelectionRangeProvider._maxDuration) {\n        setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));\n        break;\n      }\n      if (!bracket.bracketInfo.isOpeningBracket) {\n        const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;\n        // wait for opening\n        const val = counts.has(key) ? counts.get(key) : 0;\n        counts.set(key, val + 1);\n      } else {\n        const key = bracket.bracketInfo.bracketText;\n        // opening\n        let val = counts.has(key) ? counts.get(key) : 0;\n        val -= 1;\n        counts.set(key, Math.max(0, val));\n        if (val < 0) {\n          const list = ranges.get(key);\n          if (list) {\n            const closing = list.shift();\n            if (list.size === 0) {\n              ranges.delete(key);\n            }\n            const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());\n            const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());\n            bucket.push({\n              range: innerBracket\n            });\n            bucket.push({\n              range: outerBracket\n            });\n            BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);\n          }\n        }\n      }\n      pos = bracket.range.getStartPosition();\n    }\n  }\n  static _addBracketLeading(model, bracket, bucket) {\n    if (bracket.startLineNumber === bracket.endLineNumber) {\n      return;\n    }\n    // xxxxxxxx {\n    //\n    // }\n    const startLine = bracket.startLineNumber;\n    const column = model.getLineFirstNonWhitespaceColumn(startLine);\n    if (column !== 0 && column !== bracket.startColumn) {\n      bucket.push({\n        range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition())\n      });\n      bucket.push({\n        range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition())\n      });\n    }\n    // xxxxxxxx\n    // {\n    //\n    // }\n    const aboveLine = startLine - 1;\n    if (aboveLine > 0) {\n      const column = model.getLineFirstNonWhitespaceColumn(aboveLine);\n      if (column === bracket.startColumn && column !== model.getLineLastNonWhitespaceColumn(aboveLine)) {\n        bucket.push({\n          range: Range.fromPositions(new Position(aboveLine, column), bracket.getEndPosition())\n        });\n        bucket.push({\n          range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition())\n        });\n      }\n    }\n  }\n}\nBracketSelectionRangeProvider._maxDuration = 30;\nBracketSelectionRangeProvider._maxRounds = 2;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","LinkedList","Position","Range","BracketSelectionRangeProvider","provideSelectionRanges","model","positions","position","bucket","push","ranges","Map","_bracketsRightYield","_bracketsLeftYield","round","pos","counts","t1","Date","now","_maxRounds","bracket","bracketPairs","findNextBracket","d","_maxDuration","setTimeout","bracketInfo","isOpeningBracket","key","bracketText","val","has","get","set","getOpeningBrackets","Math","max","list","range","getEndPosition","size","findPrevBracket","closing","shift","delete","innerBracket","fromPositions","getStartPosition","outerBracket","_addBracketLeading","startLineNumber","endLineNumber","startLine","column","getLineFirstNonWhitespaceColumn","startColumn","aboveLine","getLineLastNonWhitespaceColumn"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/browser/bracketSelections.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { LinkedList } from '../../../../base/common/linkedList.js';\nimport { Position } from '../../../common/core/position.js';\nimport { Range } from '../../../common/core/range.js';\nexport class BracketSelectionRangeProvider {\n    provideSelectionRanges(model, positions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = [];\n            for (const position of positions) {\n                const bucket = [];\n                result.push(bucket);\n                const ranges = new Map();\n                yield new Promise(resolve => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));\n                yield new Promise(resolve => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));\n            }\n            return result;\n        });\n    }\n    static _bracketsRightYield(resolve, round, model, pos, ranges) {\n        const counts = new Map();\n        const t1 = Date.now();\n        while (true) {\n            if (round >= BracketSelectionRangeProvider._maxRounds) {\n                resolve();\n                break;\n            }\n            if (!pos) {\n                resolve();\n                break;\n            }\n            const bracket = model.bracketPairs.findNextBracket(pos);\n            if (!bracket) {\n                resolve();\n                break;\n            }\n            const d = Date.now() - t1;\n            if (d > BracketSelectionRangeProvider._maxDuration) {\n                setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));\n                break;\n            }\n            if (bracket.bracketInfo.isOpeningBracket) {\n                const key = bracket.bracketInfo.bracketText;\n                // wait for closing\n                const val = counts.has(key) ? counts.get(key) : 0;\n                counts.set(key, val + 1);\n            }\n            else {\n                const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;\n                // process closing\n                let val = counts.has(key) ? counts.get(key) : 0;\n                val -= 1;\n                counts.set(key, Math.max(0, val));\n                if (val < 0) {\n                    let list = ranges.get(key);\n                    if (!list) {\n                        list = new LinkedList();\n                        ranges.set(key, list);\n                    }\n                    list.push(bracket.range);\n                }\n            }\n            pos = bracket.range.getEndPosition();\n        }\n    }\n    static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {\n        const counts = new Map();\n        const t1 = Date.now();\n        while (true) {\n            if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {\n                resolve();\n                break;\n            }\n            if (!pos) {\n                resolve();\n                break;\n            }\n            const bracket = model.bracketPairs.findPrevBracket(pos);\n            if (!bracket) {\n                resolve();\n                break;\n            }\n            const d = Date.now() - t1;\n            if (d > BracketSelectionRangeProvider._maxDuration) {\n                setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));\n                break;\n            }\n            if (!bracket.bracketInfo.isOpeningBracket) {\n                const key = bracket.bracketInfo.getOpeningBrackets()[0].bracketText;\n                // wait for opening\n                const val = counts.has(key) ? counts.get(key) : 0;\n                counts.set(key, val + 1);\n            }\n            else {\n                const key = bracket.bracketInfo.bracketText;\n                // opening\n                let val = counts.has(key) ? counts.get(key) : 0;\n                val -= 1;\n                counts.set(key, Math.max(0, val));\n                if (val < 0) {\n                    const list = ranges.get(key);\n                    if (list) {\n                        const closing = list.shift();\n                        if (list.size === 0) {\n                            ranges.delete(key);\n                        }\n                        const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());\n                        const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());\n                        bucket.push({ range: innerBracket });\n                        bucket.push({ range: outerBracket });\n                        BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);\n                    }\n                }\n            }\n            pos = bracket.range.getStartPosition();\n        }\n    }\n    static _addBracketLeading(model, bracket, bucket) {\n        if (bracket.startLineNumber === bracket.endLineNumber) {\n            return;\n        }\n        // xxxxxxxx {\n        //\n        // }\n        const startLine = bracket.startLineNumber;\n        const column = model.getLineFirstNonWhitespaceColumn(startLine);\n        if (column !== 0 && column !== bracket.startColumn) {\n            bucket.push({ range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition()) });\n            bucket.push({ range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition()) });\n        }\n        // xxxxxxxx\n        // {\n        //\n        // }\n        const aboveLine = startLine - 1;\n        if (aboveLine > 0) {\n            const column = model.getLineFirstNonWhitespaceColumn(aboveLine);\n            if (column === bracket.startColumn && column !== model.getLineLastNonWhitespaceColumn(aboveLine)) {\n                bucket.push({ range: Range.fromPositions(new Position(aboveLine, column), bracket.getEndPosition()) });\n                bucket.push({ range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition()) });\n            }\n        }\n    }\n}\nBracketSelectionRangeProvider._maxDuration = 30;\nBracketSelectionRangeProvider._maxRounds = 2;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}