{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n  return v && !!v.data;\n}\nexport function isSemanticTokensEdits(v) {\n  return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n  constructor(provider, tokens, error) {\n    this.provider = provider;\n    this.tokens = tokens;\n    this.error = error;\n  }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n  return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n  const groups = registry.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n      let error = null;\n      try {\n        result = yield provider.provideDocumentSemanticTokens(model, provider === lastProvider ? lastResultId : null, token);\n      } catch (err) {\n        error = err;\n        result = null;\n      }\n      if (!result || !isSemanticTokens(result) && !isSemanticTokensEdits(result)) {\n        result = null;\n      }\n      return new DocumentSemanticTokensResult(provider, result, error);\n    })));\n    // Try to return the first result with actual tokens or\n    // the first result which threw an error (!!)\n    for (const result of results) {\n      if (result.error) {\n        throw result.error;\n      }\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n  const result = registry.orderedGroups(model);\n  return result.length > 0 ? result[0] : null;\n}\nclass DocumentRangeSemanticTokensResult {\n  constructor(provider, tokens) {\n    this.provider = provider;\n    this.tokens = tokens;\n  }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n  return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n  const groups = providers.orderedGroups(model);\n  return groups.length > 0 ? groups[0] : [];\n}\nexport function getDocumentRangeSemanticTokens(registry, model, range, token) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n    // Get tokens from all providers at the same time.\n    const results = yield Promise.all(providers.map(provider => __awaiter(this, void 0, void 0, function* () {\n      let result;\n      try {\n        result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n      } catch (err) {\n        onUnexpectedExternalError(err);\n        result = null;\n      }\n      if (!result || !isSemanticTokens(result)) {\n        result = null;\n      }\n      return new DocumentRangeSemanticTokensResult(provider, result);\n    })));\n    // Try to return the first result with actual tokens\n    for (const result of results) {\n      if (result.tokens) {\n        return result;\n      }\n    }\n    // Return the first result, even if it doesn't have tokens\n    if (results.length > 0) {\n      return results[0];\n    }\n    return null;\n  });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n  if (!providers) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n  }\n  return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n    // there is no provider => fall back to a document range semantic tokens provider\n    return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n  }\n  const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n  if (!r) {\n    return undefined;\n  }\n  const {\n    provider,\n    tokens\n  } = r;\n  if (!tokens || !isSemanticTokens(tokens)) {\n    return undefined;\n  }\n  const buff = encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: tokens.data\n  });\n  if (tokens.resultId) {\n    provider.releaseDocumentSemanticTokens(tokens.resultId);\n  }\n  return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentRangeSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n  if (providers.length === 0) {\n    // no providers\n    return undefined;\n  }\n  if (providers.length === 1) {\n    // straight forward case, just a single provider\n    return providers[0].getLegend();\n  }\n  if (!range || !Range.isIRange(range)) {\n    // if no range is provided, we cannot support multiple providers\n    // as we cannot fall back to the one which would give results\n    // => return the first legend for backwards compatibility and print a warning\n    console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n    return providers[0].getLegend();\n  }\n  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n  if (!result) {\n    return undefined;\n  }\n  return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n  const [uri, range] = args;\n  assertType(uri instanceof URI);\n  assertType(Range.isIRange(range));\n  const model = accessor.get(IModelService).getModel(uri);\n  if (!model) {\n    return undefined;\n  }\n  const {\n    documentRangeSemanticTokensProvider\n  } = accessor.get(ILanguageFeaturesService);\n  const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n  if (!result || !result.tokens) {\n    // there is no provider or it didn't return tokens\n    return undefined;\n  }\n  return encodeSemanticTokensDto({\n    id: 0,\n    type: 'full',\n    data: result.tokens.data\n  });\n}));","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","CancellationToken","onUnexpectedExternalError","URI","IModelService","CommandsRegistry","ICommandService","assertType","encodeSemanticTokensDto","Range","ILanguageFeaturesService","isSemanticTokens","v","data","isSemanticTokensEdits","Array","isArray","edits","DocumentSemanticTokensResult","constructor","provider","tokens","error","hasDocumentSemanticTokensProvider","registry","model","has","getDocumentSemanticTokensProviders","groups","orderedGroups","length","getDocumentSemanticTokens","lastProvider","lastResultId","token","providers","results","all","map","provideDocumentSemanticTokens","err","_getDocumentSemanticTokensProviderHighestGroup","DocumentRangeSemanticTokensResult","hasDocumentRangeSemanticTokensProvider","getDocumentRangeSemanticTokensProviders","getDocumentRangeSemanticTokens","range","provideDocumentRangeSemanticTokens","registerCommand","accessor","args","uri","get","getModel","undefined","documentSemanticTokensProvider","executeCommand","getLegend","getFullModelRange","r","None","buff","id","type","resultId","releaseDocumentSemanticTokens","documentRangeSemanticTokensProvider","isIRange","console","warn","lift"],"sources":["/home/chlohest/work/website/my_web/node_modules/monaco-editor/esm/vs/editor/contrib/semanticTokens/common/getSemanticTokens.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { CancellationToken } from '../../../../base/common/cancellation.js';\nimport { onUnexpectedExternalError } from '../../../../base/common/errors.js';\nimport { URI } from '../../../../base/common/uri.js';\nimport { IModelService } from '../../../common/services/model.js';\nimport { CommandsRegistry, ICommandService } from '../../../../platform/commands/common/commands.js';\nimport { assertType } from '../../../../base/common/types.js';\nimport { encodeSemanticTokensDto } from '../../../common/services/semanticTokensDto.js';\nimport { Range } from '../../../common/core/range.js';\nimport { ILanguageFeaturesService } from '../../../common/services/languageFeatures.js';\nexport function isSemanticTokens(v) {\n    return v && !!(v.data);\n}\nexport function isSemanticTokensEdits(v) {\n    return v && Array.isArray(v.edits);\n}\nexport class DocumentSemanticTokensResult {\n    constructor(provider, tokens, error) {\n        this.provider = provider;\n        this.tokens = tokens;\n        this.error = error;\n    }\n}\nexport function hasDocumentSemanticTokensProvider(registry, model) {\n    return registry.has(model);\n}\nfunction getDocumentSemanticTokensProviders(registry, model) {\n    const groups = registry.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentSemanticTokens(registry, model, lastProvider, lastResultId, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentSemanticTokensProviders(registry, model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            let error = null;\n            try {\n                result = yield provider.provideDocumentSemanticTokens(model, (provider === lastProvider ? lastResultId : null), token);\n            }\n            catch (err) {\n                error = err;\n                result = null;\n            }\n            if (!result || (!isSemanticTokens(result) && !isSemanticTokensEdits(result))) {\n                result = null;\n            }\n            return new DocumentSemanticTokensResult(provider, result, error);\n        })));\n        // Try to return the first result with actual tokens or\n        // the first result which threw an error (!!)\n        for (const result of results) {\n            if (result.error) {\n                throw result.error;\n            }\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nfunction _getDocumentSemanticTokensProviderHighestGroup(registry, model) {\n    const result = registry.orderedGroups(model);\n    return (result.length > 0 ? result[0] : null);\n}\nclass DocumentRangeSemanticTokensResult {\n    constructor(provider, tokens) {\n        this.provider = provider;\n        this.tokens = tokens;\n    }\n}\nexport function hasDocumentRangeSemanticTokensProvider(providers, model) {\n    return providers.has(model);\n}\nfunction getDocumentRangeSemanticTokensProviders(providers, model) {\n    const groups = providers.orderedGroups(model);\n    return (groups.length > 0 ? groups[0] : []);\n}\nexport function getDocumentRangeSemanticTokens(registry, model, range, token) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const providers = getDocumentRangeSemanticTokensProviders(registry, model);\n        // Get tokens from all providers at the same time.\n        const results = yield Promise.all(providers.map((provider) => __awaiter(this, void 0, void 0, function* () {\n            let result;\n            try {\n                result = yield provider.provideDocumentRangeSemanticTokens(model, range, token);\n            }\n            catch (err) {\n                onUnexpectedExternalError(err);\n                result = null;\n            }\n            if (!result || !isSemanticTokens(result)) {\n                result = null;\n            }\n            return new DocumentRangeSemanticTokensResult(provider, result);\n        })));\n        // Try to return the first result with actual tokens\n        for (const result of results) {\n            if (result.tokens) {\n                return result;\n            }\n        }\n        // Return the first result, even if it doesn't have tokens\n        if (results.length > 0) {\n            return results[0];\n        }\n        return null;\n    });\n}\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = _getDocumentSemanticTokensProviderHighestGroup(documentSemanticTokensProvider, model);\n    if (!providers) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokensLegend', uri);\n    }\n    return providers[0].getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    if (!hasDocumentSemanticTokensProvider(documentSemanticTokensProvider, model)) {\n        // there is no provider => fall back to a document range semantic tokens provider\n        return accessor.get(ICommandService).executeCommand('_provideDocumentRangeSemanticTokens', uri, model.getFullModelRange());\n    }\n    const r = yield getDocumentSemanticTokens(documentSemanticTokensProvider, model, null, null, CancellationToken.None);\n    if (!r) {\n        return undefined;\n    }\n    const { provider, tokens } = r;\n    if (!tokens || !isSemanticTokens(tokens)) {\n        return undefined;\n    }\n    const buff = encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: tokens.data\n    });\n    if (tokens.resultId) {\n        provider.releaseDocumentSemanticTokens(tokens.resultId);\n    }\n    return buff;\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokensLegend', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const providers = getDocumentRangeSemanticTokensProviders(documentRangeSemanticTokensProvider, model);\n    if (providers.length === 0) {\n        // no providers\n        return undefined;\n    }\n    if (providers.length === 1) {\n        // straight forward case, just a single provider\n        return providers[0].getLegend();\n    }\n    if (!range || !Range.isIRange(range)) {\n        // if no range is provided, we cannot support multiple providers\n        // as we cannot fall back to the one which would give results\n        // => return the first legend for backwards compatibility and print a warning\n        console.warn(`provideDocumentRangeSemanticTokensLegend might be out-of-sync with provideDocumentRangeSemanticTokens unless a range argument is passed in`);\n        return providers[0].getLegend();\n    }\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result) {\n        return undefined;\n    }\n    return result.provider.getLegend();\n}));\nCommandsRegistry.registerCommand('_provideDocumentRangeSemanticTokens', (accessor, ...args) => __awaiter(void 0, void 0, void 0, function* () {\n    const [uri, range] = args;\n    assertType(uri instanceof URI);\n    assertType(Range.isIRange(range));\n    const model = accessor.get(IModelService).getModel(uri);\n    if (!model) {\n        return undefined;\n    }\n    const { documentRangeSemanticTokensProvider } = accessor.get(ILanguageFeaturesService);\n    const result = yield getDocumentRangeSemanticTokens(documentRangeSemanticTokensProvider, model, Range.lift(range), CancellationToken.None);\n    if (!result || !result.tokens) {\n        // there is no provider or it didn't return tokens\n        return undefined;\n    }\n    return encodeSemanticTokensDto({\n        id: 0,\n        type: 'full',\n        data: result.tokens.data\n    });\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}